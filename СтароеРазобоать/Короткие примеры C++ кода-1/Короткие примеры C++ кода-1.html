<!DOCTYPE html>
<!-- saved from url=(0051)https://teccxx.neocities.org/mx1/cpp_listing_1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Кувшинов Д.Р.">
  <meta name="dcterms.date" content="2015-01-01">
  <title>Короткие примеры C++ кода-1</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="./Короткие примеры C++ кода-1_files/main.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Короткие примеры C++ кода-1</h1>
<h2 class="author">Кувшинов Д.Р.</h2>
<h3 class="date">2015</h3>
</header>
<nav id="TOC">
<ul>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#minimal_program.cpp">0010-minimal_program.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#comments.cpp">0020-comments.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#return.cpp">0030-return.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#hello.cpp">0040-hello.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#exit_success.cpp">0050-exit_success.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#string_variable.cpp">0060-string_variable.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#endl_string_variable.cpp">0070-endl_string_variable.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#using_namespace.cpp">0080-using_namespace.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#russian_win32.cpp">0085-russian_win32.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#russian_win32_cpp.cpp">0086-russian_win32_cpp.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#cin.cpp">0090-cin.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#getline.cpp">0100-getline.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#string_concat.cpp">0110-string_concat.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#var_assign_expr.cpp">0120-var_assign_expr.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#combined_assignment.cpp">0130-combined_assignment.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#basic_arith.cpp">0140-basic_arith.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#quot_rem.cpp">0150-quot_rem.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#double.cpp">0160-double.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#cout_precision.cpp">0170-cout_precision.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#cmath.cpp">0180-cmath.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#function_log.cpp">0190-function_log.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#file_scope_using_namespace.cpp">0200-file_scope_using_namespace.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#units_conversion.cpp">0210-units_conversion.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#if.cpp">0220-if.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#bool_expr.cpp">0230-bool_expr.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#bool_pred.cpp">0240-bool_pred.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#while_true.cpp">0250-while_true.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#while_cin.cpp">0260-while_cin.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#for_cin.cpp">0270-for_cin.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#cin_delay.cpp">0275-cin_delay.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#cin_delay_eof_exit.cpp">0276-cin_delay_eof_exit.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#circle_const.cpp">0280-circle_const.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#complex_bool_expr.cpp">0290-complex_bool_expr.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#ternary_operator.cpp">0300-ternary_operator.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#for.cpp">0310-for.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#for_for.cpp">0320-for_for.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#products_table.cpp">0330-products_table.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#iomanip_setw.cpp">0340-iomanip_setw.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#cat.cpp">0350-cat.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#cat_2.cpp">0351-cat_2.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#char_subst.cpp">0355-char_subst.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#count_lines.cpp">0360-count_lines.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#size_t.cpp">0370-size_t.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#line_unique_0.cpp">0380-line_unique_0.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#line_unique.cpp">0390-line_unique.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#spinning_pipe.cpp">0395-spinning_pipe.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#spinning_pipe_waiting.cpp">0396-spinning_pipe_waiting.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#reverse_lines.cpp">0398-reverse_lines.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#void_list.cpp">0399-void_list.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#solve_linear_0.cpp">0400-solve_linear_0.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#solve_linear_ref.cpp">0410-solve_linear_ref.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#switch_case_0.cpp">0420-switch_case_0.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#switch_case.cpp">0430-switch_case.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#solve_quadratic.cpp">0440-solve_quadratic.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#assert_0.cpp">0450-assert_0.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#solve_transcend_0.cpp">0460-solve_transcend_0.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#solve_transcend.cpp">0470-solve_transcend.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#array_initialization.cpp">0499-array_initialization.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#positives_negatives.cpp">0500-positives_negatives.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#positives_negatives_2.cpp">0501-positives_negatives_2.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#static_array_begin_end.cpp">0505-static_array_begin_end.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#euclid_norm.cpp">0510-euclid_norm.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#euclid_norm_2.cpp">0520-euclid_norm_2.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#max_duplicates_sequence.cpp">0530-max_duplicates_sequence.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#digit_freqs.cpp">0540-digit_freqs.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#cstring_array.cpp">0545-cstring_array.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#remove_comments_simple.cpp">0550-remove_comments_simple.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#simple_tokenize.cpp">0560-simple_tokenize.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#login.c">0565-login.c</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#longest_palindromic_substring_a.cpp">0570-longest_palindromic_substring_a.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#longest_palindromic_substring_b.cpp">0580-longest_palindromic_substring_b.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#longest_palindromic_substring_c.cpp">0590-longest_palindromic_substring_c.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#function_ptr_solve.cpp">0600-function_ptr_solve.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#nsolve_callback.cpp">0605-nsolve_callback.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#global_solve.cpp">0610-global_solve.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#isqrt.cpp">0620-isqrt.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#polynomials_estrin2.cpp">0650-polynomials_estrin2.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#amatrix.hpp">0700-amatrix.hpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#transpose_naive.cpp">0710-transpose_naive.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#matrix_zero_block.cpp">0720-matrix_zero_block.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#matrix_multiply.cpp">0730-matrix_multiply.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#cvarargs.cpp">0740-cvarargs.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#recursion.cpp">0750-recursion.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#memoized_fib.cpp">0755-memoized_fib.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#memoized_fib_thread_local.cpp">0756-memoized_fib_thread_local.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#prefix_calc.cpp">0760-prefix_calc.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#postfix_calc.cpp">0770-postfix_calc.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#postfix_calc_tc.cpp">0771-postfix_calc_tc.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#postfix_calc_stack.cpp">0780-postfix_calc_stack.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#postfix_calc_stack_std.cpp">0781-postfix_calc_stack_std.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#prefix_calc_stack_std.cpp">0790-prefix_calc_stack_std.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#infix_calc.cpp">0800-infix_calc.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#infix_calc_tc.cpp">0801-infix_calc_tc.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#infix_calc_tc_2.cpp">0802-infix_calc_tc_2.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#infix_calc_p.cpp">0810-infix_calc_p.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#infix_calc_p_stack_std.cpp">0820-infix_calc_p_stack_std.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#infix_calc_shunting_yard.cpp">0830-infix_calc_shunting_yard.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#merge_sort.cpp">0840-merge_sort.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#sll_merge_sort.cpp">0845-sll_merge_sort.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#quick_sort.cpp">0850-quick_sort.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#bitmap_works.cpp">0860-bitmap_works.cpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#ageo2d.hpp">0900-ageo2d.hpp</a></li>
<li><a href="https://teccxx.neocities.org/mx1/cpp_listing_1.html#jarvis.cpp">0910-jarvis.cpp</a></li>
</ul>
</nav>
<hr>
<p><a href="https://teccxx.neocities.org/mx1/index.html#contents">Общее оглавление</a></p>
<hr>
<p>Все примеры, представленные в данном наборе доступны в виде отдельных .cpp-файлов в папке cpp1.</p>
<h1 id="minimal_program.cpp">0010-minimal_program.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
}</code></pre></div>
<p><br>
</p>
<h1 id="comments.cpp">0020-comments.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// Это однострочный комментарий.</span>
<span class="co">/* Это многострочный комментарий.</span>
<span class="co">Наша программа ничего не делает.</span>
<span class="co"> */</span>
<span class="dt">int</span> main()
{
}</code></pre></div>
<p><br>
</p>
<h1 id="return.cpp">0030-return.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">/*</span>
<span class="co"> * Это многострочный комментарий.</span>
<span class="co"> * Наша программа ничего не делает.</span>
<span class="co"> */</span>
<span class="dt">int</span> main()
{
  <span class="kw">return</span> <span class="dv">0</span>; <span class="co">// Возвратим ОС "код результата работы".</span>
}</code></pre></div>
<p><br>
</p>
<h1 id="hello.cpp">0040-hello.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// hello.cpp</span>
<span class="co">// Подключить стандартные потоки текстового ввода-вывода.</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main()
{
  std::cout &lt;&lt; <span class="st">"Hello, user!"</span>;
  <span class="kw">return</span> <span class="dv">0</span>; <span class="co">// Возвратим ОС "код результата работы".</span>
}</code></pre></div>
<p><br>
</p>
<h1 id="exit_success.cpp">0050-exit_success.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// exit_success.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>

<span class="dt">int</span> main()
{
  std::cout &lt;&lt; <span class="st">"Hello, user!"</span>;
  <span class="kw">return</span> EXIT_SUCCESS; <span class="co">// Возвратим ОС "код успеха".</span>
}</code></pre></div>
<p><br>
</p>
<h1 id="string_variable.cpp">0060-string_variable.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// string_variable.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="co">// Строки C++.</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="dt">int</span> main()
{
  std::string user_name = <span class="st">"user"</span>; <span class="co">// Определить переменную.</span>
  std::cout &lt;&lt; <span class="st">"Hello, "</span> &lt;&lt; user_name &lt;&lt; <span class="st">"!"</span>;
  <span class="kw">return</span> EXIT_SUCCESS; <span class="co">// Возвратим ОС "код успеха".</span>
}</code></pre></div>
<p><br>
</p>
<h1 id="endl_string_variable.cpp">0070-endl_string_variable.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// endl_string_variable.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="co">// Строки C++.</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="dt">int</span> main()
{
  std::string user_name = <span class="st">"user"</span>; <span class="co">// Определить переменную.</span>
  std::cout &lt;&lt; <span class="st">"Hello, "</span> &lt;&lt; user_name &lt;&lt; <span class="st">"!"</span> &lt;&lt; std::endl;

  user_name = <span class="st">"The Great Whale"</span>; <span class="co">// Изменить значение переменной.</span>
  std::cout &lt;&lt; <span class="st">"I am "</span> &lt;&lt; user_name;
  <span class="kw">return</span> EXIT_SUCCESS; <span class="co">// Возвратим ОС "код успеха".</span>
}</code></pre></div>
<p><br>
</p>
<h1 id="using_namespace.cpp">0080-using_namespace.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// using_namespace.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="co">// Строки C++.</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std; <span class="co">// Искать имена в std.</span>

  string user_name = <span class="st">"user"</span>; <span class="co">// Определить переменную.</span>
  cout &lt;&lt; <span class="st">"Hello, "</span> &lt;&lt; user_name &lt;&lt; <span class="st">"!"</span> &lt;&lt; endl;

  user_name = <span class="st">"The Great Whale"</span>; <span class="co">// Изменить значение переменной.</span>
  cout &lt;&lt; <span class="st">"I am "</span> &lt;&lt; user_name;
  <span class="kw">return</span> EXIT_SUCCESS; <span class="co">// Возвратим ОС "код успеха".</span>
}</code></pre></div>
<p><br>
</p>
<h1 id="russian_win32.cpp">0085-russian_win32.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// russian_win32.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;clocale&gt;</span>

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  setlocale(LC_ALL, <span class="st">"Russian"</span>);
  cout &lt;&lt; <span class="st">"Текст"</span> &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="russian_win32_cpp.cpp">0086-russian_win32_cpp.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// russian_win32_cpp.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;locale&gt;</span>

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  locale::global(locale(<span class="st">"Russian"</span>));
  cout &lt;&lt; <span class="st">"Текст"</span> &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="cin.cpp">0090-cin.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// cin.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std; <span class="co">// Искать имена в std.</span>

  string user_name = <span class="st">"user"</span>; <span class="co">// Определить переменную.</span>
  cout &lt;&lt; <span class="st">"Login: "</span>;
  cin &gt;&gt; user_name; <span class="co">// Считать слово из потока ввода.</span>
  cout &lt;&lt; <span class="st">"Hello, "</span> &lt;&lt; user_name &lt;&lt; <span class="st">"!"</span> &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS; <span class="co">// Возвратим ОС "код успеха".</span>
}</code></pre></div>
<p><br>
</p>
<h1 id="getline.cpp">0100-getline.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// getline.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std; <span class="co">// Искать имена в std.</span>

  string user_name = <span class="st">"user"</span>; <span class="co">// Определить переменную.</span>
  cout &lt;&lt; <span class="st">"Login: "</span>;
  getline(cin, user_name); <span class="co">// Считать строку из потока ввода.</span>
  cout &lt;&lt; <span class="st">"Hello, "</span> &lt;&lt; user_name &lt;&lt; <span class="st">"!"</span> &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS; <span class="co">// Возвратим ОС "код успеха".</span>
}</code></pre></div>
<p><br>
</p>
<h1 id="string_concat.cpp">0110-string_concat.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// string_concat.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;

  string line1, line2; <span class="co">// Сразу две переменные, пустые строки.</span>
  getline(cin, line1);
  getline(cin, line2);

  cout &lt;&lt; (line1 + line2) &lt;&lt; endl; <span class="co">// + "склеивает" строки.</span>
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="var_assign_expr.cpp">0120-var_assign_expr.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// var_assign_expr.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;

  string line1, line2; <span class="co">// Сразу две переменные, пустые строки.</span>
  getline(cin, line1);
  getline(cin, line2);

  line1 = line1 + line2; <span class="co">// Заменить первую строку на результат "склеивания".</span>
  cout &lt;&lt; line1 &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="combined_assignment.cpp">0130-combined_assignment.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// combined_assignment.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;

  string line1, line2; <span class="co">// Сразу две переменные, пустые строки.</span>
  getline(cin, line1);
  getline(cin, line2);

  <span class="co">// То же, что line1 = line1 + line2, но без создания временного объекта.</span>
  line1 += line2; <span class="co">// Заменить первую строку на результат "склеивания".</span>
  cout &lt;&lt; line1 &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="basic_arith.cpp">0140-basic_arith.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// basic_arith.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;

  <span class="dt">int</span> a = <span class="dv">0</span>, b = <span class="dv">0</span>; <span class="co">// Целые числа.</span>
  cout &lt;&lt; <span class="st">"a = "</span>;
  cin &gt;&gt; a;
  cout &lt;&lt; <span class="st">"b = "</span>;
  cin &gt;&gt; b;

  cout &lt;&lt; <span class="st">"(a + 2b) (a - 2b) = "</span>;
  cout &lt;&lt; (a + <span class="dv">2</span>*b) * (a - <span class="dv">2</span>*b) &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="quot_rem.cpp">0150-quot_rem.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// quot_rem.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;

  <span class="dt">int</span> a = <span class="dv">0</span>, b = <span class="dv">0</span>; <span class="co">// Целые числа.</span>
  cout &lt;&lt; <span class="st">"a = "</span>;
  cin &gt;&gt; a;
  cout &lt;&lt; <span class="st">"b = "</span>;
  cin &gt;&gt; b;

  cout &lt;&lt; <span class="st">"quotient a:b  = "</span> &lt;&lt; a / b &lt;&lt; endl;
  cout &lt;&lt; <span class="st">"remainder a:b = "</span> &lt;&lt; a % b &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="double.cpp">0160-double.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// double.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;

  <span class="dt">double</span> a = <span class="dv">0</span>, b = <span class="dv">0</span>; <span class="co">// Числа с плавающей запятой.</span>
  cout &lt;&lt; <span class="st">"a = "</span>;
  cin &gt;&gt; a;
  cout &lt;&lt; <span class="st">"b = "</span>;
  cin &gt;&gt; b;

  cout &lt;&lt; <span class="st">"quotient a:b  = "</span> &lt;&lt; a / b &lt;&lt; endl;
  <span class="co">//cout &lt;&lt; "remainder a:b = " &lt;&lt; a % b &lt;&lt; endl;</span>
  <span class="co">// Операция взятия остатка не определена.</span>
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="cout_precision.cpp">0170-cout_precision.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// cout_precision.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;

  <span class="dt">double</span> a = <span class="dv">0</span>, b = <span class="dv">0</span>; <span class="co">// Числа с плавающей запятой.</span>
  cout &lt;&lt; <span class="st">"a = "</span>;
  cin &gt;&gt; a;
  cout &lt;&lt; <span class="st">"b = "</span>;
  cin &gt;&gt; b;

  cout.precision(<span class="dv">16</span>); <span class="co">// 16 значащих знаков.</span>
  cout &lt;&lt; <span class="st">"quotient a:b  = "</span> &lt;&lt; a / b &lt;&lt; endl;
  <span class="co">//cout &lt;&lt; "remainder a:b = " &lt;&lt; a % b &lt;&lt; endl;</span>
  <span class="co">// Операция взятия остатка не определена.</span>
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="cmath.cpp">0180-cmath.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// cmath.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="co">// "Математические функции".</span>
<span class="ot">#include &lt;cmath&gt;</span>

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;

  <span class="dt">double</span> a = <span class="dv">0</span>, b = <span class="dv">0</span>; <span class="co">// Числа с плавающей запятой.</span>
  cout &lt;&lt; <span class="st">"a = "</span>;
  cin &gt;&gt; a;
  cout &lt;&lt; <span class="st">"b = "</span>;
  cin &gt;&gt; b;

  cout.precision(<span class="dv">16</span>); <span class="co">// 16 значащих знаков.</span>
  cout &lt;&lt; <span class="st">"a to b power  = "</span> &lt;&lt; pow(a, b) &lt;&lt; endl;
  <span class="co">//cout &lt;&lt; "remainder a:b = " &lt;&lt; a % b &lt;&lt; endl;</span>
  <span class="co">// Операция взятия остатка не определена.</span>
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="function_log.cpp">0190-function_log.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// function_log.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="co">// "Математические функции".</span>
<span class="ot">#include &lt;cmath&gt;</span>

<span class="co">// Определение своей функции.</span>
<span class="dt">double</span> log(<span class="dt">double</span> base, <span class="dt">double</span> arg)
{
  <span class="co">// Через стандартный натуральный логарифм.</span>
  <span class="kw">return</span> std::log(arg) / std::log(base);
}


<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;

  <span class="dt">double</span> a = <span class="dv">0</span>, b = <span class="dv">0</span>; <span class="co">// Числа с плавающей запятой.</span>
  cout &lt;&lt; <span class="st">"a = "</span>;
  cin &gt;&gt; a;
  cout &lt;&lt; <span class="st">"b = "</span>;
  cin &gt;&gt; b;

  cout.precision(<span class="dv">16</span>); <span class="co">// 16 значащих знаков.</span>
  cout &lt;&lt; <span class="st">"log(b, a)  = "</span> &lt;&lt; log(b, a) &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="file_scope_using_namespace.cpp">0200-file_scope_using_namespace.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// file_scope_using_namespace.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="co">// "Математические функции".</span>
<span class="ot">#include &lt;cmath&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Определение своей функции.</span>
<span class="dt">double</span> log(<span class="dt">double</span> base, <span class="dt">double</span> arg)
{
  <span class="co">// Через стандартный натуральный логарифм.</span>
  <span class="kw">return</span> log(arg) / log(base);
}


<span class="dt">int</span> main()
{
  <span class="dt">double</span> a = <span class="dv">0</span>, b = <span class="dv">0</span>; <span class="co">// Числа с плавающей запятой.</span>
  cout &lt;&lt; <span class="st">"a = "</span>;
  cin &gt;&gt; a;
  cout &lt;&lt; <span class="st">"b = "</span>;
  cin &gt;&gt; b;

  cout.precision(<span class="dv">16</span>); <span class="co">// 16 значащих знаков.</span>
  cout &lt;&lt; <span class="st">"log(b, a)  = "</span> &lt;&lt; log(b, a) &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="units_conversion.cpp">0210-units_conversion.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// units_conversion.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>

<span class="co">// Дюймы in в метры.</span>
<span class="dt">double</span> in2m(<span class="dt">double</span> in) { <span class="kw">return</span> <span class="fl">0.0254</span> * in; }

<span class="co">// Футы ft в метры.</span>
<span class="dt">double</span> ft2m(<span class="dt">double</span> ft) { <span class="kw">return</span> <span class="fl">0.304</span> * ft; }

<span class="co">// Метры m в дюймы.</span>
<span class="dt">double</span> m2in(<span class="dt">double</span> m) { <span class="kw">return</span> m / <span class="fl">0.0254</span>; }

<span class="co">// Метры m в футы.</span>
<span class="dt">double</span> m2ft(<span class="dt">double</span> m) { <span class="kw">return</span> m / <span class="fl">0.304</span>; }

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  cout &lt;&lt; <span class="st">"Enter length: "</span>;
  <span class="dt">double</span> len = <span class="fl">0.0</span>;
  cin &gt;&gt; len;
  cout &lt;&lt; <span class="st">"in to m = "</span> &lt;&lt; in2m(len) &lt;&lt; endl;
  cout &lt;&lt; <span class="st">"ft to m = "</span> &lt;&lt; ft2m(len) &lt;&lt; endl;
  cout &lt;&lt; <span class="st">"m to in = "</span> &lt;&lt; m2in(len) &lt;&lt; endl;
  cout &lt;&lt; <span class="st">"m to ft = "</span> &lt;&lt; m2ft(len) &lt;&lt; endl;
  cout &lt;&lt; <span class="st">"in to ft = "</span> &lt;&lt; m2ft(in2m(len)) &lt;&lt; endl;
  cout &lt;&lt; <span class="st">"ft to in = "</span> &lt;&lt; m2in(ft2m(len)) &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="if.cpp">0220-if.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// if.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main()
{
  <span class="dt">double</span> x = <span class="dv">0</span>;
  cout &lt;&lt; <span class="st">"x = "</span>;
  cin &gt;&gt; x;
  cout &lt;&lt; <span class="st">"x*x "</span>;
  <span class="kw">if</span> (x*x &lt; <span class="dv">2</span>) <span class="co">// Условие.</span>
    cout &lt;&lt; <span class="st">" &lt; "</span>;
  <span class="kw">else</span> <span class="co">// Альтернатива.</span>
    cout &lt;&lt; <span class="st">" &gt; "</span>;
  cout &lt;&lt; <span class="st">"2"</span> &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="bool_expr.cpp">0230-bool_expr.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// bool_expr.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main()
{
  <span class="dt">double</span> x = <span class="dv">0</span>;
  cout &lt;&lt; <span class="st">"x = "</span>;
  cin &gt;&gt; x;
  <span class="co">// Логическое выражение.</span>
  cout &lt;&lt; <span class="st">"x*x &lt; 2  == "</span> &lt;&lt; (x*x &lt; <span class="dv">2</span>) &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="bool_pred.cpp">0240-bool_pred.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// bool_pred.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Определение своей функции-предиката.</span>
<span class="co">// Проверяет условие: x в квадрате меньше 2.</span>
<span class="dt">bool</span> sqr_lt_2(<span class="dt">double</span> x)
{
  <span class="kw">return</span> x*x &lt; <span class="dv">2</span>;
}


<span class="dt">int</span> main()
{
  <span class="dt">double</span> x = <span class="dv">0</span>;
  cout &lt;&lt; <span class="st">"x = "</span>;
  cin &gt;&gt; x;
  cout &lt;&lt; <span class="st">"x*x &lt; 2  == "</span> &lt;&lt; sqr_lt_2(x) &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="while_true.cpp">0250-while_true.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// while_true.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Определение своей функции-предиката.</span>
<span class="co">// Проверяет условие: x в квадрате меньше 2.</span>
<span class="dt">bool</span> sqr_lt_2(<span class="dt">double</span> x)
{
  <span class="kw">return</span> x*x &lt; <span class="dv">2</span>;
}


<span class="dt">int</span> main()
{
  <span class="dt">double</span> x = <span class="dv">0</span>;
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    cout &lt;&lt; <span class="st">"x = "</span>;
    cin &gt;&gt; x;
    cout &lt;&lt; <span class="st">"x*x &lt; 2  == "</span> &lt;&lt; sqr_lt_2(x) &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="while_cin.cpp">0260-while_cin.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// while_cin.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Определение своей функции-предиката.</span>
<span class="co">// Проверяет условие: x в квадрате меньше 2.</span>
<span class="dt">bool</span> sqr_lt_2(<span class="dt">double</span> x)
{
  <span class="kw">return</span> x*x &lt; <span class="dv">2</span>;
}


<span class="dt">int</span> main()
{
  <span class="dt">double</span> x = <span class="dv">0</span>;
  cout &lt;&lt; <span class="st">"Enter a sequence of numbers x: "</span>;
  <span class="kw">while</span> (cin &gt;&gt; x) <span class="co">// Условие продолжения выполнения цикла.</span>
  {
    cout &lt;&lt; <span class="st">"x*x &lt; 2  == "</span> &lt;&lt; sqr_lt_2(x) &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="for_cin.cpp">0270-for_cin.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// for_cin.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Определение своей функции-предиката.</span>
<span class="co">// Проверяет условие: x в квадрате меньше 2.</span>
<span class="dt">bool</span> sqr_lt_2(<span class="dt">double</span> x)
{
  <span class="kw">return</span> x*x &lt; <span class="dv">2</span>;
}


<span class="dt">int</span> main()
{
  cout &lt;&lt; <span class="st">"Enter a sequence of numbers x: "</span>;
  <span class="co">// Определение переменных; условие продолжения; последнее действие на каждом повторении.</span>
  <span class="kw">for</span> (<span class="dt">double</span> x = <span class="dv">0</span>; cin &gt;&gt; x;)
  {
    cout &lt;&lt; <span class="st">"x*x &lt; 2  == "</span> &lt;&lt; sqr_lt_2(x) &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="cin_delay.cpp">0275-cin_delay.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// cin_delay.cpp</span>
<span class="co">// Задержка экрана средствами ISO C++.</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">///</span> Сбросить флаги ошибок и содержимое буфера потока.
<span class="dt">void</span> ignore_all(istream &amp;is)
{
  is.clear(); <span class="co">// Сброс ошибок.</span>
  is.sync();  <span class="co">// Синхронизация объекта потока с внешним устройством.</span>
  is.ignore(is.rdbuf()-&gt;in_avail()); <span class="co">// Сброс символов уже считанных в буфер потока.</span>
}

<span class="co">///</span> Задержка экрана = сброс стандартного потока ввода и ожидание следующего символа.
<span class="dt">void</span> console_delay()
{
  ignore_all(cin);
  cin.ignore();
}


<span class="co">// Демонстрация.</span>
<span class="dt">int</span> main()
{
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    cout &lt;&lt; <span class="st">"Enter a sequence of integers:</span><span class="ch">\n</span><span class="st">"</span><span class="co">;</span>
    <span class="kw">for</span> (<span class="dt">int</span> i; cin &gt;&gt; i;)
      cout &lt;&lt; i &lt;&lt; <span class="st">' '</span>;
    
    cout &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">Press Enter to repeat</span><span class="ch">\n</span><span class="st">"</span>;
    console_delay();
  }
}</code></pre></div>
<p><br>
</p>
<h1 id="cin_delay_eof_exit.cpp">0276-cin_delay_eof_exit.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// cin_delay_eof_exit.cpp</span>
<span class="co">// Задержка экрана средствами ISO C++.</span>
<span class="ot">#include &lt;cstddef&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">///</span> Сбросить флаги ошибок и содержимое буфера потока.
<span class="dt">void</span> ignore_all(istream &amp;is)
{
  is.clear();
  is.sync();
  is.ignore(is.rdbuf()-&gt;in_avail());
}

<span class="co">///</span> Задержка экрана = сброс стандартного потока ввода и ожидание следующего символа.
<span class="dt">void</span> console_delay()
{
  ignore_all(cin);
  cin.ignore();
}


<span class="co">// Демонстрация.</span>
<span class="dt">int</span> main()
{
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    cout &lt;&lt; <span class="st">"Enter a sequence of integers:</span><span class="ch">\n</span><span class="st">"</span><span class="co">;</span>
    <span class="kw">for</span> (<span class="dt">int</span> i; cin &gt;&gt; i;)
      cout &lt;&lt; i &lt;&lt; <span class="st">' '</span>;

    <span class="co">// Выйти, если введён признак конца файла.</span>
    <span class="kw">if</span> (cin.eof())
      <span class="kw">return</span> EXIT_SUCCESS;

    cout &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">Press Enter to repeat</span><span class="ch">\n</span><span class="st">"</span>;
    console_delay();
  }
}</code></pre></div>
<p><br>
</p>
<h1 id="circle_const.cpp">0280-circle_const.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// circle_const.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Определение своей функции-предиката.</span>
<span class="co">// проверить попадание в круг</span>
<span class="dt">bool</span> in_circle(<span class="dt">float</span> x, <span class="dt">float</span> y,
  <span class="dt">float</span> cx, <span class="dt">float</span> cy, <span class="dt">float</span> r)
  <span class="co">// координаты центра круга и его радиус</span>
{
  <span class="co">// Константы -- после инициализации значения не изменяются.</span>
  <span class="dt">const</span> <span class="dt">float</span> dx = x - cx,
              dy = y - cy;

  <span class="kw">return</span> dx * dx + dy * dy &lt;= r * r;
}

<span class="dt">int</span> main()
{
  cout &lt;&lt; <span class="st">"Enter a sequence of coordinates x, y: "</span>;
  <span class="co">// Определение переменных; условие продолжения; последнее действие на каждом повторении.</span>
  <span class="kw">for</span> (<span class="dt">float</span> x, y; cin &gt;&gt; x &gt;&gt; y;)
  {
    <span class="dt">const</span> <span class="dt">bool</span> within_the_circle = in_circle(x, y, <span class="dv">1</span>, <span class="dv">-1</span>, <span class="dv">3</span>);
    cout &lt;&lt; <span class="st">"(x, y) within the circle == "</span> &lt;&lt; within_the_circle &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="complex_bool_expr.cpp">0290-complex_bool_expr.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// complex_bool_expr.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Проверить попадание в круг.</span>
<span class="dt">bool</span> in_circle(<span class="dt">float</span> x, <span class="dt">float</span> y,
  <span class="dt">float</span> cx, <span class="dt">float</span> cy, <span class="dt">float</span> r)
  <span class="co">// координаты центра круга и его радиус</span>
{
  <span class="co">// Константы -- после инициализации значения не изменяются.</span>
  <span class="dt">const</span> <span class="dt">float</span> dx = x - cx,
              dy = y - cy;

  <span class="kw">return</span> dx * dx + dy * dy &lt;= r * r;
}

<span class="co">// Проверить попадание в прямоугольник.</span>
<span class="dt">bool</span> in_rectangle(<span class="dt">float</span> x, <span class="dt">float</span> y,
  <span class="dt">float</span> left, <span class="dt">float</span> right, <span class="dt">float</span> bottom, <span class="dt">float</span> top)
  <span class="co">// координаты левой, правой, нижней и верхней граней</span>
{
  <span class="kw">return</span> left &lt;= x &amp;&amp; x &lt;= right <span class="co">// &amp;&amp; -- "и"</span>
    &amp;&amp; bottom &lt;= y &amp;&amp; y &lt;= top;
}

<span class="co">// Проверить попадание в заданную фигуру.</span>
<span class="dt">bool</span> in_figure(<span class="dt">float</span> x, <span class="dt">float</span> y)
{
  <span class="co">// фигура может быть представлена как пересечение полуплоскости и</span>
  <span class="co">// объединения трёх фигур: двух прямоугольников и сегмента круга</span>
  <span class="kw">return</span> (in_rectangle(x, y,  <span class="fl">2.0</span>,  <span class="fl">4.0</span>, <span class="fl">-5.0</span>, <span class="fl">5.0</span>)
       || in_rectangle(x, y, <span class="fl">-4.0</span>, <span class="fl">-2.0</span>, <span class="fl">-5.0</span>, <span class="fl">5.0</span>) <span class="co">// || -- "или"</span>
       || in_circle(x, y, <span class="fl">-2.0</span>, <span class="fl">0.0</span>, <span class="fl">5.0</span>)) &amp;&amp; x &gt;= <span class="fl">-4.0</span>;
}


<span class="dt">int</span> main()
{
  cout &lt;&lt; <span class="st">"Enter a sequence of coordinates x, y: "</span>;
  <span class="co">// Определение переменных; условие продолжения; последнее действие на каждом повторении.</span>
  <span class="kw">for</span> (<span class="dt">double</span> x = <span class="dv">0</span>, y = <span class="dv">0</span>; cin &gt;&gt; x &gt;&gt; y;)
  {
    cout &lt;&lt; <span class="st">"(x, y) within the figure == "</span> &lt;&lt; in_figure(x, y) &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="ternary_operator.cpp">0300-ternary_operator.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// ternary_operator.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Проверить попадание в круг.</span>
<span class="dt">bool</span> in_circle(<span class="dt">float</span> x, <span class="dt">float</span> y,
  <span class="dt">float</span> cx, <span class="dt">float</span> cy, <span class="dt">float</span> r)
  <span class="co">// координаты центра круга и его радиус</span>
{
  <span class="co">// Константы -- после инициализации значения не изменяются.</span>
  <span class="dt">const</span> <span class="dt">float</span> dx = x - cx,
              dy = y - cy;

  <span class="kw">return</span> dx * dx + dy * dy &lt;= r * r;
}

<span class="co">// Проверить попадание в прямоугольник.</span>
<span class="dt">bool</span> in_rectangle(<span class="dt">float</span> x, <span class="dt">float</span> y,
  <span class="dt">float</span> left, <span class="dt">float</span> right, <span class="dt">float</span> bottom, <span class="dt">float</span> top)
  <span class="co">// координаты левой, правой, нижней и верхней граней</span>
{
  <span class="kw">return</span> left &lt;= x &amp;&amp; x &lt;= right <span class="co">// &amp;&amp; -- "и"</span>
    &amp;&amp; bottom &lt;= y &amp;&amp; y &lt;= top;
}

<span class="co">// Проверить попадание в заданную фигуру.</span>
<span class="dt">bool</span> in_figure(<span class="dt">float</span> x, <span class="dt">float</span> y)
{
  <span class="co">// фигура может быть представлена как пересечение полуплоскости и</span>
  <span class="co">// объединения трёх фигур: двух прямоугольников и сегмента круга</span>
  <span class="kw">return</span> (in_rectangle(x, y,  <span class="fl">2.0</span>,  <span class="fl">4.0</span>, <span class="fl">-5.0</span>, <span class="fl">5.0</span>)
       || in_rectangle(x, y, <span class="fl">-4.0</span>, <span class="fl">-2.0</span>, <span class="fl">-5.0</span>, <span class="fl">5.0</span>) <span class="co">// || -- "или"</span>
       || in_circle(x, y, <span class="fl">-2.0</span>, <span class="fl">0.0</span>, <span class="fl">5.0</span>)) &amp;&amp; x &gt;= <span class="fl">-4.0</span>;
}


<span class="dt">int</span> main()
{
  cout &lt;&lt; <span class="st">"Enter a sequence of coordinates x, y: "</span>;
  <span class="co">// Определение переменных; условие продолжения; последнее действие на каждом повторении.</span>
  <span class="kw">for</span> (<span class="dt">double</span> x = <span class="dv">0</span>, y = <span class="dv">0</span>; cin &gt;&gt; x &gt;&gt; y;)
  {
    cout &lt;&lt; <span class="st">"("</span> &lt;&lt; x &lt;&lt; <span class="st">", "</span> &lt;&lt; y &lt;&lt; <span class="st">") "</span> &lt;&lt;
      (in_figure(x, y)? <span class="st">"is"</span>: <span class="st">"is not"</span>) <span class="co">// "тернарный оператор": условие в выражении</span>
      &lt;&lt; <span class="st">" inside the figure"</span> &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="for.cpp">0310-for.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// for.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main()
{
  <span class="co">// Определение переменных; условие продолжения; последнее действие на каждом повторении.</span>
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= <span class="dv">10</span>; ++i) <span class="co">// ++i --&gt; i = i + 1</span>
  {
    cout &lt;&lt; <span class="st">"i == "</span> &lt;&lt; i &lt;&lt; <span class="st">"</span><span class="ch">\t</span><span class="st">i squared == "</span> &lt;&lt; i * i &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="for_for.cpp">0320-for_for.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// for_for.cpp</span>
<span class="co">// Двойной цикл for.</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Таблица умножения.</span>
<span class="dt">int</span> main()
{
  <span class="co">// Определение переменных; условие продолжения; последнее действие на каждом повторении.</span>
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= <span class="dv">10</span>; ++i) <span class="co">// ++i --&gt; i = i + 1</span>
  {
    <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= <span class="dv">10</span>; ++j)
    {
      cout &lt;&lt; i &lt;&lt; <span class="st">"*"</span> &lt;&lt; j &lt;&lt; <span class="st">"</span><span class="ch">\t</span><span class="st">== "</span> &lt;&lt; i * j &lt;&lt; endl;
    }
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="products_table.cpp">0330-products_table.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// products_table.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Таблица умножения.</span>
<span class="dt">int</span> main()
{
  <span class="co">// Строчка.</span>
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= <span class="dv">10</span>; ++i)
  {
    <span class="co">// Столбец.</span>
    <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= <span class="dv">10</span>; ++j)
    {
      cout &lt;&lt; i * j &lt;&lt; <span class="st">" "</span>;
    }

    cout &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="iomanip_setw.cpp">0340-iomanip_setw.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// iomanip_setw.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;iomanip&gt; </span><span class="co">// "Манипуляторы потока".</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Таблица умножения.</span>
<span class="dt">int</span> main()
{
  <span class="co">// Строчка.</span>
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= <span class="dv">10</span>; ++i)
  {
    <span class="co">// Столбец.</span>
    <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= <span class="dv">10</span>; ++j)
    {
      <span class="co">// Манипулятор setw вставляет пробелы (до четырёх), если выведено менее 4 символов.</span>
      cout &lt;&lt; setw(<span class="dv">4</span>) &lt;&lt; i * j;
    }

    cout &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="cat.cpp">0350-cat.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// cat.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Читаем из потока ввода символы и пишем их в поток вывода.</span>
<span class="dt">int</span> main()
{
  <span class="kw">for</span> (<span class="dt">char</span> ch; cin.get(ch);)
    cout.put(ch);
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="cat_2.cpp">0351-cat_2.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// cat_2.cpp</span>
<span class="co">// Вариант на основе вывода в поток буфера другого потока.</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Читаем из потока ввода символы и пишем их в поток вывода.</span>
<span class="dt">int</span> main()
{
  cout &lt;&lt; cin.rdbuf();
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="char_subst.cpp">0355-char_subst.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// char_subst.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Читаем из потока ввода символы и пишем их в поток вывода,</span>
<span class="co">// подменяя некоторые на другие (e -&gt; i, o -&gt; u, a -&gt; o).</span>
<span class="dt">int</span> main()
{
  <span class="kw">for</span> (<span class="dt">char</span> ch; cin.get(ch);)
  {
    <span class="dt">char</span> output = ch;
    <span class="kw">if</span> (ch == <span class="st">'e'</span>)
      output = <span class="st">'i'</span>;
    <span class="kw">else</span> <span class="kw">if</span> (ch == <span class="st">'o'</span>)
      output = <span class="st">'u'</span>;
    <span class="kw">else</span> <span class="kw">if</span> (ch == <span class="st">'a'</span>)
      output = <span class="st">'o'</span>;
    cout.put(output);
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="count_lines.cpp">0360-count_lines.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// count_lines.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Читаем из потока ввода строки, выводим их в поток вывода,</span>
<span class="co">// а в конце выводим их количество в отдельной строке.</span>
<span class="dt">int</span> main()
{
  <span class="dt">int</span> amount = <span class="dv">0</span>;
  <span class="kw">for</span> (string line; getline(cin, line); ++amount)
    cout &lt;&lt; line &lt;&lt; endl;
  cout &lt;&lt; amount &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="size_t.cpp">0370-size_t.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// size_t.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Читаем из потока ввода строки, выводим их в поток вывода,</span>
<span class="co">// а в конце выводим их количество в отдельной строке.</span>
<span class="dt">int</span> main()
{
  size_t amount = <span class="dv">0</span>; <span class="co">// Тип "количество", не может быть отрицательным.</span>
  <span class="kw">for</span> (string line; getline(cin, line); ++amount)
    cout &lt;&lt; line &lt;&lt; endl;
  cout &lt;&lt; amount &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="line_unique_0.cpp">0380-line_unique_0.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// line_unique_0.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Читаем из потока ввода строки, выводим их в поток вывода,</span>
<span class="co">// пропуская подряд идущие повторяющиеся строки.</span>
<span class="dt">int</span> main()
{
  <span class="co">// Нет ли здесь ошибок?</span>
  <span class="kw">for</span> (string last, next; getline(cin, next);)
  {
    <span class="kw">if</span> (last != next)
    {
      cout &lt;&lt; next &lt;&lt; endl;
      last = next;
    }
  }

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="line_unique.cpp">0390-line_unique.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// line_unique.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Читаем из потока ввода строки, выводим их в поток вывода,</span>
<span class="co">// пропуская подряд идущие повторяющиеся строки.</span>
<span class="dt">int</span> main()
{
  <span class="co">// Первая строка -- особый случай.</span>
  string last;
  <span class="kw">if</span> (!getline(cin, last))
    <span class="kw">return</span> EXIT_FAILURE; <span class="co">// Не смогли прочитать и одной строки.</span>

  cout &lt;&lt; last &lt;&lt; endl; <span class="co">// Вывести первую строку.</span>

  <span class="co">// Продолжить работу с остатком файла.</span>
  <span class="kw">for</span> (string next; getline(cin, next);)
  {
    <span class="kw">if</span> (last != next)
    {
      cout &lt;&lt; next &lt;&lt; endl;
      last = next;
    }
  }

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="spinning_pipe.cpp">0395-spinning_pipe.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// spinning_pipe.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main()
{
  <span class="kw">while</span> (<span class="kw">true</span>) std::cout
    .put(<span class="st">'|'</span>).flush().put(<span class="st">'</span><span class="ch">\b</span><span class="st">'</span>)
    .put(<span class="st">'/'</span>).flush().put(<span class="st">'</span><span class="ch">\b</span><span class="st">'</span>)
    .put(<span class="st">'-'</span>).flush().put(<span class="st">'</span><span class="ch">\b</span><span class="st">'</span>)
    .put(<span class="st">'</span><span class="ch">\\</span><span class="st">'</span>).flush().put(<span class="st">'</span><span class="ch">\b</span><span class="st">'</span>);
}</code></pre></div>
<p><br>
</p>
<h1 id="spinning_pipe_waiting.cpp">0396-spinning_pipe_waiting.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// spinning_pipe_waiting.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;thread&gt; </span><span class="co">// sleep</span>
<span class="ot">#include &lt;chrono&gt; </span><span class="co">// суффикс ms (C++14)</span>

<span class="co">// Выполнить "следующий фрагмент работы".</span>
<span class="co">// Для примера мы просто ждём 200мс.</span>
<span class="dt">bool</span> do_next_job()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std::chrono_literals;
  std::this_thread::sleep_for(<span class="er">200ms</span>);
  <span class="co">// C++11-вариант:</span>
  <span class="co">// std::this_thread::sleep_for(std::chrono::milliseconds(200));</span>
  <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="dt">int</span> main()
{
  <span class="dt">static</span> <span class="dt">char</span> sprite[] = <span class="st">"|/-</span><span class="ch">\\</span><span class="st">"</span>;
  <span class="kw">for</span> (<span class="dt">unsigned</span> s = <span class="dv">0</span>;; s = (s + <span class="dv">1</span>) % <span class="dv">4</span>)
  {
    std::cout.put(sprite[s]).flush();
    <span class="kw">if</span> (!do_next_job())
      <span class="kw">break</span>;
    std::cout.put(<span class="st">'</span><span class="ch">\b</span><span class="st">'</span>);
  }

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="reverse_lines.cpp">0398-reverse_lines.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// reverse_lines.cpp</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> Line
{
  Line *prev;
  string line;
};

<span class="dt">int</span> main()
{
  Line *last = <span class="kw">nullptr</span>;

  <span class="co">// Чтение строк.</span>
  <span class="kw">for</span> (string line; getline(cin, line);)
  {
    Line *new_line = <span class="kw">new</span> Line;
    new_line-&gt;prev = last;
    new_line-&gt;line = line;
    last = new_line;
  }

  <span class="co">// Вывод строк в обратном порядке.</span>
  <span class="kw">while</span> (last)
  {
    cout &lt;&lt; last-&gt;line &lt;&lt; <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>;
    Line *old_line = last;
    last = last-&gt;prev;
    <span class="kw">delete</span> old_line;
  }
  
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="void_list.cpp">0399-void_list.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// void_list.cpp</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Следующие 4 функции ничего не знают о содержимом списка.</span>

<span class="co">///</span> Возвращает ссылку на указатель на следующее звено звена link.
<span class="dt">void</span>*&amp; next(<span class="dt">void</span> *link)
{
  <span class="kw">return</span> *(<span class="dt">void</span>**)link;
}

<span class="co">///</span> Вставляет link перед head и возвращает link (теперь это -- новая голова списка).
<span class="dt">void</span>* insert_head(<span class="dt">void</span> *head, <span class="dt">void</span> *link)
{
  next(link) = head;
  <span class="kw">return</span> link;
}

<span class="co">///</span> Вычисляет длину списка.
size_t size(<span class="dt">void</span> *head)
{
  size_t sz = <span class="dv">0</span>;
  <span class="kw">for</span> (; head; head = next(head))
    ++sz;
  <span class="kw">return</span> sz;
}

<span class="co">///</span> Указатель на функцию, выполняющую удаление звена.
<span class="kw">using</span> Link_delete = <span class="dt">void</span>(*)(<span class="dt">void</span>*);

<span class="co">///</span> Удаляет список, используя пользовательскую функцию удаления.
<span class="dt">void</span> delete_list(<span class="dt">void</span> *head, Link_delete link_delete)
{
  <span class="kw">while</span> (head)
  {
    <span class="kw">auto</span> next_head = next(head);
    link_delete(head);
    head = next_head;
  }    
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="co">///</span> Звено списка -- одна строка.
<span class="kw">struct</span> Line
{
  <span class="dt">void</span> *prev;
  string line;
};

<span class="co">///</span> Вывести строку и удалить объект Line.
<span class="dt">void</span> print_and_delete(<span class="dt">void</span> *ptr)
{
  <span class="kw">auto</span> line = (Line*)ptr;
  cout &lt;&lt; line-&gt;line &lt;&lt; <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>;
  <span class="kw">delete</span> line;
}

<span class="dt">int</span> main()
{
  Line *head = <span class="kw">nullptr</span>;

  <span class="co">// Чтение строк.</span>
  <span class="kw">for</span> (string line; getline(cin, line);)
  {
    Line *new_line = <span class="kw">new</span> Line;
    new_line-&gt;line = line;
    head = (Line*)insert_head(head, new_line);
  }

  <span class="co">// Вывод количества строк -- элементов списка.</span>
  cout &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">Lines: "</span><span class="co"> </span>&lt;&lt; size(head) &lt;&lt; <span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span><span class="co">;</span>

  <span class="co">// Вывод строк в обратном порядке.</span>
  delete_list(head, print_and_delete);

  cin.clear();
  cin.ignore();

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="solve_linear_0.cpp">0400-solve_linear_0.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// solve_linear_0.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Решаем уравнение ax + b = 0.</span>
<span class="dt">double</span> solve_linear(<span class="dt">double</span> a, <span class="dt">double</span> b)
{
  <span class="co">// Неужели так просто?</span>
  <span class="kw">return</span> -b / a;
}

<span class="dt">int</span> main()
{
  cout &lt;&lt; <span class="st">"Solving ax + b = 0, enter a, b:</span><span class="ch">\n</span><span class="st">"</span>;
  cout.precision(<span class="dv">16</span>);
  <span class="kw">for</span> (<span class="dt">double</span> a, b; cin &gt;&gt; a &gt;&gt; b;)
    cout &lt;&lt; <span class="st">"x == "</span> &lt;&lt; solve_linear(a, b) &lt;&lt; endl;

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="solve_linear_ref.cpp">0410-solve_linear_ref.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// solve_linear_ref.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Особое значение "бесконечное количество корней".</span>
<span class="dt">const</span> <span class="dt">int</span> INFINITE_ROOTS = <span class="dv">-1</span>;

<span class="co">// Решаем уравнение ax + b = 0.</span>
<span class="co">// Функция возвращает "количество корней".</span>
<span class="co">// Корень записывает по ссылке root.</span>
<span class="dt">int</span> solve_linear(<span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> &amp;root)
{
  <span class="kw">if</span> (a == <span class="dv">0</span>)
    <span class="kw">return</span> b == <span class="dv">0</span>? INFINITE_ROOTS: <span class="dv">0</span>;
  root = -b / a;
  <span class="kw">return</span> <span class="dv">1</span>;
}

<span class="dt">int</span> main()
{
  cout &lt;&lt; <span class="st">"Solving ax + b = 0, enter a, b:</span><span class="ch">\n</span><span class="st">"</span>;
  cout.precision(<span class="dv">16</span>);
  <span class="kw">for</span> (<span class="dt">double</span> a, b, x; cin &gt;&gt; a &gt;&gt; b;)
  {
    <span class="dt">const</span> <span class="dt">int</span> roots = solve_linear(a, b, x);
    <span class="kw">if</span> (roots == <span class="dv">0</span>)
      cout &lt;&lt; <span class="st">"no roots</span><span class="ch">\n</span><span class="st">"</span>;
    <span class="kw">else</span> <span class="kw">if</span> (roots == INFINITE_ROOTS)
      cout &lt;&lt; <span class="st">"any number is a root</span><span class="ch">\n</span><span class="st">"</span>;
    <span class="kw">else</span> <span class="co">// один корень, записан в x</span>
      cout &lt;&lt; <span class="st">"x == "</span> &lt;&lt; x &lt;&lt; endl;
  }

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="switch_case_0.cpp">0420-switch_case_0.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// switch_case_0.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Особое значение "бесконечное количество корней".</span>
<span class="dt">const</span> <span class="dt">int</span> INFINITE_ROOTS = <span class="dv">-1</span>;

<span class="co">// Решаем уравнение ax + b = 0.</span>
<span class="co">// Функция возвращает "количество корней".</span>
<span class="co">// Корень записывает по ссылке root.</span>
<span class="dt">int</span> solve_linear(<span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> &amp;root)
{
  <span class="kw">if</span> (a == <span class="dv">0</span>)
    <span class="kw">return</span> b == <span class="dv">0</span>? INFINITE_ROOTS: <span class="dv">0</span>;
  root = -b / a;
  <span class="kw">return</span> <span class="dv">1</span>;
}

<span class="dt">int</span> main()
{
  cout &lt;&lt; <span class="st">"Solving ax + b = 0, enter a, b:</span><span class="ch">\n</span><span class="st">"</span>;
  cout.precision(<span class="dv">16</span>);
  <span class="kw">for</span> (<span class="dt">double</span> a, b, x; cin &gt;&gt; a &gt;&gt; b;)
  {
    <span class="dt">const</span> <span class="dt">int</span> roots = solve_linear(a, b, x);
    <span class="kw">switch</span> (roots)
    {
    <span class="kw">case</span> <span class="dv">0</span>:
      cout &lt;&lt; <span class="st">"no roots</span><span class="ch">\n</span><span class="st">"</span>;
      <span class="kw">break</span>;
    <span class="kw">case</span> INFINITE_ROOTS:
      cout &lt;&lt; <span class="st">"any number is a root</span><span class="ch">\n</span><span class="st">"</span>;
      <span class="kw">break</span>;
    <span class="kw">default</span>: <span class="co">// один корень, записан в x</span>
      cout &lt;&lt; <span class="st">"x == "</span> &lt;&lt; x &lt;&lt; endl;
    }
  }

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="switch_case.cpp">0430-switch_case.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// switch_case.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Особое значение "бесконечное количество корней".</span>
<span class="dt">const</span> <span class="dt">int</span> INFINITE_ROOTS = <span class="dv">-1</span>;

<span class="co">// Решаем уравнение ax + b = 0.</span>
<span class="co">// Функция возвращает "количество корней".</span>
<span class="co">// Корень записывает по ссылке root.</span>
<span class="dt">int</span> solve_linear(<span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> &amp;root)
{
  <span class="kw">if</span> (a == <span class="dv">0</span>)
    <span class="kw">return</span> b == <span class="dv">0</span>? INFINITE_ROOTS: <span class="dv">0</span>;
  root = -b / a;
  <span class="kw">return</span> <span class="dv">1</span>;
}

<span class="dt">int</span> main()
{
  cout &lt;&lt; <span class="st">"Solving ax + b = 0, enter a, b:</span><span class="ch">\n</span><span class="st">"</span>;
  cout.precision(<span class="dv">16</span>);
  <span class="kw">for</span> (<span class="dt">double</span> a, b, x; cin &gt;&gt; a &gt;&gt; b;)
  {
    <span class="kw">switch</span> (solve_linear(a, b, x))
    {
    <span class="kw">case</span> <span class="dv">0</span>:
      cout &lt;&lt; <span class="st">"no roots</span><span class="ch">\n</span><span class="st">"</span>;
      <span class="kw">break</span>;
    <span class="kw">case</span> INFINITE_ROOTS:
      cout &lt;&lt; <span class="st">"any number is a root</span><span class="ch">\n</span><span class="st">"</span>;
      <span class="kw">break</span>;
    <span class="kw">default</span>: <span class="co">// один корень, записан в x</span>
      cout &lt;&lt; <span class="st">"x == "</span> &lt;&lt; x &lt;&lt; endl;
    }
  }

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="solve_quadratic.cpp">0440-solve_quadratic.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// solve_quadratic.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Особое значение "бесконечное количество корней".</span>
<span class="dt">const</span> <span class="dt">int</span> INFINITE_ROOTS = <span class="dv">-1</span>;

<span class="co">// Решаем уравнение ax + b = 0.</span>
<span class="co">// Функция возвращает "количество корней".</span>
<span class="co">// Корень записывает по ссылке root.</span>
<span class="dt">int</span> solve_linear(<span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> &amp;root)
{
  <span class="kw">if</span> (a == <span class="dv">0</span>)
    <span class="kw">return</span> b == <span class="dv">0</span>? INFINITE_ROOTS: <span class="dv">0</span>;
  root = -b / a;
  <span class="kw">return</span> <span class="dv">1</span>;
}

<span class="co">// Решаем уравнение ax2 + bx + c = 0.</span>
<span class="co">// Функция возвращает "количество корней",</span>
<span class="co">// до двух корней записывает по ссылкам.</span>
<span class="dt">int</span> solve_quadratic(<span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> c, <span class="dt">double</span> &amp;root1, <span class="dt">double</span> &amp;root2)
{
  <span class="kw">if</span> (a == <span class="dv">0</span>) <span class="co">// сводится к линейному</span>
    <span class="kw">return</span> solve_linear(b, c, root1);
  <span class="co">// a != 0</span>

  <span class="dt">const</span> <span class="dt">double</span> d = b * b - <span class="fl">4.0</span> * a * c;
  <span class="kw">if</span> (d &lt; <span class="dv">0</span>) <span class="co">// нет корней</span>
    <span class="kw">return</span> <span class="dv">0</span>;
  <span class="kw">if</span> (d == <span class="dv">0</span>) <span class="co">// один корень</span>
  {
    root1 = -b / (<span class="fl">2.0</span> * a); <span class="co">// обратите внимание на скобки</span>
    <span class="kw">return</span> <span class="dv">1</span>;
  }

  <span class="co">// два корня</span>
  <span class="dt">const</span> <span class="dt">double</span> ds = sqrt(d);
  root1 = (-b - ds) / (<span class="fl">2.0</span> * a);
  root2 = (-b + ds) / (<span class="fl">2.0</span> * a);
  <span class="kw">return</span> <span class="dv">2</span>;
}

<span class="co">// Вычислить значение квадратного трёхчлена в точке.</span>
<span class="dt">double</span> quadratic(<span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> c, <span class="dt">double</span> x)
{
  <span class="kw">return</span> (a * x + b) * x + c;
}


<span class="dt">int</span> main()
{
  cout &lt;&lt; <span class="st">"Solving ax2 + bx + c = 0, enter a, b, c:</span><span class="ch">\n</span><span class="st">"</span>;
  cout.precision(<span class="dv">16</span>);
  <span class="kw">for</span> (<span class="dt">double</span> a, b, c, x1, x2; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;)
  {
    <span class="kw">switch</span> (solve_quadratic(a, b, c, x1, x2))
    {
    <span class="kw">case</span> <span class="dv">0</span>:
      cout &lt;&lt; <span class="st">"no roots</span><span class="ch">\n</span><span class="st">"</span>;
      <span class="kw">break</span>;
    <span class="kw">case</span> INFINITE_ROOTS:
      cout &lt;&lt; <span class="st">"any number is a root</span><span class="ch">\n</span><span class="st">"</span>;
      <span class="kw">break</span>;
    <span class="kw">case</span> <span class="dv">1</span>: <span class="co">// один корень, записан в x1</span>
      cout &lt;&lt; <span class="st">"x == "</span> &lt;&lt; x1 &lt;&lt; <span class="st">", error is "</span> &lt;&lt; quadratic(a, b, c, x1) &lt;&lt; endl;
      <span class="kw">break</span>;
    <span class="kw">case</span> <span class="dv">2</span>: <span class="co">// два корня, записаны в x1 и x2</span>
      cout &lt;&lt; <span class="st">"x1 == "</span> &lt;&lt; x1 &lt;&lt; <span class="st">", error is "</span> &lt;&lt; quadratic(a, b, c, x1) &lt;&lt; endl;
      cout &lt;&lt; <span class="st">"x2 == "</span> &lt;&lt; x2 &lt;&lt; <span class="st">", error is "</span> &lt;&lt; quadratic(a, b, c, x2) &lt;&lt; endl;
      <span class="kw">break</span>;
    <span class="kw">default</span>:
      cout &lt;&lt; <span class="st">"???</span><span class="ch">\n</span><span class="st">"</span>; <span class="co">// невозможный случай</span>
    }
  }

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="assert_0.cpp">0450-assert_0.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// assert_0.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>
<span class="ot">#include &lt;cassert&gt; </span><span class="co">// assert</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Особое значение "бесконечное количество корней".</span>
<span class="dt">const</span> <span class="dt">int</span> INFINITE_ROOTS = <span class="dv">-1</span>;

<span class="co">// Решаем уравнение ax + b = 0.</span>
<span class="co">// Функция возвращает "количество корней".</span>
<span class="co">// Корень записывает по ссылке root.</span>
<span class="dt">int</span> solve_linear(<span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> &amp;root)
{
  <span class="kw">if</span> (a == <span class="dv">0</span>)
    <span class="kw">return</span> b == <span class="dv">0</span>? INFINITE_ROOTS: <span class="dv">0</span>;
  root = -b / a;
  <span class="kw">return</span> <span class="dv">1</span>;
}

<span class="co">// Решаем уравнение ax2 + bx + c = 0.</span>
<span class="co">// Функция возвращает "количество корней",</span>
<span class="co">// до двух корней записывает по ссылкам.</span>
<span class="dt">int</span> solve_quadratic(<span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> c, <span class="dt">double</span> &amp;root1, <span class="dt">double</span> &amp;root2)
{
  <span class="kw">if</span> (a == <span class="dv">0</span>) <span class="co">// сводится к линейному</span>
    <span class="kw">return</span> solve_linear(b, c, root1);
  <span class="co">// a != 0</span>

  <span class="dt">const</span> <span class="dt">double</span> d = b * b - <span class="fl">4.0</span> * a * c;
  <span class="kw">if</span> (d &lt; <span class="dv">0</span>) <span class="co">// нет корней</span>
    <span class="kw">return</span> <span class="dv">0</span>;
  <span class="kw">if</span> (d == <span class="dv">0</span>) <span class="co">// один корень</span>
  {
    root1 = -b / (<span class="fl">2.0</span> * a); <span class="co">// обратите внимание на скобки</span>
    <span class="kw">return</span> <span class="dv">1</span>;
  }

  <span class="co">// два корня</span>
  <span class="dt">const</span> <span class="dt">double</span> ds = sqrt(d);
  root1 = (-b - ds) / (<span class="fl">2.0</span> * a);
  root2 = (-b + ds) / (<span class="fl">2.0</span> * a);
  <span class="kw">return</span> <span class="dv">2</span>;
}

<span class="co">// Вычислить значение квадратного трёхчлена в точке.</span>
<span class="dt">double</span> quadratic(<span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> c, <span class="dt">double</span> x)
{
  <span class="kw">return</span> (a * x + b) * x + c;
}


<span class="dt">int</span> main()
{
  cout &lt;&lt; <span class="st">"Solving ax2 + bx + c = 0, enter a, b, c:</span><span class="ch">\n</span><span class="st">"</span>;
  cout.precision(<span class="dv">16</span>);
  <span class="kw">for</span> (<span class="dt">double</span> a, b, c, x1, x2; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;)
  {
    <span class="kw">switch</span> (solve_quadratic(a, b, c, x1, x2))
    {
    <span class="kw">case</span> <span class="dv">0</span>:
      cout &lt;&lt; <span class="st">"no roots</span><span class="ch">\n</span><span class="st">"</span>;
      <span class="kw">break</span>;
    <span class="kw">case</span> INFINITE_ROOTS:
      cout &lt;&lt; <span class="st">"any number is a root</span><span class="ch">\n</span><span class="st">"</span>;
      <span class="kw">break</span>;
    <span class="kw">case</span> <span class="dv">1</span>: <span class="co">// один корень, записан в x1</span>
      cout &lt;&lt; <span class="st">"x == "</span> &lt;&lt; x1 &lt;&lt; <span class="st">", error is "</span> &lt;&lt; quadratic(a, b, c, x1) &lt;&lt; endl;
      <span class="kw">break</span>;
    <span class="kw">case</span> <span class="dv">2</span>: <span class="co">// два корня, записаны в x1 и x2</span>
      cout &lt;&lt; <span class="st">"x1 == "</span> &lt;&lt; x1 &lt;&lt; <span class="st">", error is "</span> &lt;&lt; quadratic(a, b, c, x1) &lt;&lt; endl;
      cout &lt;&lt; <span class="st">"x2 == "</span> &lt;&lt; x2 &lt;&lt; <span class="st">", error is "</span> &lt;&lt; quadratic(a, b, c, x2) &lt;&lt; endl;
      <span class="kw">break</span>;
    <span class="kw">default</span>:
      assert(!<span class="st">"impossible case: 3 or more roots"</span>); <span class="co">// невозможный случай</span>
      cout &lt;&lt; <span class="st">"unknown error</span><span class="ch">\n</span><span class="st">"</span>;
      <span class="kw">return</span> EXIT_FAILURE;
    }
  }

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="solve_transcend_0.cpp">0460-solve_transcend_0.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// solve_transcend_0.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>
<span class="ot">#include &lt;cassert&gt; </span><span class="co">// assert</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Особое значение "бесконечное количество корней".</span>
<span class="dt">const</span> <span class="dt">int</span> INFINITE_ROOTS = <span class="dv">-1</span>;

<span class="dt">const</span> <span class="dt">double</span> <span class="co">// Вспомогательные числовые константы</span>
  HALF_PI   = <span class="fl">1.570796326795</span>, <span class="co">// половина пи</span>
  TOLERANCE = <span class="fl">1e-10</span>; <span class="co">// граница между "нулём" и "ненулём"</span>

<span class="co">// Логарифм по произвольному основанию.</span>
<span class="dt">double</span> log(<span class="dt">double</span> base, <span class="dt">double</span> arg)
{
  <span class="kw">return</span> log(arg) / log(base);
}

<span class="co">// Проверка значения на близость нулю.</span>
<span class="dt">bool</span> is_almost_zero(<span class="dt">double</span> x, <span class="dt">double</span> tolerance = TOLERANCE)
{
  <span class="kw">return</span> abs(x) &lt;= tolerance;
}

<span class="co">// Левая часть уравнения.</span>
<span class="dt">double</span> f(<span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> c, <span class="dt">double</span> x)
{
  <span class="kw">return</span> <span class="fl">1.0</span> + sin(pow(a, x) + abs(log(b, c)));
}

<span class="co">// Решаем уравнение f(a, b, c, root) = 0 относительно root.</span>
<span class="co">// Функция возвращает "количество корней",</span>
<span class="co">// один корень записывает по ссылке.</span>
<span class="dt">int</span> solve_f(<span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> c, <span class="dt">double</span> &amp;root)
{
  <span class="kw">if</span> (a &lt; <span class="fl">0.0</span> || b &lt;= <span class="fl">0.0</span> || b == <span class="fl">1.0</span> || c &lt;= <span class="fl">0.0</span>)
    <span class="kw">return</span> <span class="dv">0</span>; <span class="co">// нет корней</span>
  <span class="kw">if</span> (a == <span class="fl">0.0</span> || a == <span class="fl">1.0</span>) <span class="co">// потенциально почти все возможные x -- корни</span>
    <span class="kw">return</span> is_almost_zero(f(a, b, c, <span class="fl">1.0</span>))? INFINITE_ROOTS: <span class="dv">0</span>;

  <span class="co">// Счётное число корней, вернём один из них (он может не существовать).</span>
  root = log(a, <span class="fl">3.0</span> * HALF_PI - abs(log(b, c)));
  <span class="kw">return</span> <span class="dv">1</span>;
}


<span class="dt">int</span> main()
{
  cout &lt;&lt; <span class="st">"Solving f(a, b, c, x) = 0, enter a, b, c:</span><span class="ch">\n</span><span class="st">"</span>;
  cout.precision(<span class="dv">16</span>);
  <span class="kw">for</span> (<span class="dt">double</span> a, b, c, x; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;)
  {
    <span class="kw">switch</span> (solve_f(a, b, c, x))
    {
    <span class="kw">case</span> <span class="dv">0</span>:
      cout &lt;&lt; <span class="st">"no roots</span><span class="ch">\n</span><span class="st">"</span>;
      <span class="kw">break</span>;
    <span class="kw">case</span> INFINITE_ROOTS:
      cout &lt;&lt; <span class="st">"any number is a root</span><span class="ch">\n</span><span class="st">"</span>;
      <span class="kw">break</span>;
    <span class="kw">case</span> <span class="dv">1</span>: <span class="co">// один корень, записан в x</span>
      cout &lt;&lt; <span class="st">"x == "</span> &lt;&lt; x &lt;&lt; <span class="st">", error is "</span> &lt;&lt; f(a, b, c, x) &lt;&lt; endl;
      <span class="kw">break</span>;
    <span class="kw">default</span>:
      assert(!<span class="st">"impossible case: invalid roots quantity"</span>); <span class="co">// невозможный случай</span>
      cout &lt;&lt; <span class="st">"unknown error</span><span class="ch">\n</span><span class="st">"</span>;
      <span class="kw">return</span> EXIT_FAILURE;
    }
  }

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="solve_transcend.cpp">0470-solve_transcend.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// solve_transcend.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>
<span class="ot">#include &lt;cassert&gt; </span><span class="co">// assert</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Особое значение "бесконечное количество корней".</span>
<span class="dt">const</span> <span class="dt">int</span> INFINITE_ROOTS = <span class="dv">-1</span>;

<span class="dt">const</span> <span class="dt">double</span> <span class="co">// Вспомогательные числовые константы</span>
  HALF_PI   = <span class="fl">1.5707963267949</span>,  <span class="co">// половина пи</span>
  PI        = <span class="fl">3.14159265358979</span>, <span class="co">// число пи</span>
  DOUBLE_PI = <span class="fl">6.2831853071796</span>,  <span class="co">// два пи</span>
  TOLERANCE = <span class="fl">1e-10</span>; <span class="co">// граница между "нулём" и "ненулём"</span>

<span class="co">// Логарифм по произвольному основанию.</span>
<span class="dt">double</span> log(<span class="dt">double</span> base, <span class="dt">double</span> arg)
{
  <span class="kw">return</span> log(arg) / log(base);
}

<span class="co">// Проверка значения на близость нулю.</span>
<span class="dt">bool</span> is_almost_zero(<span class="dt">double</span> x, <span class="dt">double</span> tolerance = TOLERANCE)
{
  <span class="kw">return</span> abs(x) &lt;= tolerance;
}

<span class="co">// Левая часть уравнения.</span>
<span class="dt">double</span> f(<span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> c, <span class="dt">double</span> x)
{
  <span class="kw">return</span> <span class="fl">1.0</span> + sin(pow(a, x) + abs(log(b, c)));
}

<span class="co">// Решаем уравнение f(a, b, c, root) = 0 относительно root.</span>
<span class="co">// Функция возвращает "количество корней",</span>
<span class="co">// один корень записывает по ссылке.</span>
<span class="dt">int</span> solve_f(<span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> c, <span class="dt">double</span> &amp;root)
{
  <span class="kw">if</span> (a &lt; <span class="fl">0.0</span> || b &lt;= <span class="fl">0.0</span> || b == <span class="fl">1.0</span> || c &lt;= <span class="fl">0.0</span>)
    <span class="kw">return</span> <span class="dv">0</span>; <span class="co">// нет корней</span>
  <span class="kw">if</span> (a == <span class="fl">0.0</span> || a == <span class="fl">1.0</span>) <span class="co">// потенциально почти все возможные x -- корни</span>
    <span class="kw">return</span> is_almost_zero(f(a, b, c, <span class="fl">1.0</span>))? INFINITE_ROOTS: <span class="dv">0</span>;

  <span class="co">// Счётное число корней, получим один из них.</span>
  <span class="dt">const</span> <span class="dt">double</span>
    expr_part = abs(log(b, c)) + HALF_PI,  <span class="co">// часть выражения</span>
    n = <span class="fl">1.0</span> + ceil(expr_part / DOUBLE_PI), <span class="co">// номер корня</span>
    log_arg = DOUBLE_PI * n - expr_part;   <span class="co">// аргумент логарифма в формуле корня</span>

  assert(log_arg &gt; <span class="fl">0.0</span>); <span class="co">// всегда должен быть положительным по построению</span>
  root = log(a, log_arg);
  <span class="kw">return</span> <span class="dv">1</span>;
}


<span class="dt">int</span> main()
{
  cout &lt;&lt; <span class="st">"Solving f(a, b, c, x) = 0, enter a, b, c:</span><span class="ch">\n</span><span class="st">"</span>;
  cout.precision(<span class="dv">16</span>);
  <span class="kw">for</span> (<span class="dt">double</span> a, b, c, x; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;)
  {
    <span class="kw">switch</span> (solve_f(a, b, c, x))
    {
    <span class="kw">case</span> <span class="dv">0</span>:
      cout &lt;&lt; <span class="st">"no roots</span><span class="ch">\n</span><span class="st">"</span>;
      <span class="kw">break</span>;
    <span class="kw">case</span> INFINITE_ROOTS:
      cout &lt;&lt; <span class="st">"any number is a root</span><span class="ch">\n</span><span class="st">"</span>;
      <span class="kw">break</span>;
    <span class="kw">case</span> <span class="dv">1</span>: <span class="co">// один корень, записан в x</span>
      cout &lt;&lt; <span class="st">"x == "</span> &lt;&lt; x &lt;&lt; <span class="st">", error is "</span> &lt;&lt; f(a, b, c, x) &lt;&lt; endl;
      <span class="kw">break</span>;
    <span class="kw">default</span>:
      assert(!<span class="st">"impossible case: invalid roots quantity"</span>); <span class="co">// невозможный случай</span>
      cout &lt;&lt; <span class="st">"unknown error</span><span class="ch">\n</span><span class="st">"</span>;
      <span class="kw">return</span> EXIT_FAILURE;
    }
  }

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="array_initialization.cpp">0499-array_initialization.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// array_initialization.cpp</span>
<span class="co">// Примеры инициализации одномерных статических массивов.</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="co">// Макрос для "распечатки" статического массива.</span>
<span class="ot">#define PRINTA(a)        </span>\
<span class="ot">  for (auto item: a)     </span>\
<span class="ot">    cout &lt;&lt; item &lt;&lt; ' '; </span>\
<span class="ot">  cout &lt;&lt; endl</span>

<span class="dt">int</span> main()
{
  <span class="co">// Указан и размер и значения всех элементов.</span>
  <span class="dt">int</span> xyz[<span class="dv">3</span>] = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };
  PRINTA(xyz);
  
  <span class="co">// Последние три элемента будут нули.</span>
  <span class="dt">int</span> zero_tail[<span class="dv">6</span>] = { <span class="dv">7</span>, <span class="dv">7</span>, <span class="dv">7</span> };
  PRINTA(zero_tail);
  
  <span class="co">// Типичная инициализация локального массива нулями.</span>
  <span class="dt">float</span> zeroes[<span class="dv">10</span>] = {};
  PRINTA(zeroes);
  
  <span class="co">// Размер не указан, определяется количеством значений в инициализаторе.</span>
  <span class="dt">char</span> word[] = { <span class="st">'w'</span>, <span class="st">'o'</span>, <span class="st">'r'</span>, <span class="st">'d'</span> };
  PRINTA(word);
  
  <span class="co">// В качестве инициализатора можно использовать строковый литерал.</span>
  <span class="co">// В конце добавляется нулевой символ, поэтому размер greets 11, а не 10.</span>
  <span class="dt">char</span> greets[] = <span class="st">"greetings!"</span>;
  PRINTA(greets) &lt;&lt; <span class="kw">sizeof</span>(greets) &lt;&lt; <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>;
  
  greets[<span class="dv">3</span>] = <span class="st">'a'</span>;
  cout &lt;&lt; greets &lt;&lt; endl;
}</code></pre></div>
<p><br>
</p>
<h1 id="positives_negatives.cpp">0500-positives_negatives.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// positives_negatives.cpp</span>
<span class="co">// Отношение количества положительных к количеству отрицательных элементов.</span>
<span class="co">// Пример: { 4, 1, 100, 0, 20, 0, -1, -2, 3, -6 } -&gt; 5/3 = 1.6666667.</span>
<span class="ot">#include &lt;cstddef&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;


<span class="co">// П.1: обработка произвольного массива, переданного как адрес + размер,</span>
<span class="co">// size_t -- стандартный тип (определён в Стандартной библиотеке C),</span>
<span class="co">// предназначенный для хранения размеров массивов.</span>
<span class="dt">double</span> pn_ratio(<span class="dt">const</span> <span class="dt">double</span> numbers[], size_t n)
{
  <span class="co">// Счётчики положительных и отрицательных чисел.</span>
  size_t positives = <span class="dv">0</span>, negatives = <span class="dv">0</span>;
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; n; ++i)
  {
    <span class="co">// Ключевое слово auto предписывает компилятору вывести тип переменной</span>
    <span class="co">// автоматически по типу инициализирующего выражения.</span>
    <span class="dt">const</span> <span class="kw">auto</span> x = numbers[i]; <span class="co">// следующий элемент последовательности</span>
    <span class="kw">if</span> (x &lt; <span class="fl">0.0</span>)
      ++negatives;
    <span class="kw">else</span> <span class="kw">if</span> (x &gt; <span class="fl">0.0</span>)
      ++positives;
  }

  <span class="co">// Без приведения к double будет деление в целых числах.</span>
  <span class="kw">return</span> <span class="dt">double</span>(positives) / negatives;
}

<span class="co">// П.2: тестирование функции из п.1 на заранее заданных массивах.</span>
<span class="dt">bool</span> test_pn_ratio()
{
  <span class="dt">const</span> <span class="dt">double</span> test1[] = { <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">100</span>, <span class="dv">0</span>, <span class="dv">20</span>, <span class="dv">0</span>, <span class="dv">-1</span>, <span class="dv">-2</span>, <span class="dv">3</span>, <span class="dv">-6</span> };
  <span class="co">// sizeof возвращает размер статического массива в байтах</span>
  <span class="co">// (!) при этом массив должен быть виден в данном контексте непосредственно,</span>
  <span class="co">// (!) иначе программист рискует получить вместо размера массива размер указателя на него</span>
  <span class="kw">if</span> (pn_ratio(test1, <span class="kw">sizeof</span>(test1) / <span class="kw">sizeof</span>(<span class="dt">double</span>)) != <span class="fl">5.0</span> / <span class="fl">3.0</span>)
    <span class="kw">return</span> <span class="kw">false</span>;

  <span class="dt">const</span> <span class="dt">double</span> test2[] = { <span class="dv">-40</span>, <span class="dv">-2</span>, <span class="dv">-111</span>, <span class="dv">42</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">-1000</span>, <span class="dv">-4</span> };
  <span class="kw">if</span> (pn_ratio(test2, <span class="kw">sizeof</span>(test2) / <span class="kw">sizeof</span>(<span class="dt">double</span>)) != <span class="fl">2.0</span> / <span class="fl">5.0</span>)
    <span class="kw">return</span> <span class="kw">false</span>;

  <span class="co">// Все проверки прошли успешно.</span>
  <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="co">// П.3: считывание чисел с потока ввода.</span>
<span class="dt">double</span> pn_ratio(istream &amp;in)
{
  <span class="co">// Счётчики положительных и отрицательных чисел.</span>
  size_t positives = <span class="dv">0</span>, negatives = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="dt">double</span> x; in &gt;&gt; x;)
  {
    <span class="kw">if</span> (x &lt; <span class="fl">0.0</span>)
      ++negatives;
    <span class="kw">else</span> <span class="kw">if</span> (x &gt; <span class="fl">0.0</span>)
      ++positives;
  }

  <span class="co">// Без приведения к double будет деление в целых числах.</span>
  <span class="kw">return</span> <span class="dt">double</span>(positives) / negatives;
}

<span class="dt">int</span> main()
{
  <span class="co">// Тестирование варианта обработки данных для массива.</span>
  cout &lt;&lt; test_pn_ratio() &lt;&lt; endl;

  <span class="co">// Вариант для обработки данных с потока ввода.</span>
  <span class="dt">const</span> <span class="kw">auto</span> result = pn_ratio(cin);
  cout &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">Result: "</span> &lt;&lt; result &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="positives_negatives_2.cpp">0501-positives_negatives_2.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// positives_negatives_2.cpp</span>
<span class="co">// Отношение количества положительных к количеству отрицательных элементов.</span>
<span class="co">// Пример: { 4, 1, 100, 0, 20, 0, -1, -2, 3, -6 } -&gt; 5/3 = 1.6666667.</span>
<span class="ot">#include &lt;cstddef&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;


<span class="co">// П.1: обработка произвольного массива, переданного как адрес + размер,</span>
<span class="co">// size_t -- стандартный тип (определён в Стандартной библиотеке C),</span>
<span class="co">// предназначенный для хранения размеров массивов.</span>
<span class="dt">double</span> pn_ratio(<span class="dt">const</span> <span class="dt">double</span> numbers[], size_t n)
{
  <span class="co">// Счётчики положительных и отрицательных чисел.</span>
  size_t positives = <span class="dv">0</span>, negatives = <span class="dv">0</span>;
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; n; ++i)
  {
    <span class="co">// Ключевое слово auto предписывает компилятору вывести тип переменной</span>
    <span class="co">// автоматически по типу инициализирующего выражения.</span>
    <span class="dt">const</span> <span class="kw">auto</span> x = numbers[i]; <span class="co">// следующий элемент последовательности</span>
    <span class="co">// Воспользуемся тем фактом, что логические операции возвращают 0 или 1.</span>
    negatives += x &lt; <span class="fl">0.0</span>;
    positives += x &gt; <span class="fl">0.0</span>;
  }

  <span class="co">// Без приведения к double будет деление в целых числах.</span>
  <span class="kw">return</span> <span class="dt">double</span>(positives) / negatives;
}

<span class="co">// П.2: тестирование функции из п.1 на заранее заданных массивах.</span>
<span class="dt">bool</span> test_pn_ratio()
{
  <span class="dt">const</span> <span class="dt">double</span> test1[] = { <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">100</span>, <span class="dv">0</span>, <span class="dv">20</span>, <span class="dv">0</span>, <span class="dv">-1</span>, <span class="dv">-2</span>, <span class="dv">3</span>, <span class="dv">-6</span> };
  <span class="co">// sizeof возвращает размер статического массива в байтах</span>
  <span class="co">// (!) при этом массив должен быть виден в данном контексте непосредственно,</span>
  <span class="co">// (!) иначе программист рискует получить вместо размера массива размер указателя на него</span>
  <span class="kw">if</span> (pn_ratio(test1, <span class="kw">sizeof</span>(test1) / <span class="kw">sizeof</span>(<span class="dt">double</span>)) != <span class="fl">5.0</span> / <span class="fl">3.0</span>)
    <span class="kw">return</span> <span class="kw">false</span>;

  <span class="dt">const</span> <span class="dt">double</span> test2[] = { <span class="dv">-40</span>, <span class="dv">-2</span>, <span class="dv">-111</span>, <span class="dv">42</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">-1000</span>, <span class="dv">-4</span> };
  <span class="kw">if</span> (pn_ratio(test2, <span class="kw">sizeof</span>(test2) / <span class="kw">sizeof</span>(<span class="dt">double</span>)) != <span class="fl">2.0</span> / <span class="fl">5.0</span>)
    <span class="kw">return</span> <span class="kw">false</span>;

  <span class="co">// Все проверки прошли успешно.</span>
  <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="co">// П.3: считывание чисел с потока ввода.</span>
<span class="dt">double</span> pn_ratio(istream &amp;in)
{
  <span class="co">// Счётчики положительных и отрицательных чисел.</span>
  size_t positives = <span class="dv">0</span>, negatives = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="dt">double</span> x; in &gt;&gt; x;)
  {
    <span class="kw">if</span> (x &lt; <span class="fl">0.0</span>)
      ++negatives;
    <span class="kw">else</span> <span class="kw">if</span> (x &gt; <span class="fl">0.0</span>)
      ++positives;
  }

  <span class="co">// Без приведения к double будет деление в целых числах.</span>
  <span class="kw">return</span> <span class="dt">double</span>(positives) / negatives;
}

<span class="dt">int</span> main()
{
  <span class="co">// Тестирование варианта обработки данных для массива.</span>
  cout &lt;&lt; test_pn_ratio() &lt;&lt; endl;

  <span class="co">// Вариант для обработки данных с потока ввода.</span>
  <span class="dt">const</span> <span class="kw">auto</span> result = pn_ratio(cin);
  cout &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">Result: "</span> &lt;&lt; result &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="static_array_begin_end.cpp">0505-static_array_begin_end.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// static_array_begin_end.cpp</span>
<span class="co">// Использование std::begin и std::end для получения границ диапазона статического массива.</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;iterator&gt; </span><span class="co">// begin, end</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;
 
<span class="co">// Заполняет [begin, end) квадратами индексов.</span>
<span class="dt">void</span> fill_with_squares(<span class="dt">float</span>* begin, <span class="dt">float</span>* end)
{
  <span class="co">// Количество элементов равно разности указателей.</span>
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i != end - begin; ++i)
    begin[i] = i * i;
}

<span class="co">// Выводим array в консоль.</span>
<span class="dt">void</span> print_array(<span class="dt">float</span>* begin, <span class="dt">float</span>* end)
{
  <span class="kw">while</span> (begin != end)
    cout &lt;&lt; *begin++ &lt;&lt; <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>;
}
 
<span class="dt">int</span> main()
{
  <span class="co">// Локальный статический массив. Его размер виден только внутри main.</span>
  <span class="dt">float</span> squares[<span class="dv">100</span>];
  <span class="co">// begin(squares) возвращает указатель на первый элемент массива, а</span>
  <span class="co">// end(squares) возвращает указатель на фиктивный элемент, следующий за последним элементом массива.</span>
  fill_with_squares(begin(squares), end(squares));
  <span class="co">// Вывести в консоль.</span>
  print_array(begin(squares), end(squares));
}</code></pre></div>
<p><br>
</p>
<h1 id="euclid_norm.cpp">0510-euclid_norm.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// euclid_norm.cpp</span>
<span class="co">// Евклидова норма последовательности как многомерного вектора.</span>
<span class="co">// Пример: { 1, -5, 2, 20, -13 } -&gt; (1+25+4+400+169)1/2 = 24.4744765.</span>
<span class="ot">#include &lt;cstddef&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">///</span> Чувствительность к погрешности при проверке нормы.
<span class="dt">const</span> <span class="dt">double</span> TOLERANCE = <span class="fl">1e-6</span>;

<span class="co">// Сравнение двух значений на примерное равенство</span>
<span class="co">// с заданным уровнем относительной разности tolerance.</span>
<span class="co">// В данном примере используется при тестировании.</span>
<span class="dt">bool</span> almost_equal(<span class="dt">double</span> x1, <span class="dt">double</span> x2, <span class="dt">double</span> tolerance = TOLERANCE)
{
  <span class="kw">return</span> abs(x1 - x2) &lt;= tolerance * fmax(abs(x1), abs(x2));
}

<span class="co">// П.1: обработка произвольного массива, переданного как адрес + размер,</span>
<span class="co">// size_t -- стандартный тип (определён в Стандартной библиотеке C),</span>
<span class="co">// предназначенный для хранения размеров массивов.</span>
<span class="dt">double</span> euclid_norm(<span class="dt">const</span> <span class="dt">double</span> a[], size_t n)
{
  <span class="dt">double</span> s = <span class="fl">0.0</span>;
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; n; ++i)
    s += a[i] * a[i];
  <span class="kw">return</span> sqrt(s);
}

<span class="co">// П.2: тестирование функции из п.2 на заранее заданных массивах.</span>
<span class="dt">bool</span> test_euclid_norm()
{
  <span class="dt">const</span> <span class="dt">double</span> test1[] = { <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">-1</span>, <span class="dv">-2</span>, <span class="dv">-6</span> };
  <span class="co">// sizeof возвращает размер статического массива в байтах</span>
  <span class="co">// (!) при этом массив должен быть виден в данном контексте непосредственно,</span>
  <span class="co">// (!) иначе программист рискует получить вместо размера массива размер указателя на него</span>
  <span class="kw">if</span> (!almost_equal(
        euclid_norm(test1, <span class="kw">sizeof</span>(test1) / <span class="kw">sizeof</span>(<span class="dt">double</span>)),
        <span class="fl">8.18535277</span>))
    <span class="kw">return</span> <span class="kw">false</span>;

  <span class="dt">const</span> <span class="dt">double</span> test2[] = { <span class="dv">-40</span>, <span class="dv">-2</span>, <span class="dv">-111</span>, <span class="dv">42</span>, <span class="dv">2</span>, <span class="dv">-1000</span>, <span class="dv">-4</span> };
  <span class="kw">if</span> (!almost_equal(
        euclid_norm(test2, <span class="kw">sizeof</span>(test2) / <span class="kw">sizeof</span>(<span class="dt">double</span>)),
        <span class="fl">1007.823893</span>))
    <span class="kw">return</span> <span class="kw">false</span>;

  <span class="co">// Все тесты прошли успешно.</span>
  <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="co">// П.3: считывание чисел с потока ввода.</span>
<span class="dt">double</span> euclid_norm(istream &amp;in)
{
  <span class="dt">double</span> s = <span class="fl">0.0</span>;
  <span class="kw">for</span> (<span class="dt">double</span> x; in &gt;&gt; x;)
    s += x * x;
  <span class="kw">return</span> sqrt(s);
}

<span class="dt">int</span> main()
{
  <span class="co">// Запуск тестов из п.2.</span>
  cout &lt;&lt; test_euclid_norm() &lt;&lt; endl;

  <span class="co">// Запуск функции из п.3.</span>
  <span class="dt">const</span> <span class="kw">auto</span> result = euclid_norm(cin);
  cout &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">Result: "</span><span class="co"> </span>&lt;&lt; result &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="euclid_norm_2.cpp">0520-euclid_norm_2.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// euclid_norm_2.cpp</span>
<span class="co">// Евклидова норма последовательности как многомерного вектора.</span>
<span class="co">// Пример: { 1, -5, 2, 20, -13 } -&gt; (1+25+4+400+169)1/2 = 24.4744765.</span>
<span class="ot">#include &lt;cstddef&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;sstream&gt; </span><span class="co">// строковые потоки ввода-вывода</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">///</span> Чувствительность к погрешности при проверке нормы.
<span class="dt">const</span> <span class="dt">double</span> TOLERANCE = <span class="fl">1e-6</span>;

<span class="co">// Сравнение двух значений на примерное равенство</span>
<span class="co">// с заданным уровнем относительной разности tolerance.</span>
<span class="co">// В данном примере используется при тестировании.</span>
<span class="dt">bool</span> almost_equal(<span class="dt">double</span> x1, <span class="dt">double</span> x2, <span class="dt">double</span> tolerance = TOLERANCE)
{
  <span class="kw">return</span> abs(x1 - x2) &lt;= tolerance * fmax(abs(x1), abs(x2));
}

<span class="co">// П.1: обработка произвольного массива, переданного как адрес + размер,</span>
<span class="co">// size_t -- стандартный тип (определён в Стандартной библиотеке C),</span>
<span class="co">// предназначенный для хранения размеров массивов.</span>
<span class="dt">double</span> euclid_norm(<span class="dt">const</span> <span class="dt">double</span> a[], size_t n)
{
  <span class="dt">double</span> s = <span class="fl">0.0</span>;
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; n; ++i)
    s += a[i] * a[i];
  <span class="kw">return</span> sqrt(s);
}

<span class="co">// П.2: тестирование функции из п.2 на заранее заданных массивах.</span>
<span class="dt">bool</span> test_euclid_norm_array()
{
  <span class="dt">const</span> <span class="dt">double</span> test1[] = { <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">-1</span>, <span class="dv">-2</span>, <span class="dv">-6</span> };
  <span class="co">// sizeof возвращает размер статического массива в байтах</span>
  <span class="co">// (!) при этом массив должен быть виден в данном контексте непосредственно,</span>
  <span class="co">// (!) иначе программист рискует получить вместо размера массива размер указателя на него</span>
  <span class="kw">if</span> (!almost_equal(
        euclid_norm(test1, <span class="kw">sizeof</span>(test1) / <span class="kw">sizeof</span>(<span class="dt">double</span>)),
        <span class="fl">8.18535277</span>))
    <span class="kw">return</span> <span class="kw">false</span>;

  <span class="dt">const</span> <span class="dt">double</span> test2[] = { <span class="dv">-40</span>, <span class="dv">-2</span>, <span class="dv">-111</span>, <span class="dv">42</span>, <span class="dv">2</span>, <span class="dv">-1000</span>, <span class="dv">-4</span> };
  <span class="kw">if</span> (!almost_equal(
        euclid_norm(test2, <span class="kw">sizeof</span>(test2) / <span class="kw">sizeof</span>(<span class="dt">double</span>)),
        <span class="fl">1007.823893</span>))
    <span class="kw">return</span> <span class="kw">false</span>;

  <span class="co">// Все тесты прошли успешно.</span>
  <span class="kw">return</span> <span class="kw">true</span>;
}


<span class="co">// П.3: считывание чисел с потока ввода.</span>
<span class="dt">double</span> euclid_norm(istream &amp;in)
{
  <span class="dt">double</span> s = <span class="fl">0.0</span>;
  <span class="kw">for</span> (<span class="dt">double</span> x; in &gt;&gt; x;)
    s += x * x;
  <span class="kw">return</span> sqrt(s);
}

<span class="co">// Дополнение: тестирование функции из п.3 на заранее заданных последовательностях.</span>
<span class="dt">bool</span> test_euclid_norm_stream()
{
  stringstream ts;
  ts &lt;&lt; <span class="dv">4</span> &lt;&lt; <span class="st">' '</span> &lt;&lt; <span class="dv">1</span> &lt;&lt; <span class="st">' '</span> &lt;&lt; <span class="dv">0</span> &lt;&lt; <span class="st">' '</span> &lt;&lt; <span class="dv">3</span> &lt;&lt; <span class="st">' '</span>;
  ts &lt;&lt; <span class="dv">0</span> &lt;&lt; <span class="st">' '</span> &lt;&lt; <span class="dv">-1</span> &lt;&lt; <span class="st">' '</span> &lt;&lt; <span class="dv">-2</span> &lt;&lt; <span class="st">' '</span> &lt;&lt; <span class="dv">-6</span>;
  <span class="kw">if</span> (!almost_equal(euclid_norm(ts), <span class="fl">8.18535277</span>))
    <span class="kw">return</span> <span class="kw">false</span>;

  ts.clear();  <span class="co">// сбросить флаг конца файла</span>
  ts.seekp(<span class="dv">0</span>); <span class="co">// сбросить позицию записи в поток на начало</span>
  ts.seekg(<span class="dv">0</span>); <span class="co">// сбросить позицию чтения из потока на начало</span>
  ts &lt;&lt; <span class="dv">-40</span> &lt;&lt; <span class="st">' '</span> &lt;&lt; <span class="dv">-2</span> &lt;&lt; <span class="st">' '</span> &lt;&lt; <span class="dv">-111</span> &lt;&lt; <span class="st">' '</span> &lt;&lt; <span class="dv">42</span> &lt;&lt; <span class="st">' '</span>;
  ts &lt;&lt; <span class="dv">2</span> &lt;&lt; <span class="st">' '</span> &lt;&lt; <span class="dv">-1000</span> &lt;&lt; <span class="st">' '</span> &lt;&lt; <span class="dv">-4</span>;
  <span class="kw">if</span> (!almost_equal(euclid_norm(ts), <span class="fl">1007.823893</span>))
    <span class="kw">return</span> <span class="kw">false</span>;

  <span class="co">// Все тесты прошли успешно.</span>
  <span class="kw">return</span> <span class="kw">true</span>;
}


<span class="dt">int</span> main()
{
  <span class="co">// Запуск тестов из п.2.</span>
  cout &lt;&lt; test_euclid_norm_array() &lt;&lt; endl;
  <span class="co">// Запуск тестов для функции из п.3.</span>
  cout &lt;&lt; test_euclid_norm_stream() &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="max_duplicates_sequence.cpp">0530-max_duplicates_sequence.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// max_duplicates_sequence.cpp</span>
<span class="co">// Определить длину максимальной подпоследовательности, состоящей из идущих подряд равных элементов.</span>
<span class="co">// Пример: { 1, 2, 3, 3, 0, 0, 0, 1, 2 } -&gt; 3 (три нуля подряд).</span>
<span class="ot">#include &lt;cstddef&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;sstream&gt; </span><span class="co">// строковые потоки для тестирования п.4</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Вычислить максимум двух целых чисел.</span>
<span class="kw">inline</span> size_t max(size_t a, size_t b)
{
  <span class="kw">return</span> a &lt; b? b: a;
}

<span class="co">// П.1: обработка произвольного массива, переданного как адрес + размер</span>
size_t max_duprun(<span class="dt">const</span> <span class="dt">double</span> a[], size_t n)
{
  <span class="kw">if</span> (n == <span class="dv">0</span>)
    <span class="kw">return</span> <span class="dv">0</span>;

  <span class="co">// По крайней мере, один элемент в массиве есть.</span>
  size_t max_run = <span class="dv">1</span>; <span class="co">// максимальная длина на данный момент</span>
  size_t cur_run = <span class="dv">1</span>; <span class="co">// текущая длина</span>
  <span class="kw">for</span> (size_t i = <span class="dv">1</span>; i &lt; n; ++i)
  {
    <span class="kw">if</span> (a[i] != a[i - <span class="dv">1</span>]) <span class="co">// соседние элементы не равны</span>
      cur_run = <span class="dv">1</span>;
    <span class="kw">else</span> <span class="co">// продолжается подпоследовательность равных</span>
      ++cur_run;

    max_run = max(max_run, cur_run);
  }

  <span class="kw">return</span> max_run;
}


<span class="co">// П.2: тестирование функции из п.1 на заданном массиве с заданным результатом.</span>
<span class="dt">bool</span> test_max_duprun_array(<span class="dt">const</span> <span class="dt">double</span> a[], size_t n, size_t result)
{
  <span class="kw">return</span> result == max_duprun(a, n);
}


<span class="co">// П.3: считывание чисел с потока ввода.</span>
size_t max_duprun(istream &amp;in)
{
  size_t max_run = <span class="dv">0</span>; <span class="co">// максимальная длина на данный момент</span>
  <span class="dt">double</span> x, prev_x; <span class="co">// последнее и предпоследнее прочитанные числа</span>
  <span class="kw">if</span> (in &gt;&gt; prev_x)
  {
    <span class="co">// Последовательность содержит не менее одного элемента.</span>
    size_t cur_run = <span class="dv">1</span>; <span class="co">// текущая длина</span>
    max_run = <span class="dv">1</span>; <span class="co">// по крайней мере, есть один элемент</span>

    <span class="kw">while</span> (in &gt;&gt; x)
    {
      <span class="kw">if</span> (x != prev_x) <span class="co">// соседние элементы не равны</span>
      {
        cur_run = <span class="dv">1</span>;
        prev_x = x;
      }
      <span class="kw">else</span> <span class="co">// продолжается подпоследовательность равных</span>
      {
        ++cur_run;
      }

      max_run = max(max_run, cur_run);
    }
  }

  <span class="kw">return</span> max_run;
}


<span class="co">// П.4: тестирование функции из п.3 на заданном массиве с заданным результатом.</span>
<span class="dt">bool</span> test_max_duprun_stream(<span class="dt">const</span> <span class="dt">double</span> a[], size_t n, size_t result)
{
  stringstream test;
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; n; ++i)
    test &lt;&lt; a[i] &lt;&lt; <span class="st">' '</span>;

  <span class="kw">return</span> result == max_duprun(test);
}


<span class="co">// Тип функции-"тестера".</span>
<span class="kw">using</span> Max_duprun_tester = <span class="dt">bool</span> (*)(<span class="dt">const</span> <span class="dt">double</span> a[], size_t n, size_t result);


<span class="co">// П.2 и п.4: тестирование функции из п.1 или п.3 (выбирается через tester).</span>
<span class="dt">int</span> test_max_duprun(Max_duprun_tester tester)
{
  <span class="dt">const</span> <span class="dt">double</span> test1[] = { <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">2</span> };
  <span class="kw">if</span> (!tester(test1, <span class="dv">0</span>, <span class="dv">0</span>)) <span class="kw">return</span> <span class="dv">1</span>;
  <span class="kw">if</span> (!tester(test1, <span class="dv">1</span>, <span class="dv">1</span>)) <span class="kw">return</span> <span class="dv">2</span>;
  <span class="kw">if</span> (!tester(test1, <span class="dv">2</span>, <span class="dv">2</span>)) <span class="kw">return</span> <span class="dv">3</span>;
  <span class="kw">if</span> (!tester(test1, <span class="dv">5</span>, <span class="dv">3</span>)) <span class="kw">return</span> <span class="dv">4</span>;
  
  <span class="co">// sizeof возвращает размер статического массива в байтах</span>
  <span class="co">// (!) при этом массив должен быть виден в данном контексте непосредственно,</span>
  <span class="co">// (!) иначе программист рискует получить вместо размера массива размер указателя на него</span>
  <span class="kw">if</span> (!tester(test1, <span class="kw">sizeof</span>(test1) / <span class="kw">sizeof</span>(<span class="dt">double</span>), <span class="dv">4</span>))
      <span class="kw">return</span> <span class="dv">5</span>;
  
  <span class="dt">const</span> <span class="dt">double</span> test2[] = { <span class="dv">-4</span>, <span class="dv">-3</span>, <span class="dv">-2</span>, <span class="dv">-1</span> };
  <span class="kw">if</span> (!tester(test2, <span class="kw">sizeof</span>(test2) / <span class="kw">sizeof</span>(<span class="dt">double</span>), <span class="dv">1</span>))
    <span class="kw">return</span> <span class="dv">6</span>;

  <span class="dt">const</span> <span class="dt">double</span> test3[] = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span> };
  <span class="kw">if</span> (!tester(test3, <span class="kw">sizeof</span>(test3) / <span class="kw">sizeof</span>(<span class="dt">double</span>), <span class="dv">3</span>))
    <span class="kw">return</span> <span class="dv">7</span>;

  <span class="co">// Все тесты пройдены успешно.</span>
  <span class="kw">return</span> <span class="dv">0</span>;
}


<span class="dt">int</span> main()
{
  cout &lt;&lt; test_max_duprun(test_max_duprun_array)
       &lt;&lt; test_max_duprun(test_max_duprun_stream)
       &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="digit_freqs.cpp">0540-digit_freqs.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// digit_freqs.cpp</span>
<span class="co">// Частоты цифр (относительно всех, только графических, друг друга).</span>
<span class="co">// Выводит только ненулевые частоты.</span>
<span class="ot">#include &lt;cstddef&gt;</span>
<span class="ot">#include &lt;cctype&gt;</span>
<span class="ot">#include &lt;climits&gt; </span><span class="co">// CHAR_BIT</span>
<span class="ot">#include &lt;cassert&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Количество разных байт. Байт и char -- синонимы в C и C++.</span>
<span class="dt">const</span> size_t BYTES = <span class="dv">1u</span> &lt;&lt; CHAR_BIT;

<span class="co">// Целочисленный тип для представления счётчиков.</span>
<span class="co">// Тип streamoff -- целочисленный тип, достаточный для того, чтобы описать смещение в потоке</span>
<span class="co">// или размер любого файла в данной системе, т.е. "достаточно большое целое".</span>
<span class="kw">using</span> Counter = streamoff;

<span class="co">// Тип "гистограмма" -- массив счётчиков.</span>
<span class="kw">using</span> Histogram = Counter[BYTES];

<span class="co">// Строит гистограмму байт потока. Добавляет количества к счётчикам h.</span>
<span class="co">// Возвращает общее количество.</span>
Counter byte_histogram(istream &amp;in, Histogram h)
{
  Counter bytes_read = <span class="dv">0</span>;
  <span class="co">// Читать по символу из потока, увеличивая на каждой итерации соответствующий счётчик в h.</span>
  <span class="kw">for</span> (<span class="dt">char</span> ch; in.get(ch); ++bytes_read)
    h[(<span class="dt">unsigned</span> <span class="dt">char</span>)ch]++; <span class="co">/* Приведение к unsigned char необходимо так как</span>
<span class="co">    по стандарту char может быть "знаковым" и "верхняя половина" диапазона</span>
<span class="co">    в таком случае попадает в отрицательные индексы, что (при прямом использовании char)</span>
<span class="co">    повлекло бы выход за пределы массива h. */</span>
  <span class="kw">return</span> bytes_read;
}

<span class="co">// Строит гистограмму массива. Добавляет количества к счётчикам h.</span>
<span class="co">// Возвращает переданный размер.</span>
size_t byte_histogram(<span class="dt">const</span> <span class="dt">char</span> a[], size_t sz, Histogram h)
{
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; sz; ++i)
    h[(<span class="dt">unsigned</span> <span class="dt">char</span>)(a[i])]++; <span class="co">/* Приведение к unsigned char необходимо так как</span>
<span class="co">    по стандарту char может быть "знаковым" и "верхняя половина" диапазона</span>
<span class="co">    в таком случае попадает в отрицательные индексы, что (при прямом использовании char)</span>
<span class="co">    повлекло бы выход за пределы массива h. */</span>
  <span class="kw">return</span> sz;
}

<span class="co">// Тип: указатель на функцию, принимающую и возвращающую целое число.</span>
<span class="kw">using</span> Char_predicate = <span class="dt">int</span> (*)(<span class="dt">int</span>);

<span class="co">// Возвращает сумму элементов гистограммы, для индексов которых предикат filter возвращает истину.</span>
Counter histogram_filter_sum(<span class="dt">const</span> Histogram h, Char_predicate filter)
{
  Counter s = <span class="dv">0</span>;
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; BYTES; ++i)
    s += filter((<span class="dt">int</span>)i)? h[i]: <span class="dv">0</span>; <span class="co">/* i приводится к int, </span>
<span class="co">    т.к. стандартные функции --- символьные предикаты принимают int, а не size_t */</span>
  <span class="kw">return</span> s;
}


<span class="co">// Преобразование номер десятичной цифры -&gt; символ цифры.</span>
<span class="kw">inline</span> <span class="dt">unsigned</span> <span class="dt">char</span> dec_digit(<span class="dt">int</span> n)
{
  assert(<span class="dv">0</span> &lt;= n &amp;&amp; n &lt; <span class="dv">10</span>);
  <span class="kw">return</span> <span class="st">'0'</span> + n;
}


<span class="co">// Для заданной гистограммы и заданного общего количества символов total получить частоты цифр.</span>
<span class="co">// Возвращает суммарную частоту.</span>
<span class="co">// Данную функцию удобно использовать для тестирования.</span>
<span class="dt">double</span> digits_freqs(<span class="dt">const</span> Histogram h, Counter total, <span class="dt">double</span> freqs[<span class="dv">10</span>])
{
  Counter h_digit_sum = <span class="dv">0</span>;
  <span class="dt">const</span> <span class="kw">auto</span> divisor = <span class="dt">double</span>(total);
  <span class="kw">for</span> (<span class="dt">int</span> digit = <span class="dv">0</span>; digit &lt; <span class="dv">10</span>; ++digit)
  {
    <span class="dt">const</span> <span class="kw">auto</span> h_digit = h[dec_digit(digit)];
    h_digit_sum += h_digit;
    freqs[digit] = h_digit / divisor;
  }

  <span class="kw">return</span> h_digit_sum / divisor;
}

<span class="co">// Вывести частоты в стандартный поток вывода.</span>
<span class="co">// total_freq -- значение, возвращаемое функцией digits_freqs.</span>
<span class="dt">void</span> print_digit_freqs(<span class="dt">const</span> <span class="dt">double</span> freqs[<span class="dv">10</span>], <span class="dt">double</span> total_freq)
{
  <span class="kw">for</span> (<span class="dt">int</span> digit = <span class="dv">0</span>; digit &lt; <span class="dv">10</span>; ++digit)
  {
    <span class="dt">const</span> <span class="kw">auto</span> digit_freq = freqs[digit];
    <span class="kw">if</span> (digit_freq != <span class="fl">0.0</span>)
      cout &lt;&lt; dec_digit(digit) &lt;&lt; <span class="st">": "</span> &lt;&lt; digit_freq &lt;&lt; <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>;
  }
  cout &lt;&lt; <span class="st">"Total: "</span> &lt;&lt; total_freq &lt;&lt; endl;
}

<span class="co">// "Комплекс мероприятий": по гистограмме получить и вывести частоты для всех трёх случаев из задания.</span>
<span class="co">// total -- количество всех символов (сумма гистограммы).</span>
<span class="dt">void</span> print_relative_digit_freqs(<span class="dt">const</span> Histogram h, Counter total)
{
  <span class="dt">double</span> freqs[<span class="dv">10</span>];
  <span class="co">// 1. Для всех символов.</span>
  cout &lt;&lt; <span class="st">"Digits among all characters</span><span class="ch">\n</span><span class="st">"</span>;
  print_digit_freqs(freqs,
    digits_freqs(h, total, freqs));
  
  <span class="co">// 2. Для графических.</span>
  cout &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">Digits among graphical characters</span><span class="ch">\n</span><span class="st">"</span>;
  print_digit_freqs(freqs,
    digits_freqs(h, histogram_filter_sum(h, isgraph), freqs));

  <span class="co">// 3. Для цифр.</span>
  cout &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">Digits among digits</span><span class="ch">\n</span><span class="st">"</span>;
  print_digit_freqs(freqs,
    digits_freqs(h, histogram_filter_sum(h, isdigit), freqs));
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Тестирование</span>

<span class="co">// Сравнение на равенство пары массивов из 10 double.</span>
<span class="dt">bool</span> are_freqs_equal(<span class="dt">const</span> <span class="dt">double</span> ft[<span class="dv">10</span>], <span class="dt">const</span> <span class="dt">double</span> fr[<span class="dv">10</span>])
{
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; ++i)
    <span class="kw">if</span> (ft[i] != fr[i])
      <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="co">// Собственно автоматический тест.</span>
<span class="dt">int</span> test_digits_freqs()
{
  <span class="dt">const</span> <span class="kw">auto</span> text = <span class="st">"This is a text with some 013 digits in it 01456..."</span>;
  <span class="co">// 50 символов, из них графических 40, цифр 8, 0 и 1 встречаются дважды, 3456 -- однажды.</span>
  <span class="dt">const</span> <span class="dt">double</span>
    f0[<span class="dv">10</span>] = { <span class="fl">0.04</span>, <span class="fl">0.04</span>, <span class="fl">0.0</span>,  <span class="fl">0.02</span>,  <span class="fl">0.02</span>,  <span class="fl">0.02</span>,  <span class="fl">0.02</span> },
    f1[<span class="dv">10</span>] = { <span class="fl">0.05</span>, <span class="fl">0.05</span>, <span class="fl">0.0</span>, <span class="fl">0.025</span>, <span class="fl">0.025</span>, <span class="fl">0.025</span>, <span class="fl">0.025</span> },
    f2[<span class="dv">10</span>] = { <span class="fl">0.25</span>, <span class="fl">0.25</span>, <span class="fl">0.0</span>, <span class="fl">0.125</span>, <span class="fl">0.125</span>, <span class="fl">0.125</span>, <span class="fl">0.125</span> };

  Histogram h = {};
  <span class="dt">double</span> freqs[<span class="dv">10</span>];
  <span class="dt">const</span> <span class="kw">auto</span> total = byte_histogram(text, <span class="dv">50</span>, h);

  <span class="kw">if</span> (digits_freqs(h, total, freqs) != <span class="fl">0.16</span>)
    <span class="kw">return</span> <span class="dv">1</span>;
  <span class="kw">if</span> (!are_freqs_equal(freqs, f0))
    <span class="kw">return</span> <span class="dv">2</span>;

  <span class="kw">if</span> (digits_freqs(h, histogram_filter_sum(h, isgraph), freqs) != <span class="fl">0.2</span>)
    <span class="kw">return</span> <span class="dv">3</span>;
  <span class="kw">if</span> (!are_freqs_equal(freqs, f1))
    <span class="kw">return</span> <span class="dv">4</span>;

  <span class="kw">if</span> (digits_freqs(h, histogram_filter_sum(h, isdigit), freqs) != <span class="fl">1.0</span>)
    <span class="kw">return</span> <span class="dv">5</span>;
  <span class="kw">if</span> (!are_freqs_equal(freqs, f2))
    <span class="kw">return</span> <span class="dv">6</span>;

  <span class="kw">return</span> <span class="dv">0</span>;
}


<span class="dt">int</span> main()
{
  cout &lt;&lt; <span class="st">"Testing: "</span> &lt;&lt; test_digits_freqs() &lt;&lt; endl;

  Histogram h = {};
  <span class="kw">auto</span> total = byte_histogram(cin, h);
  cin.clear();

  cout.precision(<span class="dv">16</span>);
  print_relative_digit_freqs(h, total);
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="cstring_array.cpp">0545-cstring_array.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// cstring_array.cpp</span>
<span class="co">// Ввод-вывод средствами стандартной библиотеки C (не C++),</span>
<span class="co">// управление динамической памятью также средствами C (malloc, calloc, realloc, free).</span>
<span class="ot">#include &lt;cstdlib&gt; </span><span class="co">// malloc, realloc, free</span>
<span class="ot">#include &lt;cstdio&gt;  </span><span class="co">// puts, fgets</span>
<span class="ot">#include &lt;cstring&gt; </span><span class="co">// strlen, memcpy</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">///</span> Максимальная длина строки (не включая <span class="st">'</span><span class="ch">\0</span><span class="st">'</span>), возвращаемой нашим вариантом gets.
<span class="dt">const</span> size_t MAX_GETS_LENGTH = <span class="dv">1023</span>;

<span class="co">///</span> Вместо std::gets (которая объявлена устаревшей), мы реализуем
<span class="co">///</span> собственную функцию gets, создающую строку в динамической памяти.
<span class="co">///</span> Если строка на вводе слишком длинная, отрезаем на MAX_GETS_LENGTH символах.
<span class="co">///</span> Возвращает нулевой указатель, если не удалось прочитать ни одного символа.
<span class="dt">char</span>* gets()
{
  <span class="dt">char</span> buffer[MAX_GETS_LENGTH + <span class="dv">1</span>];
  <span class="kw">if</span> (!fgets(buffer, MAX_GETS_LENGTH + <span class="dv">1</span>, stdin))
    <span class="kw">return</span> <span class="kw">nullptr</span>;

  <span class="co">// Узнать длину считанной строки.</span>
  <span class="kw">auto</span> alloc_len = strlen(buffer) + <span class="dv">1</span>;
  <span class="co">// В отличие от gets, fgets записывает в буфер и перевод строки (если хватает места).</span>
  <span class="co">// Уберём этот перевод строки.</span>
  <span class="kw">if</span> (alloc_len &gt; <span class="dv">1</span> &amp;&amp; buffer[alloc_len - <span class="dv">2</span>] == <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)
  {
    buffer[alloc_len - <span class="dv">2</span>] = <span class="st">'</span><span class="ch">\0</span><span class="st">'</span>;
    --alloc_len;
  }
  
  <span class="co">// Выделить в динамической памяти место на копию.</span>
  <span class="dt">const</span> <span class="kw">auto</span> new_str = (<span class="dt">char</span>*)malloc(alloc_len);
  <span class="kw">if</span> (!new_str) <span class="co">// не хватило памяти?</span>
    <span class="kw">return</span> <span class="kw">nullptr</span>;

  <span class="co">// Скопировать содержимое буфера в выделенную память.</span>
  memcpy(new_str, buffer, alloc_len);
  <span class="kw">return</span> new_str;
}

<span class="co">///</span> Читаем построчно и складываем в динамический массив указатели.
<span class="co">///</span> Последний указатель в массиве обязательно нулевой.
<span class="co">///</span> Возвращает нулевой указатель в случае невозможности выделить память хотя бы на два указателя.
<span class="co">///</span> Увеличиваем массив <span class="st">"на ходу"</span><span class="co"> </span>по мере необходимости.
<span class="dt">char</span>** getlines()
{
  <span class="kw">auto</span> lines = (<span class="dt">char</span>**)calloc(<span class="dv">2</span>, <span class="kw">sizeof</span>(<span class="dt">char</span>*));
  <span class="kw">if</span> (!lines) <span class="co">// не хватило памяти?</span>
    <span class="kw">return</span> <span class="kw">nullptr</span>;

  <span class="co">// Цикл по строкам.</span>
  <span class="kw">for</span> (size_t item = <span class="dv">0</span>, capacity = <span class="dv">2</span>; lines[item++] = gets();)
  {
    <span class="kw">if</span> (capacity == item + <span class="dv">1</span>) <span class="co">// все элементы массива задействованы -- увеличим его</span>
    {
      <span class="co">// Попытка 1: попробуем увеличить capacity в 1.5 раза.</span>
      capacity += capacity / <span class="dv">2</span> + <span class="dv">1</span>;
      <span class="co">// Для больших capacity возможно переполнение capacity * sizeof(char*).</span>
      assert((capacity * <span class="kw">sizeof</span>(<span class="dt">char</span>*)) / <span class="kw">sizeof</span>(<span class="dt">char</span>*) == capacity);
      
      <span class="kw">if</span> (<span class="kw">auto</span> new_lines = (<span class="dt">char</span>**)realloc(lines, capacity * <span class="kw">sizeof</span>(<span class="dt">char</span>*)))
      {
        lines = new_lines;
      }
      <span class="kw">else</span> <span class="co">// Попытка 2: попробуем увеличить capacity на 1 элемент.</span>
      <span class="kw">if</span> (<span class="kw">auto</span> new_lines = (<span class="dt">char</span>**)realloc(lines, (item + <span class="dv">2</span>) * <span class="kw">sizeof</span>(<span class="dt">char</span>*)))
      {
        capacity = item + <span class="dv">2</span>;
        lines = new_lines;
      }
      <span class="kw">else</span> <span class="co">// Не получается выделить память.</span>
      {
        lines[item] = <span class="kw">nullptr</span>; <span class="co">// закрывающий нулевой указатель</span>
        <span class="kw">break</span>;
      }
    }
  }

  <span class="kw">return</span> lines;
}

<span class="co">///</span> Вывести в стандартный поток вывода массив строк.
<span class="dt">void</span> putlines(<span class="dt">const</span> <span class="dt">char</span>* <span class="dt">const</span>* lines)
{
  <span class="kw">if</span> (!lines)
    <span class="kw">return</span>;

  <span class="kw">while</span> (*lines)
    puts(*lines++);
}

<span class="co">///</span> Освободить память, занимаемую массивом строк.
<span class="dt">void</span> freelines(<span class="dt">char</span>** lines)
{
  <span class="kw">if</span> (!lines)
    <span class="kw">return</span>;

  <span class="kw">for</span> (<span class="kw">auto</span> p = lines; *p != <span class="kw">nullptr</span>; ++p)
    free(*p);

  free(lines);
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Тестирование: ввести и вывести текст через консоль.</span>
<span class="dt">int</span> main()
{
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="co">// Ввод текста.</span>
    puts(<span class="st">"</span><span class="ch">\n</span><span class="st">Enter a text:</span><span class="ch">\n</span><span class="st">"</span><span class="co">)</span>;
    <span class="kw">auto</span> lines = getlines();
    clearerr(stdin);

    <span class="co">// Вывод текста.</span>
    puts(<span class="st">"</span><span class="ch">\n</span><span class="st">The text entered is:</span><span class="ch">\n</span><span class="st">"</span><span class="co">)</span>;
    putlines(lines);
    freelines(lines);
  }
}</code></pre></div>
<p><br>
</p>
<h1 id="remove_comments_simple.cpp">0550-remove_comments_simple.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// remove_comments_simple.cpp</span>
<span class="co">///</span> Найти в си-строке str символ ch (аналог стандартной функции strchr).
<span class="co">///</span> Возвращает указатель на найденный символ или нулевой указатель, если символа в строке нет.
<span class="dt">char</span>* find_char(<span class="dt">char</span> *str, <span class="dt">char</span> ch)
{
  <span class="kw">for</span> (; *str != <span class="st">'</span><span class="ch">\0</span><span class="st">'</span>; ++str)
  {
    <span class="kw">if</span> (*str == ch)
      <span class="kw">return</span> str;
  }
  <span class="kw">return</span> <span class="kw">nullptr</span>;
}

<span class="co">///</span> Затереть нулём первый символ, открывающий комментарий, закончив таким образом на нём си-строку.
<span class="dt">void</span> remove_comment(<span class="dt">char</span> *line, <span class="dt">char</span> comment_mark)
{
  <span class="kw">if</span> (<span class="kw">auto</span> pos = find_char(line, comment_mark))
    *pos = <span class="st">'</span><span class="ch">\0</span><span class="st">'</span>;
}

<span class="co">///</span> Удалить однострочные комментарии из текста.
<span class="dt">void</span> remove_comments(<span class="dt">char</span> *text[], <span class="dt">char</span> comment_mark)
{
  <span class="kw">for</span> (; *text != <span class="kw">nullptr</span>; ++text)
    remove_comment(*text, comment_mark);
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Тестирование.</span>
<span class="ot">#include &lt;cstring&gt; </span><span class="co">// strcmp, strlen, memcpy</span>

<span class="co">// Вспомогательные функции.</span>

<span class="co">///</span> Сравнение текстов на равенство.
<span class="dt">bool</span> are_equal(<span class="dt">const</span> <span class="dt">char</span> * <span class="dt">const</span> text1[], <span class="dt">const</span> <span class="dt">char</span> * <span class="dt">const</span> text2[])
{
  <span class="kw">for</span> (; *text1 &amp;&amp; *text2; ++text1, ++text2)
  {
    <span class="co">// Сравнение си-строк на равенство с помощью стандартной функции.</span>
    <span class="kw">if</span> (std::strcmp(*text1, *text2) != <span class="dv">0</span>)
      <span class="kw">return</span> <span class="kw">false</span>;
  }
  
  <span class="co">// Оба указателя должны быть нулевыми, если тексты совпадают.</span>
  <span class="kw">return</span> *text1 == *text2;
}


<span class="co">///</span> Определить количество строк в тексте.
std::size_t lines_in_text(<span class="dt">const</span> <span class="dt">char</span> * <span class="dt">const</span> source[])
{
  std::size_t source_size = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="kw">auto</span> p = source; *p != <span class="kw">nullptr</span>; ++p)
    ++source_size;
  <span class="kw">return</span> source_size;
}

<span class="co">///</span> Вспомогательная функция для создания копии текста.
<span class="co">///</span> Она нужна для того, чтобы не изменять значения, заданные строковыми литералами (что чревато неопределённым поведением).
<span class="dt">char</span>** copy_text(<span class="dt">const</span> <span class="dt">char</span> * <span class="dt">const</span> source[])
{
  <span class="co">// Создать массив строк.</span>
  <span class="dt">const</span> <span class="kw">auto</span> source_size = lines_in_text(source);
  <span class="kw">auto</span> copy = <span class="kw">new</span> <span class="dt">char</span>*[source_size + <span class="dv">1</span>];
  <span class="co">// Скопировать массив построчно.</span>
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; source_size; ++i)
  {
    <span class="co">// Выделить память для новой строки.</span>
    <span class="dt">const</span> <span class="kw">auto</span> line_len = std::strlen(source[i]) + <span class="dv">1</span>;
    copy[i] = <span class="kw">new</span> <span class="dt">char</span>[line_len];
    <span class="co">// Скопировать строку (вместе с завершающим нулём).</span>
    std::memcpy(copy[i], source[i], line_len);
  }

  <span class="co">// Записать завершающий нуль.</span>
  copy[source_size] = <span class="kw">nullptr</span>;
  <span class="co">// Вернуть результат.</span>
  <span class="kw">return</span> copy;
}

<span class="co">///</span> Освобождение памяти, занятой текстом, созданным с помощью функции copy_text.
<span class="dt">void</span> free_text(<span class="dt">char</span> *text[])
{
  <span class="kw">for</span> (<span class="kw">auto</span> p = text; *p != <span class="kw">nullptr</span>; ++p)
    <span class="kw">delete</span>[] *p;
  <span class="kw">delete</span>[] text;
}

<span class="co">// Собственно тестирование.</span>

<span class="co">///</span> Тест функции remove_comments.
<span class="dt">bool</span> test_remove_comments()
{
  <span class="co">// Исходный текст.</span>
  <span class="dt">const</span> <span class="dt">char</span> *input[] =
  {
    <span class="st">""</span><span class="co">,</span>
    <span class="st">"# comment"</span>,
    <span class="st">"something; # comment"</span>,
    <span class="st">"'hello, world!'"</span>,
    <span class="st">"'# not a comment but it's OK to cut here too'... # a real comment"</span>,
    <span class="kw">nullptr</span>
  };

  <span class="co">// Текст результата, который должен получиться.</span>
  <span class="dt">const</span> <span class="dt">char</span> *reference[] =
  {
    <span class="st">""</span>,
    <span class="st">""</span>,
    <span class="st">"something; "</span>,
    <span class="st">"'hello, world!'"</span>,
    <span class="st">"'"</span>,
    <span class="kw">nullptr</span>
  };

  <span class="kw">auto</span> text = copy_text(input);
  remove_comments(text, <span class="st">'#'</span>);

  <span class="dt">const</span> <span class="kw">auto</span> result = are_equal(text, reference);
  free_text(text);
  <span class="kw">return</span> result;
}

<span class="ot">#include &lt;iostream&gt;</span>
<span class="dt">int</span> main()
{
  std::cout &lt;&lt; test_remove_comments();
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="simple_tokenize.cpp">0560-simple_tokenize.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// simple_tokenize.cpp</span>
<span class="co">//</span>
<span class="co">// Задача.</span>
<span class="co">//</span>
<span class="co">// Вычленить в строке слова, заполнив массив си-строк указателями на первые буквы слов,</span>
<span class="co">// а пробельные символы заменив нулями.</span>
<span class="co">// Память под массив выделяется извне (пользователем).</span>
<span class="co">// Функция принимает указатель на целевой массив и его размер,</span>
<span class="co">// возвращает указатель на последний необработанный символ (нулевой указатель, если вся строка обработана).</span>
<span class="co">// Элемент, следующий за последним записанным в массив указателем должен быть нулём.</span>
<span class="co">//</span>
<span class="co">// Алгоритм.</span>
<span class="co">//</span>
<span class="co">// Пока исходная строка не кончилась, циклически повторяем два действия:</span>
<span class="co">//</span>
<span class="co">// 1. Проходим по исходной строке, затирая нулями пробельные символы.</span>
<span class="co">// Если встретился непробельный символ, то записываем указатель на него на следующую позицию в массиве.</span>
<span class="co">// 2. Двигаемся по строке до первого пробельного символа.</span>
<span class="co">//</span>

<span class="ot">#include &lt;cassert&gt;</span>
<span class="ot">#include &lt;cstddef&gt; </span><span class="co">// size_t</span>
<span class="ot">#include &lt;cctype&gt; </span><span class="co">// isspace</span>

<span class="co">///</span> Затереть последовательность пробельных символов нулевым символом.
<span class="dt">char</span>* zero_spaces(<span class="dt">char</span> *text)
{
  <span class="kw">while</span> (std::isspace(*text))
    *text++ = <span class="st">'</span><span class="ch">\0</span><span class="st">'</span>;
  <span class="kw">return</span> text;
}

<span class="co">///</span> Пропустить все непробельные символы (кроме завершающего нуля).
<span class="dt">char</span>* skip_non_spaces(<span class="dt">char</span> *line)
{
  <span class="kw">while</span> (*line != <span class="st">'</span><span class="ch">\0</span><span class="st">'</span> &amp;&amp; !std::isspace(*line))
    ++line;
  <span class="kw">return</span> line;
}

<span class="co">///</span> Выполнить вычленение <span class="st">"слов"</span><span class="co"> </span>в строке text, указатели на слова записать в массив words.
<span class="co">///</span> Массив words создаётся кодом, вызывающим эту функцию.
<span class="co">///</span> Параметром words_size передаётся размер массива words.
<span class="dt">char</span>* split(<span class="dt">char</span> *text, <span class="dt">char</span> *words[], std::size_t words_size)
{
  assert(words_size &gt; <span class="dv">1</span>);
  <span class="dt">const</span> <span class="kw">auto</span> max_words = words_size - <span class="dv">1</span>;
  <span class="kw">for</span> (std::size_t word = <span class="dv">0</span>; word &lt; max_words; ++word)
  {
    text = zero_spaces(text);
    <span class="kw">if</span> (*text == <span class="st">'</span><span class="ch">\0</span><span class="st">'</span>)
    {
      words[word] = <span class="kw">nullptr</span>;
      <span class="kw">return</span> <span class="kw">nullptr</span>;
    }

    words[word] = text;
    text = skip_non_spaces(text);
  }

  words[max_words] = <span class="kw">nullptr</span>;

  <span class="co">// Перейти к началу следующего слова.</span>
  text = zero_spaces(text);
  <span class="co">// Возможно, строка кончилась (т.е. был "хвост" из пробельных символов), тогда вернуть nullptr.</span>
  <span class="kw">return</span> *text != <span class="st">'</span><span class="ch">\0</span><span class="st">'</span> ? text : <span class="kw">nullptr</span>;
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Тестирование.</span>
<span class="ot">#include &lt;cstring&gt; </span><span class="co">// strcmp, strlen, memcpy</span>

<span class="co">///</span> Сравнение текстов на равенство.
<span class="dt">bool</span> are_equal(<span class="dt">const</span> <span class="dt">char</span> * <span class="dt">const</span> text1[], <span class="dt">const</span> <span class="dt">char</span> * <span class="dt">const</span> text2[])
{
  <span class="kw">for</span> (; *text1 &amp;&amp; *text2; ++text1, ++text2)
  {
    <span class="co">// Сравнение си-строк на равенство с помощью стандартной функции.</span>
    <span class="kw">if</span> (std::strcmp(*text1, *text2) != <span class="dv">0</span>)
      <span class="kw">return</span> <span class="kw">false</span>;
  }

  <span class="co">// Оба указателя должны быть нулевыми, если тексты совпадают.</span>
  <span class="kw">return</span> *text1 == *text2;
}


<span class="co">///</span> Тест split.
<span class="dt">int</span> test_split()
{
  <span class="dt">char</span> text[] = <span class="st">"Just a simple sentence."</span><span class="co">;</span>
  <span class="dt">const</span> <span class="dt">char</span> *reference[] =
  {
    <span class="st">"Just"</span>,
    <span class="st">"a"</span>,
    <span class="st">"simple"</span>,
    <span class="st">"sentence."</span>,
    <span class="kw">nullptr</span>
  };

  <span class="co">// Проверка случая, когда передан массив достаточного размера.</span>
  <span class="dt">char</span> *words[<span class="dv">10</span>];
  <span class="kw">if</span> (split(text, words, <span class="dv">10</span>))
    <span class="kw">return</span> <span class="dv">1</span>; <span class="co">// split должна вернуть нулевой указатель</span>

  <span class="kw">if</span> (!are_equal(words, reference))
    <span class="kw">return</span> <span class="dv">2</span>;

  <span class="co">// Проверка случая, когда передан массив недостаточного размера.</span>
  <span class="dt">char</span> long_text[] =
    <span class="st">"This program is free software; you can redistribute it and/or modify</span><span class="ch">\n</span><span class="st">"</span>
    <span class="st">"it under the terms of the GNU General Public License as published by</span><span class="ch">\n</span><span class="st">"</span>
    <span class="st">"the Free Software Foundation; either version 3 of the License, or (at</span><span class="ch">\n</span><span class="st">"</span>
    <span class="st">"your option) any later version."</span>;

  <span class="dt">const</span> <span class="kw">auto</span> last_pos = split(long_text, words, <span class="dv">10</span>);
  <span class="kw">if</span> (!last_pos || <span class="kw">sizeof</span>(long_text) &lt; last_pos - long_text)
    <span class="kw">return</span> <span class="dv">3</span>;

  <span class="kw">if</span> (*last_pos != <span class="st">'a'</span>) <span class="co">// следующее слово было бы "and/or"</span>
    <span class="kw">return</span> <span class="dv">4</span>;

  <span class="dt">const</span> <span class="dt">char</span> *long_reference[] =
  {
    <span class="st">"This"</span>,
    <span class="st">"program"</span>,
    <span class="st">"is"</span>,
    <span class="st">"free"</span>,
    <span class="st">"software;"</span>,
    <span class="st">"you"</span>,
    <span class="st">"can"</span>,
    <span class="st">"redistribute"</span>,
    <span class="st">"it"</span>,
    <span class="kw">nullptr</span>
  };

  <span class="kw">if</span> (!are_equal(words, long_reference))
    <span class="kw">return</span> <span class="dv">5</span>;

  <span class="kw">return</span> <span class="dv">0</span>; <span class="co">// ошибки не обнаружены.</span>
}


<span class="ot">#include &lt;iostream&gt;</span>
<span class="dt">int</span> main()
{
  <span class="dt">const</span> <span class="kw">auto</span> test = test_split();
  std::cout &lt;&lt; test &lt;&lt; std::endl;
  assert(test == <span class="dv">0</span>);
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="login.c">0565-login.c</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// login.c</span>
<span class="co">// Пример уязвимости gets и printf.</span>
<span class="co">// Имел параллели в реальном коде.</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;time.h&gt;</span>


<span class="co">// Сгенерировать псевдослучайную строку.</span>
<span class="dt">void</span> generate_random_str(<span class="dt">char</span> *str, size_t n)
{
  memset(str, <span class="dv">0</span>, n + <span class="dv">1</span>);
  <span class="kw">while</span> (n--)
    str[n] = <span class="st">'a'</span> + rand() % <span class="dv">26</span>;
}


<span class="co">// Сгенерировать псевдослучайные логин и пароль.</span>
<span class="dt">void</span> load_credentials(<span class="dt">char</span> **login, <span class="dt">char</span> **pwd)
{
  <span class="dt">static</span> <span class="dt">char</span> login_buf[<span class="dv">9</span>];
  <span class="dt">static</span> <span class="dt">char</span> pwd_buf[<span class="dv">9</span>];

  generate_random_str(login_buf, <span class="dv">8</span>);
  generate_random_str(pwd_buf, <span class="dv">8</span>);

  *login = login_buf;
  *pwd = pwd_buf;
}


<span class="dt">int</span> main(<span class="dt">void</span>)
{
<span class="ot">#define BUFSIZE 80</span>
  <span class="dt">char</span> login_buf[BUFSIZE];
  <span class="dt">char</span> pwd_buf[BUFSIZE];
    
  <span class="dt">char</span> *root_login;
  <span class="dt">char</span> *root_pwd;

  <span class="co">// Сгенерировать случайные логин и пароль.</span>
  srand(time(NULL));
  load_credentials(&amp;root_login, &amp;root_pwd);

  <span class="co">// Допускается бесконечное число попыток входа.</span>
  <span class="kw">for</span> (;;)
  {
    <span class="co">// Считать логин.</span>
    memset(login_buf, <span class="dv">0</span>, BUFSIZE);
    memset(pwd_buf, <span class="dv">0</span>, BUFSIZE);
    printf(<span class="st">"Login:"</span>);
    gets(login_buf);

    <span class="co">// Считать пароль.</span>
    printf(<span class="st">"Pwd:"</span>);
    gets(pwd_buf);
    
    <span class="co">// Сравнить логин и пароль со сгенерированными.</span>
    <span class="kw">if</span> (strcmp(login_buf, root_login) || strcmp(pwd_buf, root_pwd))
    {
      printf(login_buf);
      printf(<span class="st">" failed to login</span><span class="ch">\n</span><span class="st">"</span>);
    }
    <span class="kw">else</span> <span class="co">// access granted</span>
    {
      printf(<span class="st">"Congratulations! Access granted!</span><span class="ch">\n</span><span class="st">"</span>);
      <span class="kw">break</span>;
    }
  }

  getchar(); <span class="co">// задержка экрана</span>
}</code></pre></div>
<p><br>
</p>
<h1 id="longest_palindromic_substring_a.cpp">0570-longest_palindromic_substring_a.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// longest_palindromic_substring_a.cpp</span>
<span class="co">// Задача: в заданной строке найти самую длинную подстроку-палиндром.</span>
<span class="co">// Алгоритм решения: начиная с длины строки (и уменьшая её до 2) перебирать все подстроки заданной длины,</span>
<span class="co">// проверяя, являются ли они палиндромами.</span>
<span class="ot">#include &lt;cstddef&gt;</span>

<span class="co">///</span> Функция проверяет, является ли содержимое диапазона строки палиндромом.
<span class="dt">bool</span> is_palindrome(<span class="dt">const</span> <span class="dt">char</span> *begin, <span class="dt">const</span> <span class="dt">char</span> *end)
{
  <span class="kw">while</span> (begin &lt; end)
    <span class="kw">if</span> (*begin++ != *--end)
      <span class="kw">return</span> <span class="kw">false</span>;

  <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="co">///</span> Найти самую длинную подстроку-палиндром в диапазоне строки.
<span class="co">///</span> Возвращает длину найденной подстроки, по указателю found записывает указатель на начало найденной подстроки.
std::size_t longest_palindrome(<span class="dt">const</span> <span class="dt">char</span> *begin, <span class="dt">const</span> <span class="dt">char</span> *end, <span class="dt">const</span> <span class="dt">char</span> **found)
{
  <span class="kw">for</span> (<span class="kw">auto</span> n = end - begin; n &gt; <span class="dv">1</span>; --n) <span class="co">// длина палиндрома</span>
  {
    <span class="kw">for</span> (<span class="kw">auto</span> pos = begin; end - pos &gt;= n; ++pos) <span class="co">// начало подстроки</span>
    {
      <span class="kw">if</span> (is_palindrome(pos, pos + n)) <span class="co">// палиндром?</span>
      {
        *found = pos;
        <span class="kw">return</span> n;
      }
    }
  }

  <span class="kw">return</span> <span class="dv">0</span>;
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Тестирование</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cassert&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">///</span> В заданном объекте std::string найти самую длинную подстроку-палиндром
<span class="co">///</span> и вернуть её в виде нового объекта std::string.
string longest_palindrome(<span class="dt">const</span> string &amp;text)
{
  <span class="dt">const</span> <span class="dt">char</span> *pos = <span class="kw">nullptr</span>;
  <span class="dt">const</span> <span class="kw">auto</span> len = longest_palindrome(text.data(), text.data() + text.size(), &amp;pos);
  <span class="kw">return</span> string(pos, pos + len);
}

<span class="co">///</span> Проверка результата для тестовых строк.
<span class="dt">int</span> test_longest_palindrome()
{
  <span class="kw">if</span> (longest_palindrome(<span class="st">"this isn't a text with no palindromic substrings"</span><span class="co">)</span> != <span class="st">"t a t"</span><span class="co">)</span>
    <span class="kw">return</span> <span class="dv">1</span>;
  <span class="kw">if</span> (longest_palindrome(<span class="st">"there is no word redivider in English"</span>) != <span class="st">" redivider "</span>)
    <span class="kw">return</span> <span class="dv">2</span>;
  <span class="kw">if</span> (longest_palindrome(<span class="st">"who knows what </span><span class="ch">\"</span><span class="st">detartrated</span><span class="ch">\"</span><span class="st"> means?"</span>) != <span class="st">" </span><span class="ch">\"</span><span class="st">detartrated</span><span class="ch">\"</span><span class="st"> "</span>)
    <span class="kw">return</span> <span class="dv">3</span>;
  <span class="kw">if</span> (longest_palindrome(<span class="st">"saippuakalasalakauppias is longer than"</span>
                         <span class="st">"saippuakivikauppias but what about"</span>
                         <span class="st">"kuulilennuteetunneliluuk?"</span>) != <span class="st">"kuulilennuteetunneliluuk"</span>)
    <span class="kw">return</span> <span class="dv">4</span>;
  <span class="kw">if</span> (longest_palindrome(<span class="st">"blast"</span>) != <span class="st">""</span>)
    <span class="kw">return</span> <span class="dv">5</span>;
  <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> main()
{
  <span class="kw">auto</span> test = test_longest_palindrome();
  cout &lt;&lt; test &lt;&lt; endl;
  assert(test == <span class="dv">0</span>);
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="longest_palindromic_substring_b.cpp">0580-longest_palindromic_substring_b.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// longest_palindromic_substring_b.cpp</span>
<span class="co">// Задача: в заданной строке найти самую длинную подстроку-палиндром.</span>
<span class="co">// Алгоритм решения</span>
<span class="co">// Искать набольшую общую подстроку двух строк: исходной и исходной в обратном порядке.</span>
<span class="ot">#include &lt;cstddef&gt;</span>

<span class="co">///</span> Найти совпадающие символы при движении по диапазону <span class="dv">1</span> в прямом направлении, а по диапазону <span class="dv">2</span> -- в обратном.
<span class="co">///</span> Возвращает истину, если удалось найти.
<span class="dt">bool</span> find_factor
  (
    <span class="dt">const</span> <span class="dt">char</span> *begin1, <span class="dt">const</span> <span class="dt">char</span> *end1, <span class="co">// диапазон 1</span>
    <span class="dt">const</span> <span class="dt">char</span> *begin2, <span class="dt">const</span> <span class="dt">char</span> *end2, <span class="co">// диапазон 2</span>
    <span class="dt">const</span> <span class="dt">char</span> **found1, <span class="co">// позиция найденного символа в диапазоне 1</span>
    <span class="dt">const</span> <span class="dt">char</span> **found2  <span class="co">// позиция найденного символа в диапазоне 2</span>
  )
{
  <span class="kw">while</span> (begin1 != end1 &amp;&amp; begin2 != end2)
  {
    <span class="kw">if</span> (*begin1++ == *--end2)
    {
      *found1 = begin1 - <span class="dv">1</span>;
      *found2 = end2;
      <span class="kw">return</span> <span class="kw">true</span>;
    }
  }

  <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="co">///</span> Посчитать длину максимальной совпадающей последовательности с начала диапазона <span class="dv">1</span> и конца диапазона <span class="fl">2.</span>
std::size_t longest_common_prefix_suffix
  (
    <span class="dt">const</span> <span class="dt">char</span> *begin1, <span class="dt">const</span> <span class="dt">char</span> *end1, <span class="co">// диапазон 1</span>
    <span class="dt">const</span> <span class="dt">char</span> *begin2, <span class="dt">const</span> <span class="dt">char</span> *end2  <span class="co">// диапазон 2</span>
  )
{
  std::size_t cnt = <span class="dv">0</span>;
  <span class="kw">while</span> (begin1 != end1 &amp;&amp; begin2 != end2)
  {
    <span class="kw">if</span> (*begin1++ != *--end2)
      <span class="kw">break</span>;
    ++cnt;
  }

  <span class="kw">return</span> cnt;
}


<span class="co">///</span> Идти по диапазону <span class="dv">1</span> с начала, а по диапазону <span class="dv">2</span> -- с конца.
<span class="co">///</span> В случае совпадающей последовательности символов считать их и вернуть самую длинную последовательность (указатель в диапазоне <span class="dv">1</span>).
std::size_t longest_common_factor_0
  (
    <span class="dt">const</span> <span class="dt">char</span> *begin1, <span class="dt">const</span> <span class="dt">char</span> *end1, <span class="co">// диапазон 1</span>
    <span class="dt">const</span> <span class="dt">char</span> *begin2, <span class="dt">const</span> <span class="dt">char</span> *end2, <span class="co">// диапазон 2</span>
    <span class="dt">const</span> <span class="dt">char</span> **found1 <span class="co">// позиция найденной подстроки в диапазоне 1</span>
  )
{
  std::size_t cur_max = <span class="dv">0</span>;
  <span class="kw">while</span> (find_factor(begin1, end1, begin2, end2, &amp;begin1, &amp;end2))
  {
    <span class="kw">if</span> (end1 &lt;= begin1 + cur_max || ++end2 &lt;= begin2 + cur_max)
      <span class="kw">break</span>;

    <span class="co">// Первый символ уже проверен find_factor, отсюда отступы на единицы.</span>
    <span class="dt">const</span> <span class="kw">auto</span> factor_len = <span class="dv">1</span> + longest_common_prefix_suffix(begin1 + <span class="dv">1</span>, end1, begin2, end2 - <span class="dv">1</span>);
    <span class="kw">if</span> (cur_max &lt; factor_len)
    {
      *found1 = begin1;
      cur_max = factor_len;
    }

    begin1 += factor_len;
    end2 -= factor_len;
  }

  <span class="kw">return</span> cur_max;
}


<span class="co">///</span> Перебирать все подстроки диапазона <span class="dv">1</span>, сохраняя максимум результата longest_common_factor.
std::size_t longest_common_factor_1
(
  <span class="dt">const</span> <span class="dt">char</span> *begin1, <span class="dt">const</span> <span class="dt">char</span> *end1, <span class="co">// диапазон 1</span>
  <span class="dt">const</span> <span class="dt">char</span> *begin2, <span class="dt">const</span> <span class="dt">char</span> *end2, <span class="co">// диапазон 2</span>
  <span class="dt">const</span> <span class="dt">char</span> **found1 <span class="co">// позиция найденной подстроки в диапазоне 1</span>
  )
{
  std::size_t cur_max = <span class="dv">0</span>;
  <span class="kw">for</span> (; begin1 + cur_max &lt; end1; ++begin1)
  {
    <span class="dt">const</span> <span class="dt">char</span> *factor_pos;
    <span class="dt">const</span> <span class="kw">auto</span> factor_len = longest_common_factor_0(begin1, end1, begin2, end2, &amp;factor_pos);
    <span class="kw">if</span> (cur_max &lt; factor_len)
    {
      cur_max = factor_len;
      *found1 = factor_pos;
    }
  }

  <span class="kw">return</span> cur_max;
}

<span class="co">///</span> Перебирать все подстроки диапазона <span class="dv">2</span>, сохраняя максимум результата longest_common_factor.
std::size_t longest_common_factor_2
(
  <span class="dt">const</span> <span class="dt">char</span> *begin1, <span class="dt">const</span> <span class="dt">char</span> *end1, <span class="co">// диапазон 1</span>
  <span class="dt">const</span> <span class="dt">char</span> *begin2, <span class="dt">const</span> <span class="dt">char</span> *end2, <span class="co">// диапазон 2</span>
  <span class="dt">const</span> <span class="dt">char</span> **found1 <span class="co">// позиция найденной подстроки в диапазоне 1</span>
  )
{
  std::size_t cur_max = <span class="dv">0</span>;
  <span class="kw">for</span> (; begin2 + cur_max &lt; end2; --end2)
  {
    <span class="dt">const</span> <span class="dt">char</span> *factor_pos;
    <span class="dt">const</span> <span class="kw">auto</span> factor_len = longest_common_factor_0(begin1, end1, begin2, end2, &amp;factor_pos);
    <span class="kw">if</span> (cur_max &lt; factor_len)
    {
      cur_max = factor_len;
      *found1 = factor_pos;
    }
  }

  <span class="kw">return</span> cur_max;
}


<span class="co">///</span> Найти самую длинную подстроку-палиндром в диапазоне строки.
<span class="co">///</span> Возвращает длину найденной подстроки, по указателю found записывает указатель на начало найденной подстроки.
std::size_t longest_palindrome(<span class="dt">const</span> <span class="dt">char</span> *begin, <span class="dt">const</span> <span class="dt">char</span> *end, <span class="dt">const</span> <span class="dt">char</span> **found)
{
  <span class="dt">const</span> <span class="dt">char</span> *f1, *f2;
  <span class="dt">const</span> <span class="kw">auto</span>
    l1 = longest_common_factor_1(begin, end, begin, end, &amp;f1),
    l2 = longest_common_factor_2(begin, end, begin, end, &amp;f2);

  <span class="kw">if</span> (l1 == <span class="dv">1</span> &amp;&amp; l2 == <span class="dv">1</span>)
    <span class="kw">return</span> <span class="dv">0</span>;

  <span class="kw">if</span> (l2 &lt; l1)
  {
    *found = f1;
    <span class="kw">return</span> l1;
  }
  <span class="kw">else</span>
  {
    *found = f2;
    <span class="kw">return</span> l2;
  }
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Тестирование</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cassert&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">///</span> В заданном объекте std::string найти самую длинную подстроку-палиндром
<span class="co">///</span> и вернуть её в виде нового объекта std::string.
string longest_palindrome(<span class="dt">const</span> string &amp;text)
{
  <span class="dt">const</span> <span class="dt">char</span> *pos = <span class="kw">nullptr</span>;
  <span class="dt">const</span> <span class="kw">auto</span> len = longest_palindrome(text.data(), text.data() + text.size(), &amp;pos);
  <span class="kw">return</span> string(pos, pos + len);
}

<span class="co">///</span> Проверка результата для тестовых строк.
<span class="dt">int</span> test_longest_palindrome()
{
  <span class="kw">if</span> (longest_palindrome(<span class="st">"this isn't a text with no palindromic substrings"</span><span class="co">)</span> != <span class="st">"t a t"</span><span class="co">)</span>
    <span class="kw">return</span> <span class="dv">1</span>;
  <span class="kw">if</span> (longest_palindrome(<span class="st">"there is no word redivider in English"</span>) != <span class="st">" redivider "</span>)
    <span class="kw">return</span> <span class="dv">2</span>;
  <span class="kw">if</span> (longest_palindrome(<span class="st">"who knows what </span><span class="ch">\"</span><span class="st">detartrated</span><span class="ch">\"</span><span class="st"> means?"</span>) != <span class="st">" </span><span class="ch">\"</span><span class="st">detartrated</span><span class="ch">\"</span><span class="st"> "</span>)
    <span class="kw">return</span> <span class="dv">3</span>;
  <span class="kw">if</span> (longest_palindrome(<span class="st">"saippuakalasalakauppias is longer than"</span>
                         <span class="st">"saippuakivikauppias but what about"</span>
                         <span class="st">"kuulilennuteetunneliluuk?"</span>) != <span class="st">"kuulilennuteetunneliluuk"</span>)
    <span class="kw">return</span> <span class="dv">4</span>;
  <span class="kw">if</span> (longest_palindrome(<span class="st">"blast"</span>) != <span class="st">""</span>)
    <span class="kw">return</span> <span class="dv">5</span>;
  <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> main()
{
  <span class="kw">auto</span> test = test_longest_palindrome();
  cout &lt;&lt; test &lt;&lt; endl;
  assert(test == <span class="dv">0</span>);
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="longest_palindromic_substring_c.cpp">0590-longest_palindromic_substring_c.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// longest_palindromic_substring_c.cpp</span>
<span class="co">// Задача: в заданной строке найти самую длинную подстроку-палиндром.</span>
<span class="co">// Алгоритм решения</span>
<span class="co">// Палиндромы нечётной длины: перебирать символы строки, определять наибольший палиндром, центром которого они являются.</span>
<span class="co">// Палиндромы чётной длины: перебирать пары совпадающих символов, определять наибольший палиндром, центром которого они являются.</span>
<span class="ot">#include &lt;cstddef&gt;</span>
<span class="ot">#include &lt;cassert&gt;</span>

<span class="co">///</span> Определить максимальную длину совпадающих суффикса массива [begin, left) и префикса массива [right, end)
std::size_t max_common_prefix_suffix
  (
    <span class="dt">const</span> <span class="dt">char</span> *begin, <span class="dt">const</span> <span class="dt">char</span> *left,
    <span class="dt">const</span> <span class="dt">char</span> *right, <span class="dt">const</span> <span class="dt">char</span> *end
  )
{
  std::size_t steps = <span class="dv">0</span>;
  <span class="kw">while</span> (begin != left &amp;&amp; right != end &amp;&amp; *--left == *right++)
    ++steps;
  <span class="kw">return</span> steps;
}

<span class="co">///</span> Определить радиус палиндрома нечётной длины с центром center.
<span class="kw">inline</span> std::size_t longest_odd_palindrome_radius_from
  (
    <span class="dt">const</span> <span class="dt">char</span> *begin, <span class="dt">const</span> <span class="dt">char</span> *end,
    <span class="dt">const</span> <span class="dt">char</span> *center
  )
{
  assert(begin &lt;= center &amp;&amp; center &lt; end);
  <span class="kw">return</span> max_common_prefix_suffix(begin, center, center + <span class="dv">1</span>, end);
}

<span class="co">///</span> Определить радиус палиндрома чётной длины с центром (левым символом пары) в center.
<span class="kw">inline</span> std::size_t longest_even_palindrome_radius_from
  (
    <span class="dt">const</span> <span class="dt">char</span> *begin, <span class="dt">const</span> <span class="dt">char</span> *end,
    <span class="dt">const</span> <span class="dt">char</span> *center
  )
{
  assert(begin &lt;= center &amp;&amp; center + <span class="dv">1</span> &lt; end);
  <span class="kw">return</span> max_common_prefix_suffix(begin, center, center + <span class="dv">2</span>, end);
}


<span class="co">///</span> Найти самую длинную подстроку-палиндром в диапазоне строки.
<span class="co">///</span> Возвращает длину найденной подстроки, по указателю found записывает указатель на начало найденной подстроки.
std::size_t longest_palindrome(<span class="dt">const</span> <span class="dt">char</span> *begin, <span class="dt">const</span> <span class="dt">char</span> *end, <span class="dt">const</span> <span class="dt">char</span> **found)
{
  std::size_t cur_max = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="kw">auto</span> pos = begin + <span class="dv">1</span>; pos + <span class="dv">1</span> &lt; end; ++pos)
  {
    <span class="dt">const</span> <span class="kw">auto</span> odd_len = <span class="dv">2</span> * longest_odd_palindrome_radius_from(begin, end, pos) + <span class="dv">1</span>;
    <span class="kw">if</span> (cur_max &lt; odd_len)
    {
      cur_max = odd_len;
      *found = pos - odd_len / <span class="dv">2</span>;
    }

    <span class="kw">if</span> (*pos == *(pos + <span class="dv">1</span>))
    {
      <span class="dt">const</span> <span class="kw">auto</span> even_len = <span class="dv">2</span> * longest_even_palindrome_radius_from(begin, end, pos) + <span class="dv">2</span>;
      <span class="kw">if</span> (cur_max &lt; even_len)
      {
        cur_max = even_len;
        *found = (pos + <span class="dv">1</span>) - even_len / <span class="dv">2</span>;
      }
    }
  }

  <span class="kw">return</span> cur_max &gt; <span class="dv">1</span> ? cur_max : <span class="dv">0</span>;
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Тестирование</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">///</span> В заданном объекте std::string найти самую длинную подстроку-палиндром
<span class="co">///</span> и вернуть её в виде нового объекта std::string.
string longest_palindrome(<span class="dt">const</span> string &amp;text)
{
  <span class="dt">const</span> <span class="dt">char</span> *pos = <span class="kw">nullptr</span>;
  <span class="dt">const</span> <span class="kw">auto</span> len = longest_palindrome(text.data(), text.data() + text.size(), &amp;pos);
  <span class="kw">return</span> string(pos, pos + len);
}

<span class="co">///</span> Проверка результата для тестовых строк.
<span class="dt">int</span> test_longest_palindrome()
{
  <span class="kw">if</span> (longest_palindrome(<span class="st">"this isn't a text with no palindromic substrings"</span><span class="co">)</span> != <span class="st">"t a t"</span><span class="co">)</span>
    <span class="kw">return</span> <span class="dv">1</span>;
  <span class="kw">if</span> (longest_palindrome(<span class="st">"there is no word redivider in English"</span>) != <span class="st">" redivider "</span>)
    <span class="kw">return</span> <span class="dv">2</span>;
  <span class="kw">if</span> (longest_palindrome(<span class="st">"who knows what </span><span class="ch">\"</span><span class="st">detartrated</span><span class="ch">\"</span><span class="st"> means?"</span>) != <span class="st">" </span><span class="ch">\"</span><span class="st">detartrated</span><span class="ch">\"</span><span class="st"> "</span>)
    <span class="kw">return</span> <span class="dv">3</span>;
  <span class="kw">if</span> (longest_palindrome(<span class="st">"saippuakalasalakauppias is longer than"</span>
                         <span class="st">"saippuakivikauppias but what about"</span>
                         <span class="st">"kuulilennuteetunneliluuk?"</span>) != <span class="st">"kuulilennuteetunneliluuk"</span>)
    <span class="kw">return</span> <span class="dv">4</span>;
  <span class="kw">if</span> (longest_palindrome(<span class="st">"blast"</span>) != <span class="st">""</span>)
    <span class="kw">return</span> <span class="dv">5</span>;
  <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> main()
{
  <span class="kw">auto</span> test = test_longest_palindrome();
  cout &lt;&lt; test &lt;&lt; endl;
  assert(test == <span class="dv">0</span>);
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="function_ptr_solve.cpp">0600-function_ptr_solve.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// function_ptr_solve.cpp</span>
<span class="co">// Приближённое решение произвольного уравнения f(x) = 0</span>
<span class="co">// методом деления отрезка пополам.</span>
<span class="co">// f передаётся указателем на функцию.</span>
<span class="ot">#include &lt;cassert&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>

<span class="co">///</span> Тип <span class="st">"правая часть уравнения"</span><span class="co"> </span>-- функция одного действительного параметра.
<span class="kw">typedef</span> <span class="dt">double</span> (*Unary_real_function)(<span class="dt">double</span>);

<span class="co">///</span> Точность приближённого решения, используемая по умолчанию.
<span class="dt">const</span> <span class="dt">double</span> TOLERANCE = <span class="fl">1e-8</span>;

<span class="co">///</span> Алгоритм численного решения уравнения f(x) = <span class="dv">0</span> на отрезке [a, b] делением отрезка пополам.
<span class="co">///</span> Данный алгоритм является вариантом двоичного поиска.
<span class="dt">double</span> nsolve(Unary_real_function f, <span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> tol = TOLERANCE)
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  assert(f != <span class="kw">nullptr</span>);
  assert(a &lt; b);
  assert(<span class="fl">0.</span> &lt;= tol);
  <span class="kw">for</span> (<span class="kw">auto</span> fa = f(a), fb = f(b);;)
  {
    <span class="co">// Проверим значения функции на концах отрезка.</span>
    <span class="kw">if</span> (fa == <span class="fl">0.</span>)
      <span class="kw">return</span> a;
    <span class="kw">if</span> (fb == <span class="fl">0.</span>)
      <span class="kw">return</span> b;

    <span class="co">// Делим отрезок пополам.</span>
    <span class="dt">const</span> <span class="kw">auto</span> mid = <span class="fl">0.5</span> * (a + b); <span class="co">// середина отрезка</span>
    <span class="kw">if</span> (mid &lt;= a || b &lt;= mid)
      <span class="kw">return</span> abs(fa) &lt; abs(fb)? a: b;
    <span class="kw">if</span> (b - a &lt;= tol)
      <span class="kw">return</span> mid;

    <span class="co">// Выберем одну из половин в качестве уточнённого отрезка.</span>
    <span class="dt">const</span> <span class="kw">auto</span> fmid = f(mid);
    <span class="kw">if</span> (signbit(fa) != signbit(fmid))
    {
      <span class="co">// Корень на левой половине.</span>
      b = mid;
      fb = fmid;
    }
    <span class="kw">else</span>
    {
      assert(signbit(fb) != signbit(fmid));
      <span class="co">// Корень на правой половине.</span>
      a = mid;
      fa = fmid;
    }
  }
}


<span class="co">// Тестирование.</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">///</span> Модельная функция <span class="fl">1.</span>
<span class="dt">double</span> poly5(<span class="dt">double</span> x)
{
  <span class="kw">return</span> (x - <span class="fl">1.</span>)*(x - <span class="fl">2.</span>)*(x - <span class="fl">3.</span>)*(x - <span class="fl">4.</span>)*(x - <span class="fl">5.</span>);
}

<span class="co">///</span> Модельная функция <span class="fl">2.</span>
<span class="dt">double</span> loge(<span class="dt">double</span> x)
{
  <span class="kw">return</span> log(x) - <span class="fl">1.</span>;
}

<span class="co">///</span> Модельная функция <span class="fl">3.</span>
<span class="dt">double</span> ipl(<span class="dt">double</span> x)
{
  <span class="kw">return</span> x*x*x - pow(<span class="fl">3.</span>, x);
}


<span class="co">///</span> Вывести результат для заданной функции.
<span class="dt">void</span> print_root(Unary_real_function f, <span class="dt">double</span> a, <span class="dt">double</span> b)
{
  <span class="dt">const</span> <span class="kw">auto</span> root = nsolve(f, a, b);
  cout &lt;&lt; <span class="st">"on ["</span><span class="co"> </span>&lt;&lt; a &lt;&lt; <span class="st">", "</span><span class="co"> </span>&lt;&lt; b &lt;&lt; <span class="st">"] root is "</span><span class="co"> </span>&lt;&lt; root &lt;&lt; endl;
}

<span class="dt">int</span> main()
{
  <span class="kw">struct</span> { <span class="dt">const</span> <span class="dt">char</span> *msg; Unary_real_function f; <span class="dt">double</span> a, b; }
  tasks[] =
  {
    { <span class="st">"poly: "</span><span class="co">,</span> poly5, <span class="fl">0.5</span>, <span class="fl">100.</span> },
    { <span class="st">"poly (1): "</span><span class="co">,</span> poly5, <span class="fl">0.5</span>, <span class="fl">1.5</span> },
    { <span class="st">"e: "</span><span class="co">,</span> loge, <span class="fl">0.01</span>, <span class="fl">1000.</span> },
    { <span class="st">"ipl: "</span><span class="co">,</span> ipl, <span class="fl">0.0</span>, <span class="fl">2.7</span> },
    { <span class="st">"ipl (3): "</span><span class="co">,</span> ipl, <span class="fl">2.7</span>, <span class="fl">10.</span> }
  };

  cout.precision(<span class="dv">16</span>);
  <span class="kw">for</span> (<span class="kw">auto</span> &amp;task : tasks)
  {
    cout &lt;&lt; task.msg;
    print_root(task.f, task.a, task.b);
  }

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="nsolve_callback.cpp">0605-nsolve_callback.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// nsolve_callback.cpp</span>
<span class="co">// Приближённое решение произвольного уравнения f(x) = 0 с поиском нескольких корней.</span>
<span class="co">// Метод деления пополам на равномерной сетке, разбивающей заданный отрезок (участок поиска).</span>
<span class="ot">#include &lt;cassert&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>

<span class="co">///</span> Тип <span class="st">"правая часть уравнения"</span><span class="co"> </span>-- функция одного действительного параметра.
<span class="kw">typedef</span> <span class="dt">double</span> (*Unary_real_function)(<span class="dt">double</span>);

<span class="co">///</span> Точность приближённого решения, используемая по умолчанию.
<span class="dt">const</span> <span class="dt">double</span> TOLERANCE = <span class="fl">1e-8</span>;

<span class="co">///</span> Алгоритм численного решения уравнения f(x) = <span class="dv">0</span> на отрезке [a, b] делением отрезка пополам.
<span class="co">///</span> Данный алгоритм является вариантом двоичного поиска.
<span class="dt">double</span> nsolve(Unary_real_function f, <span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> tol = TOLERANCE)
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  assert(f != <span class="kw">nullptr</span>);
  assert(a &lt; b);
  assert(<span class="fl">0.</span> &lt;= tol);
  <span class="kw">for</span> (<span class="kw">auto</span> fa = f(a), fb = f(b);;)
  {
    <span class="co">// Проверим значения функции на концах отрезка.</span>
    <span class="kw">if</span> (fa == <span class="fl">0.</span>)
      <span class="kw">return</span> a;
    <span class="kw">if</span> (fb == <span class="fl">0.</span>)
      <span class="kw">return</span> b;

    <span class="co">// Делим отрезок пополам.</span>
    <span class="dt">const</span> <span class="kw">auto</span> mid = <span class="fl">0.5</span> * (a + b); <span class="co">// середина отрезка</span>
    <span class="kw">if</span> (mid &lt;= a || b &lt;= mid)
      <span class="kw">return</span> abs(fa) &lt; abs(fb)? a: b;
    <span class="kw">if</span> (b - a &lt;= tol)
      <span class="kw">return</span> mid;

    <span class="co">// Выберем одну из половин в качестве уточнённого отрезка.</span>
    <span class="dt">const</span> <span class="kw">auto</span> fmid = f(mid);
    <span class="kw">if</span> (signbit(fa) != signbit(fmid))
    {
      <span class="co">// Корень на левой половине.</span>
      b = mid;
      fb = fmid;
    }
    <span class="kw">else</span>
    {
      assert(signbit(fb) != signbit(fmid));
      <span class="co">// Корень на правой половине.</span>
      a = mid;
      fa = fmid;
    }
  }
}


<span class="co">///</span> Тип <span class="st">"решатель уравнения на отрезке"</span><span class="co"> </span>-- функция вроде nsolve, определённой выше.
<span class="kw">typedef</span> <span class="dt">double</span> (*Equation_solver)(Unary_real_function, <span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> tol);
<span class="co">///</span> Тип функции, вызываемой для каждого корня. 
<span class="co">///</span> Процесс поиска останавливается, если эта функция возвращает ложь.
<span class="kw">typedef</span> <span class="dt">bool</span> (*Root_reporter)(<span class="dt">double</span>);

<span class="co">///</span> Применяет заданный алгоритм поиска корня на отрезке, 
<span class="co">///</span> разбивая заданный отрезок [a, b] на отрезки одинаковой длины step (кроме, возможно, последнего).
<span class="co">///</span> Для каждого найденного корня вызывает функцию report (callback-функция).
<span class="co">///</span> Возвращает правую границу пройденного участка (идёт слева направо по заданному отрезку).
<span class="dt">double</span> repeated_nsolve
  (
    Unary_real_function f, <span class="dt">double</span> a, <span class="dt">double</span> b,
    <span class="dt">double</span> step, <span class="co">// шаг на отрезке</span>
    Root_reporter report,
    <span class="dt">double</span> x_tol = TOLERANCE, <span class="co">// чувствительность по аргументу</span>
    <span class="dt">double</span> f_tol = TOLERANCE, <span class="co">// чувствительность по значению функции</span>
    Equation_solver solver = nsolve
  )
{
  assert(x_tol &gt;= <span class="fl">0.</span> &amp;&amp; f_tol &gt;= <span class="fl">0.</span>);
  assert(a &lt;= b);
  assert(step &gt; <span class="fl">0.</span>);
  assert(f &amp;&amp; report &amp;&amp; solver);

  <span class="kw">using</span> <span class="kw">namespace</span> std;
  <span class="dt">double</span> left = a, f_left = f(left);
  <span class="dt">bool</span> f_left_zero = abs(f_left) &lt;= f_tol;
  
  <span class="co">// Корень на левой границе исходного отрезка?</span>
  <span class="kw">if</span> (f_left_zero &amp;&amp; !report(left))
    <span class="kw">return</span> left;

  <span class="kw">while</span> (left != b)
  {
    <span class="co">// Правая граница очередного участка.</span>
    <span class="dt">const</span> <span class="dt">double</span> right = fmin(b, left + step), f_right = f(right);
    <span class="dt">const</span> <span class="dt">bool</span> f_right_zero = abs(f_right) &lt;= f_tol;
    
    <span class="co">// Корень на правой границе участка?</span>
    <span class="kw">if</span> (f_right_zero &amp;&amp; !report(right))
      <span class="kw">return</span> right;

    <span class="co">// Есть корень внутри участка?</span>
    <span class="kw">if</span> (!(f_left_zero || f_right_zero) &amp;&amp; signbit(f_left) != signbit(f_right))
    {
      <span class="dt">const</span> <span class="dt">double</span> root = solver(f, left, right, x_tol);
      <span class="kw">if</span> (!report(root))
        <span class="kw">return</span> root;
    }

    <span class="co">// Передвинуть левую границу.</span>
    left = right;
    f_left = f_right;
    f_left_zero = f_right_zero;
  }

  <span class="kw">return</span> b;
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Тестирование.</span>

<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">///</span> Модельная функция <span class="fl">1.</span>
<span class="dt">double</span> poly5(<span class="dt">double</span> x)
{
  <span class="kw">return</span> (x - <span class="fl">1.</span>)*(x - <span class="fl">2.</span>)*(x - <span class="fl">3.</span>)*(x - <span class="fl">4.</span>)*(x - <span class="fl">5.</span>);
}

<span class="co">///</span> Модельная функция <span class="fl">2.</span>
<span class="dt">double</span> loge(<span class="dt">double</span> x)
{
  <span class="kw">return</span> log(x) - <span class="fl">1.</span>;
}

<span class="co">///</span> Модельная функция <span class="fl">3.</span>
<span class="dt">double</span> ipl(<span class="dt">double</span> x)
{
  <span class="kw">return</span> x*x*x - pow(<span class="fl">3.</span>, x);
}


<span class="co">///</span> Вывести очередной корень.
<span class="dt">bool</span> print_root(<span class="dt">double</span> root)
{
  cout &lt;&lt; root &lt;&lt; endl;
  <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="dt">int</span> main()
{
  <span class="kw">struct</span> { <span class="dt">const</span> <span class="dt">char</span> *msg; Unary_real_function f; <span class="dt">double</span> a, b, step; }
  tasks[] =
  {
    { <span class="st">"poly: "</span><span class="co">,</span>     poly5, <span class="fl">-10.0</span>, <span class="fl">10.0</span>, <span class="fl">0.5</span> },
    { <span class="st">"poly (1): "</span><span class="co">,</span> poly5, <span class="fl">-10.5</span>, <span class="fl">10.5</span>, <span class="fl">0.3</span> },
    { <span class="st">"e: "</span><span class="co">,</span>        loge,   <span class="fl">0.01</span>, <span class="fl">100.</span>, <span class="fl">0.1</span> },
    { <span class="st">"ipl: "</span><span class="co">,</span>      ipl,   <span class="fl">-100.</span>, <span class="fl">100.</span>, <span class="fl">0.5</span> },
    { <span class="st">"sin: "</span><span class="co">,</span>      sin,      <span class="fl">0.</span>,  <span class="fl">30.</span>, <span class="fl">0.2</span> }
  };

  cout.precision(<span class="dv">16</span>);
  <span class="kw">for</span> (<span class="kw">auto</span> &amp;task : tasks)
  {
    cout &lt;&lt; task.msg &lt;&lt; endl;
    repeated_nsolve(task.f, task.a, task.b, task.step, print_root);
    cout &lt;&lt; <span class="st">"---------------</span><span class="ch">\n</span><span class="st">"</span><span class="co"> </span>&lt;&lt; endl;
  }

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="global_solve.cpp">0610-global_solve.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// global_solve.cpp</span>
<span class="ot">#include &lt;cfloat&gt;</span>
<span class="ot">#include &lt;cassert&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>

<span class="co">///</span> Точность приближённого решения, используемая по умолчанию.
<span class="dt">const</span> <span class="dt">double</span> TOLERANCE = <span class="fl">1e-9</span>;

<span class="co">///</span> Найти диапазон [left, right] такой, что x0 &gt;= left и существует left &lt;= x &lt;= right, что f(x) = <span class="fl">0.</span>
<span class="co">///</span> Предполагается, что f(x) -- непрерывная функция.
<span class="co">///</span> Минимальная ширина шага по x задаётся параметром tol.
<span class="kw">typedef</span> <span class="dt">double</span> (*Function)(<span class="dt">double</span>);
<span class="dt">bool</span> catch_root_to_the_right
  (
    Function f,
    <span class="dt">double</span> &amp;left,
    <span class="dt">double</span> &amp;right, 
    <span class="dt">double</span> x0 = <span class="fl">0.</span>, 
    <span class="dt">double</span> tol = TOLERANCE,
    <span class="dt">double</span> max_j = DBL_MAX
  )
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  max_j = fmin(max_j, <span class="fl">1.</span> / DBL_EPSILON);
  <span class="dt">double</span> f_left = f(x0), f_right;

  <span class="co">// Найти левую границу отрезка.</span>
  <span class="kw">if</span> (isnan(f_left))
    <span class="kw">for</span> (<span class="dt">double</span> j = <span class="fl">1.</span>; j &lt; max_j; j += <span class="fl">2.</span>)
      <span class="kw">for</span> (<span class="dt">double</span> i = tol * j; isfinite(i); i *= <span class="fl">2.</span>)
        <span class="kw">if</span> (isfinite(f_left = f(x0 + i)))
        {
          x0 += i;
          <span class="kw">goto</span> left_found;
        }

left_found:
  <span class="co">// Уже нашли ноль?</span>
  <span class="kw">if</span> (f_left == <span class="fl">0.</span>)
  {
    left = right = x0;
    <span class="kw">return</span> <span class="kw">true</span>;
  }

  <span class="co">// Найти правую границу отрезка.</span>
  <span class="kw">for</span> (<span class="dt">double</span> j = <span class="fl">1.</span>; j &lt; max_j; j += <span class="fl">2.</span>)
    <span class="kw">for</span> (<span class="dt">double</span> i = tol * j; isfinite(i); i *= <span class="fl">2.</span>)
      <span class="kw">if</span> (isfinite(f_right = f(x0 + i)))
      {
        <span class="co">// Нашли ноль?</span>
        <span class="kw">if</span> (f_right == <span class="fl">0.</span>)
        {
          left = right = x0 + i;
          <span class="kw">return</span> <span class="kw">true</span>;
        }

        <span class="co">// Разные знаки на концах отрезка?</span>
        <span class="kw">if</span> (f_left * f_right &lt; <span class="fl">0.</span>)
        {
          left = x0;
          right = x0 + i;
          <span class="kw">return</span> <span class="kw">true</span>;
        }
      }

  <span class="co">// Найти не удалось.</span>
  <span class="kw">return</span> <span class="kw">false</span>;
}


<span class="co">///</span> Алгоритм численного решения уравнения f(x) = <span class="dv">0</span> на отрезке [a, b] делением отрезка пополам.
<span class="co">///</span> Данный алгоритм является вариантом двоичного поиска.
<span class="dt">double</span> nsolve(Function f, <span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> tol = TOLERANCE)
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  assert(f != <span class="kw">nullptr</span>);
  assert(a &lt;= b);
  assert(<span class="fl">0.</span> &lt;= tol);
  <span class="kw">for</span> (<span class="kw">auto</span> fa = f(a), fb = f(b);;)
  {
    <span class="co">// Проверим значения функции на концах отрезка.</span>
    <span class="kw">if</span> (fa == <span class="fl">0.</span>)
      <span class="kw">return</span> a;
    <span class="kw">if</span> (fb == <span class="fl">0.</span>)
      <span class="kw">return</span> b;

    <span class="co">// Делим отрезок пополам.</span>
    <span class="dt">const</span> <span class="kw">auto</span> mid = <span class="fl">0.5</span> * (a + b); <span class="co">// середина отрезка</span>
    <span class="kw">if</span> (mid &lt;= a || b &lt;= mid)
      <span class="kw">return</span> abs(fa) &lt; abs(fb) ? a : b;
    <span class="kw">if</span> (b - a &lt;= tol)
      <span class="kw">return</span> mid;

    <span class="co">// Выберем одну из половин в качестве уточнённого отрезка.</span>
    <span class="dt">const</span> <span class="kw">auto</span> fmid = f(mid);
    <span class="kw">if</span> (signbit(fa) != signbit(fmid))
    {
      <span class="co">// Корень на левой половине.</span>
      b = mid;
      fb = fmid;
    }
    <span class="kw">else</span>
    {
      assert(signbit(fb) != signbit(fmid));
      <span class="co">// Корень на правой половине.</span>
      a = mid;
      fa = fmid;
    }
  }
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Тестирование</span>

<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">struct</span> Test_result
{
  <span class="dt">bool</span> root_found; <span class="co">// корень был найден?</span>
  <span class="dt">double</span> a, b, root, f_root; <span class="co">// диапазон, корень, значение функции в корне</span>
};

<span class="co">// Для заданной функции f найти диапазон, содержащий корень f(x) = 0.</span>
<span class="co">// Затем найти на этом диапазоне сам корень (приближённо) и вычислить значение функции в нём.</span>
<span class="dt">void</span> test(Function f, Test_result &amp;result)
{
  result.root_found = <span class="kw">false</span>;
  <span class="kw">if</span> (catch_root_to_the_right(f, result.a, result.b))
  {
    result.root_found = <span class="kw">true</span>;
    result.root = nsolve(f, result.a, result.b);
    result.f_root = f(result.root);
  }
}

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  cout.precision(<span class="dv">9</span>);
  <span class="co">// Набор заданий: функции и текстовые обозначения.</span>
  <span class="kw">struct</span> Task {
    Function f;
    <span class="dt">const</span> <span class="dt">char</span> *name;
    Test_result result;
  } task[] =
  {
    { sin, <span class="st">"sin"</span><span class="co"> </span>},
    { cos, <span class="st">"cos"</span><span class="co"> </span>},
    <span class="ot">#define F(expr, name) </span>\
<span class="ot">      { [](double x) { return expr; }, name }</span>
    F(tan(x - <span class="fl">1.</span>), <span class="st">"tan1"</span><span class="co">)</span>,
    F(exp(x) - <span class="fl">1000.</span>, <span class="st">"expm"</span><span class="co">)</span>,
    F(<span class="fl">20.</span> / (x*x) - <span class="fl">0.1</span>, <span class="st">"rep"</span><span class="co">)</span>,
    F(pow(<span class="fl">3.</span>, x) - x*x*x, <span class="st">"W3"</span><span class="co">)</span>,
    F(exp(sin(<span class="fl">0.1</span>*x)) - exp(cos(sqrt(<span class="fl">2.</span>)*x)), <span class="st">"cexp"</span><span class="co">)</span>,
    F(log((x + <span class="fl">100.</span>) / x) - <span class="dv">1</span> / sqrt(x), <span class="st">"logr"</span><span class="co">)</span>,
    F(log(sin(x) / x) / tan(x - <span class="fl">2.5</span>)*cos(x), <span class="st">"f1"</span><span class="co">)</span>,
    F(<span class="fl">10.</span> / cbrt(x) - <span class="dv">1</span> / (<span class="fl">1.</span> + log(x + <span class="fl">1.</span>)) + <span class="fl">100.</span> / sqrt(x), <span class="st">"f2"</span><span class="co">)</span>,
    F(atan(log(abs(tan(x) - exp(x)))) - <span class="fl">0.5</span>, <span class="st">"f3"</span><span class="co">)</span>,
    F(atan(log(abs(tan(x + <span class="fl">0.5</span>)*tan(sqrt(<span class="fl">2.</span>)*x + <span class="fl">0.3</span>)))) - <span class="fl">1.4</span>, <span class="st">"f4"</span><span class="co">)</span>,
    F(tanh(-sin(<span class="fl">1.</span> / cosh(x - <span class="fl">100.</span>)*sin(sinh(x - <span class="fl">100.</span>)))) + <span class="fl">0.15</span>, <span class="st">"chirp"</span><span class="co">)</span>,
    F(exp(<span class="fl">-1.</span> / pow(x - <span class="fl">100123.</span>, <span class="dv">8</span>)) - <span class="fl">0.7</span>, <span class="st">"b100k"</span><span class="co">)</span>,
    F(log(x) / exp(<span class="fl">1.</span> / x) + <span class="fl">0.09726</span>, <span class="st">"touch"</span><span class="co">)</span>,
    F(<span class="fl">0.1</span> + cbrt(x) - pow(x, <span class="fl">1.</span>/<span class="fl">5.</span>) - pow(x, <span class="fl">1.</span>/<span class="fl">7.</span>), <span class="st">"357"</span><span class="co">)</span>,
    F((x &lt; <span class="fl">1e+6</span>? abs(sin(x<span class="fl">+0.1</span>)*sin(sqrt(<span class="fl">30.</span>)*x<span class="fl">+0.1</span>)) - <span class="fl">0.001</span>: <span class="fl">1.</span>), <span class="st">"s30"</span><span class="co">)</span>
    <span class="ot">#undef F</span>
  };

  <span class="co">// Параллельное вычисление результатов (использует OpenMP).</span>
  <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> tasks = <span class="kw">sizeof</span>(task) / <span class="kw">sizeof</span>(Task);
  <span class="ot">#pragma omp parallel for</span>
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; tasks; ++i)
    test(task[i].f, task[i].result);

  <span class="co">// Последовательный вывод результатов.</span>
  <span class="kw">for</span> (<span class="kw">auto</span> &amp;t: task)
  {
    cout &lt;&lt; t.name &lt;&lt; <span class="st">": "</span>;
    <span class="kw">auto</span> &amp;r = t.result;
    <span class="kw">if</span> (r.root_found)
    {
      cout &lt;&lt; <span class="st">'['</span> &lt;&lt; r.a &lt;&lt; <span class="st">", "</span> &lt;&lt; r.b &lt;&lt; <span class="st">"], root = "</span>;
      cout &lt;&lt; r.root &lt;&lt; <span class="st">", f(root) = "</span> &lt;&lt; r.f_root &lt;&lt; <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>;
    }
    <span class="kw">else</span>
    {
      cout &lt;&lt; <span class="st">"no roots found</span><span class="ch">\n</span><span class="st">"</span>;
    }
  }

  cout &lt;&lt; <span class="st">"done"</span> &lt;&lt; endl;
  cin.ignore();
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="isqrt.cpp">0620-isqrt.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// isqrt.cpp</span>
<span class="co">// Квадратный корень целого числа, округлённый вниз.</span>
<span class="ot">#include &lt;cstdint&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>


<span class="co">// Через стандартную функцию для вычисления квадратного корня в плавающей точке.</span>
<span class="co">// Должно работать быстро на современных процессорах.</span>
<span class="co">// "Внутри" обычно реализовано на основе метода Ньютона.</span>
<span class="kw">inline</span> <span class="dt">uint32_t</span> isqrt_fpu(<span class="dt">uint32_t</span> n)
{
  <span class="kw">return</span> <span class="dt">uint32_t</span>(sqrt(<span class="dt">double</span>(n)));
}


<span class="co">// Метод деления отрезка пополам.</span>
<span class="dt">uint32_t</span> isqrt_dt1(<span class="dt">uint32_t</span> n)
{
  <span class="co">// Границы диапазона: [0, 65535]</span>
  <span class="co">// (65535 в квадрате представимо в 32-битным числом, 65536 -- уже нет).</span>
  <span class="dt">uint32_t</span> a = <span class="dv">0</span>, b = <span class="dv">65536</span>;
  <span class="co">// Цикл выполняет 16 итераций.</span>
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">16</span>; ++i)
  { 
    <span class="co">// Середина отрезка [a, b], с округлением вниз.</span>
    <span class="dt">const</span> <span class="kw">auto</span> m = (a + b) &gt;&gt; <span class="dv">1</span>;
    <span class="kw">if</span> (m * m &gt; n)
      b = m;
    <span class="kw">else</span>
      a = m;
  }
  <span class="kw">return</span> a;
}


<span class="co">// Метод деления отрезка пополам: на одну переменную меньше.</span>
<span class="dt">uint32_t</span> isqrt_dt2(<span class="dt">uint32_t</span> n)
{
  <span class="dt">register</span> <span class="dt">uint32_t</span> a = <span class="dv">0</span>, d = <span class="dv">32768</span>;
  <span class="kw">do</span>
  {
    <span class="co">// Середина отрезка [a, b], с округлением вниз.</span>
    <span class="dt">const</span> <span class="kw">auto</span> m = a + d;
    <span class="kw">if</span> (m * m &lt;= n)
      a = m;
  } <span class="kw">while</span> (d &gt;&gt;= <span class="dv">1</span>);
  <span class="kw">return</span> a;
}


<span class="co">/////////////////////////////////////////////////////////////////////</span>
<span class="co">// Тестирование</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;ctime&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Корректность</span>
<span class="dt">void</span> test_isqrt()
{
  <span class="kw">for</span> (<span class="dt">uint32_t</span> n = <span class="dv">0</span>;; ++n)
  {
    <span class="dt">const</span> <span class="kw">auto</span>
      fpu = isqrt_fpu(n),
      dt1 = isqrt_dt1(n),
      dt2 = isqrt_dt2(n);
    
    <span class="kw">if</span> (dt1 != fpu)
      cout &lt;&lt; <span class="st">"dt1 "</span> &lt;&lt; n &lt;&lt; endl;
    <span class="kw">if</span> (dt2 != fpu)
      cout &lt;&lt; <span class="st">"dt2 "</span> &lt;&lt; n &lt;&lt; endl;
    <span class="kw">if</span> (n == UINT32_MAX)
      <span class="kw">return</span>;
  }
}

<span class="co">// Время</span>
<span class="ot">#define TIME_TEST(func)</span>\
<span class="ot">  double time_##func(unsigned dummy)</span>\
<span class="ot">  {</span>\
<span class="ot">    const auto t0 = clock();</span>\
<span class="ot">    for (uint32_t n = 0; func(n) != dummy &amp;&amp; n != UINT32_MAX; ++n) {}</span>\
<span class="ot">    return double(clock() - t0) / CLOCKS_PER_SEC;</span>\
<span class="ot">  }</span>

TIME_TEST(isqrt_fpu)
TIME_TEST(isqrt_dt1)
TIME_TEST(isqrt_dt2)

<span class="dt">void</span> time_all(<span class="dt">const</span> <span class="dt">char</span> *msg, <span class="dt">int</span> dummy)
{
  cout &lt;&lt; msg;
  cout &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">fpu: "</span> &lt;&lt; time_isqrt_fpu(dummy) &lt;&lt; <span class="st">"s</span><span class="ch">\n</span><span class="st">"</span>;
  cout &lt;&lt; <span class="st">"dt1:  "</span> &lt;&lt; time_isqrt_dt1(dummy) &lt;&lt; <span class="st">"s</span><span class="ch">\n</span><span class="st">"</span>;
  cout &lt;&lt; <span class="st">"dt2: "</span> &lt;&lt; time_isqrt_dt2(dummy) &lt;&lt; <span class="st">"s</span><span class="ch">\n\n</span><span class="st">"</span>;
}

<span class="dt">int</span> main()
{
  test_isqrt();
  cout &lt;&lt; <span class="st">"Correctness testing done."</span> &lt;&lt; endl;
  time_all(<span class="st">"Full uint32_t range:"</span>, <span class="dv">65536</span>);
  time_all(<span class="st">"First 1/64 of uint32_t range:"</span>, <span class="dv">8192</span>);
  time_all(<span class="st">"First 1/256 of uint32_t range:"</span>, <span class="dv">4096</span>);
  time_all(<span class="st">"First 1/4096 of uint32_t range:"</span>, <span class="dv">1024</span>);
  cout &lt;&lt; <span class="st">"Time testing done."</span> &lt;&lt; endl;
  <span class="co">//cin.ignore();</span>
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="polynomials_estrin2.cpp">0650-polynomials_estrin2.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// polynomials_estrin2.cpp</span>
<span class="co">// Вычисление многочленов.</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>
<span class="ot">#include &lt;cassert&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">///</span> близость значений по абсолютной разности
<span class="dt">bool</span> abs_close(<span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> tol = <span class="fl">1e-10</span>)
{
  <span class="kw">return</span> abs(a - b) &lt;= tol;
}

<span class="co">// многочлены</span>

<span class="co">// sum(ai*x^i, i=0:(n-1)) = (...((a(n-1)*x + a(n-2))*x + ...)*x + a0</span>
<span class="dt">double</span> poly_horner(<span class="dt">double</span> x, <span class="dt">double</span> a[], size_t n)
{
  assert(n != <span class="dv">0</span>);
  <span class="kw">auto</span> s = a[--n];
  <span class="kw">while</span> (n != <span class="dv">0</span>)
    s = s * x + a[--n];
  <span class="kw">return</span> s;
}

<span class="co">// fma(a, b, c) --&gt; (a * b + c) с одним округлением (C99, C++11)</span>
<span class="dt">double</span> poly_horner_fma(<span class="dt">double</span> x, <span class="dt">double</span> a[], size_t n)
{
  assert(n != <span class="dv">0</span>);
  <span class="kw">auto</span> s = a[--n];
  <span class="kw">while</span> (n != <span class="dv">0</span>)
    s = fma(s, x, a[--n]);
  <span class="kw">return</span> s;
}

<span class="co">// a3*x^3 + a2*x^2 + a1*x + a0 = (a3*x + a2)*x^2 + (a1*x + a0)</span>
<span class="co">// sum(ai*x^i, i=0:(n-1)) =</span>
<span class="co">//  (...((a(n-1)*x + a(n-2))*x^2 + (a(n-3)*x + a(n-4)))*x^2 + ...)*x^2 + (a1*x + a0)</span>
<span class="co">// -- метод Горнера по x^2</span>
<span class="dt">double</span> poly_estrin2_fma(<span class="dt">double</span> x, <span class="dt">double</span> a[], size_t n)
{
  assert(n != <span class="dv">0</span>);
  <span class="kw">if</span> (n == <span class="dv">1</span>)
    <span class="kw">return</span> a[<span class="dv">0</span>];

  <span class="co">// один шаг схемы Эстрина + метод Горнера + fma</span>
  <span class="dt">const</span> <span class="kw">auto</span> x2 = x * x;
  <span class="kw">auto</span> s = fma(a[n<span class="dv">-1</span>], x, a[n<span class="dv">-2</span>]);
  <span class="kw">for</span> (--n; n &gt; <span class="dv">2</span>; n -= <span class="dv">2</span>)
  {
    <span class="dt">const</span> <span class="kw">auto</span> p = fma(a[n<span class="dv">-2</span>], x, a[n<span class="dv">-3</span>]);
    s = fma(s, x2, p);
  }

  <span class="co">// если был нечётный размер массива, то n == 2, иначе 1</span>
  <span class="kw">return</span> n != <span class="dv">2</span>? s: fma(s, x, a[<span class="dv">0</span>]);
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Тестирование</span>

<span class="kw">typedef</span> <span class="dt">double</span> (*poly_eval_fun)(<span class="dt">double</span>, <span class="dt">double</span>*, size_t);


<span class="dt">bool</span> test_poly_eval(poly_eval_fun poly)
{
  <span class="dt">double</span> test[] = { <span class="fl">20.</span>, <span class="fl">-1.</span>, <span class="fl">4.</span>, <span class="fl">9.</span>, <span class="fl">-8.</span>, <span class="fl">4.</span> };
  <span class="dt">const</span> size_t size = <span class="kw">sizeof</span>(test) / <span class="kw">sizeof</span>(<span class="dt">double</span>);
  <span class="kw">return</span> poly(<span class="fl">100.</span>, test, <span class="dv">1</span>) == <span class="fl">20.</span>
      &amp;&amp; poly(<span class="fl">0.</span>, test, size) == <span class="fl">20.</span>
      &amp;&amp; poly(<span class="fl">0.</span>, test, size - <span class="dv">1</span>) == <span class="fl">20.</span>

      &amp;&amp; abs_close(poly(<span class="fl">1.</span>, test, size - <span class="dv">1</span>), <span class="fl">24.</span>)
      &amp;&amp; abs_close(poly(<span class="fl">-1.</span>, test, size - <span class="dv">1</span>), <span class="fl">8.</span>)
      &amp;&amp; abs_close(poly(<span class="fl">2.5</span>, test, size - <span class="dv">1</span>), <span class="fl">-129.375</span>)

      &amp;&amp; abs_close(poly(<span class="fl">1.</span>, test, size), <span class="fl">28.</span>)
      &amp;&amp; abs_close(poly(<span class="fl">-1.</span>, test, size), <span class="fl">4.</span>)
      &amp;&amp; abs_close(poly(<span class="fl">2.5</span>, test, size), <span class="fl">261.25</span>);
}

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  poly_eval_fun poly[] =
  {
    poly_horner,
    poly_horner_fma,
    poly_estrin2_fma
  };

  <span class="kw">for</span> (<span class="kw">auto</span> pf: poly)
    cout &lt;&lt; test_poly_eval(pf);
  cout &lt;&lt; endl;

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="amatrix.hpp">0700-amatrix.hpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// amatrix.hpp</span>
<span class="co">// Общие задачи обслуживания динамических массивов, которые можно интерпретировать как матрицы.</span>
<span class="co">// Работа на C++ в стиле C.</span>
<span class="ot">#ifndef AMATRIX_HPP_INCLUDED_AMA700</span>
<span class="ot">#define AMATRIX_HPP_INCLUDED_AMA700</span>

<span class="co">// Используются упакованные двумерные массивы.</span>
<span class="co">// Под "упакованным" понимается массив, все элементы которого расположены в памяти без разрывов.</span>
<span class="co">// Таким образом, фактически двумерный массив является одномерным с особым режимом индексирования.</span>
<span class="co">// Элемент с двумерным индексом (i, j) имеет одномерный индекс (i * cols + j),</span>
<span class="co">// где cols -- количество столбцов (т.е. строки идут друг за другом в памяти).</span>
<span class="ot">#include &lt;cstddef&gt; </span><span class="co">// size_t</span>
<span class="ot">#include &lt;cstdlib&gt; </span><span class="co">// calloc, realloc, free</span>

<span class="co">///</span> Описание матрицы.
<span class="kw">struct</span> Matrix_info
{
  <span class="dt">double</span> *data; <span class="co">///&lt;</span> Указатель на массив элементов.
  size_t rows,  <span class="co">///&lt;</span> Количество строк.
         cols;  <span class="co">///&lt;</span> Размер строки (количество столбцов).
};


<span class="co">// Ключевое слово inline позволяет размещать определения функций </span>
<span class="co">// непосредственно в заголовочном файле, что часто удобно, так как не требуется отдельный .cpp файл.</span>

<span class="co">///</span> Определить количество элементов матрицы mtx.
<span class="kw">inline</span> size_t matrix_size(<span class="dt">const</span> Matrix_info *mtx)
{
  <span class="kw">return</span> mtx-&gt;rows * mtx-&gt;cols;
}

<span class="co">///</span> Создать динамический массив нужного размера, заполнить поля mtx.
<span class="co">///</span> Возвращает <span class="kw">true</span> в случае успеха и <span class="kw">false</span> в случае ошибки.
<span class="co">///</span> В случае ошибки выделения памяти обнуляет поля *mtx.
<span class="kw">inline</span> <span class="dt">bool</span> alloc_matrix(Matrix_info *mtx, size_t rows, size_t cols)
{
  <span class="co">// Проверить, представимо ли произведение rows на cols в виде значения size_t.</span>
  <span class="dt">const</span> <span class="kw">auto</span> elements = rows * cols;
  <span class="kw">if</span> (elements / rows == cols &amp;&amp;
    (mtx-&gt;data = (<span class="dt">double</span>*)std::calloc(elements, <span class="kw">sizeof</span>(<span class="dt">double</span>))))
  {
    mtx-&gt;rows = rows;
    mtx-&gt;cols = cols;
    <span class="kw">return</span> <span class="kw">true</span>;
  }
  <span class="kw">else</span>
  {
    mtx-&gt;data = <span class="kw">nullptr</span>;
    mtx-&gt;rows = <span class="dv">0</span>;
    mtx-&gt;cols = <span class="dv">0</span>;
    <span class="kw">return</span> <span class="kw">false</span>;
  }
}

<span class="co">///</span> Освободить динамический массив, привязанный к матрице.
<span class="co">///</span> Обнуляет поля *mtx.
<span class="kw">inline</span> <span class="dt">void</span> free_matrix(Matrix_info *mtx)
{
  std::free(mtx-&gt;data);
  mtx-&gt;data = <span class="kw">nullptr</span>;
  mtx-&gt;rows = <span class="dv">0</span>;
  mtx-&gt;cols = <span class="dv">0</span>;
}

<span class="co">///</span> Переформатировать существующую матрицу под новый размер.
<span class="co">///</span> Возвращает <span class="kw">true</span> в случае успеха и <span class="kw">false</span> в случае ошибки.
<span class="co">///</span> В случае ошибки выделения памяти оставляет поля *mtx неизменными.
<span class="kw">inline</span> <span class="dt">bool</span> realloc_matrix(Matrix_info *mtx, size_t rows, size_t cols)
{
  <span class="dt">const</span> <span class="kw">auto</span> elements = rows * cols;
  <span class="co">// Проверить, представимо ли произведение rows на cols в виде значения size_t.</span>
  <span class="kw">if</span> (elements / rows != cols)
    <span class="kw">return</span> <span class="kw">false</span>;

  <span class="kw">if</span> (matrix_size(mtx) &lt; elements)
  {
    <span class="dt">const</span> <span class="kw">auto</span> bytes = elements * <span class="kw">sizeof</span>(<span class="dt">double</span>);
    <span class="kw">if</span> (bytes / <span class="kw">sizeof</span>(<span class="dt">double</span>) != elements)
      <span class="kw">return</span> <span class="kw">false</span>; <span class="co">// Столько байт нельзя выделить.</span>

    <span class="co">// Попытаться расширить блок.</span>
    <span class="dt">const</span> <span class="kw">auto</span> data = (<span class="dt">double</span>*)std::realloc(mtx-&gt;data, bytes);
    <span class="kw">if</span> (!data)
      <span class="kw">return</span> <span class="kw">false</span>;

    <span class="co">// Удалось расширить блок.</span>
    mtx-&gt;data = data;
    mtx-&gt;rows = rows;
    mtx-&gt;cols = cols;
    <span class="kw">return</span> <span class="kw">true</span>;
  }
  <span class="kw">else</span>
  {
    mtx-&gt;rows = rows;
    mtx-&gt;cols = cols;
    <span class="kw">return</span> <span class="kw">true</span>;
  }
}

<span class="co">///</span> Присвоить всем элементам матрицы заданное значение.
<span class="kw">inline</span> <span class="dt">void</span> fill_matrix(Matrix_info *mtx, <span class="dt">double</span> value)
{
  <span class="dt">const</span> <span class="kw">auto</span> elements = matrix_size(mtx);
  <span class="dt">const</span> <span class="kw">auto</span> data = mtx-&gt;data;
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; elements; ++i)
    data[i] = value;
}

<span class="co">///</span> Заполнить матрицу значениями из статического массива (если требуется, выделяет память).
<span class="co">///</span> Значения полей *mtx должны быть инициализированы (хотя бы нулями).
<span class="kw">inline</span> <span class="dt">void</span> matrix_from_array(Matrix_info *mtx, size_t rows, size_t cols, <span class="dt">const</span> <span class="dt">double</span> *arr2)
{
  <span class="co">// Подготовить место.</span>
  realloc_matrix(mtx, rows, cols);
  <span class="co">// Скопировать поэлементно подряд.</span>
  <span class="dt">const</span> <span class="kw">auto</span> sz = matrix_size(mtx);
  <span class="dt">const</span> <span class="kw">auto</span> data = mtx-&gt;data;
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; sz; ++i)
    data[i] = arr2[i]; <span class="co">// вместо цикла можно использовать memcpy из cstring</span>
}

<span class="co">///</span> Создать единичную матрицу размера n x n.
<span class="co">///</span> Значения полей *mtx должны быть инициализированы (хотя бы нулями).
<span class="kw">inline</span> <span class="dt">void</span> identity(Matrix_info *mtx, size_t n)
{
  <span class="co">// Подготовить место.</span>
  realloc_matrix(mtx, n, n);
  <span class="co">// Большинство элементов единичной матрицы -- нули.</span>
  fill_matrix(mtx, <span class="fl">0.0</span>);
  <span class="co">// Но по диагонали идут единицы.</span>
  <span class="kw">auto</span> write_pos = mtx-&gt;data;
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; n; ++i)
  {
    *write_pos = <span class="fl">1.0</span>;
    write_pos += (n + <span class="dv">1</span>);
  }
}

<span class="co">///</span> Скопировать содержимое одной матрицы в другую.
<span class="co">///</span> Значения полей *dst должны быть инициализированы (хотя бы нулями).
<span class="kw">inline</span> <span class="dt">void</span> copy_matrix(<span class="dt">const</span> Matrix_info *src, Matrix_info *dst)
{
  <span class="co">// Подготовить место под копию.</span>
  realloc_matrix(dst, src-&gt;rows, src-&gt;cols);
  <span class="co">// Скопировать всё содержимое массива подряд.</span>
  <span class="dt">const</span> <span class="kw">auto</span> elements = matrix_size(src);
  <span class="dt">const</span> <span class="kw">auto</span> sd = src-&gt;data;
  <span class="dt">const</span> <span class="kw">auto</span> dd = dst-&gt;data;
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; elements; ++i)
    dd[i] = sd[i];
}

<span class="co">///</span> Сравнить матрицы на равенство.
<span class="kw">inline</span> <span class="dt">bool</span> matrices_are_equal(<span class="dt">const</span> Matrix_info *a, <span class="dt">const</span> Matrix_info *b)
{
  <span class="co">// Если размеры матриц не равны, то и матрицы не равны.</span>
  <span class="kw">if</span> (a-&gt;rows != b-&gt;rows || a-&gt;cols != b-&gt;cols)
    <span class="kw">return</span> <span class="kw">false</span>;

  <span class="co">// Размеры совпали, сравним поэлементно.</span>
  <span class="dt">const</span> <span class="kw">auto</span> elements = matrix_size(a);
  <span class="kw">auto</span> ad = a-&gt;data, bd = b-&gt;data;
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; elements; ++i)
    <span class="kw">if</span> (ad[i] != bd[i])
      <span class="kw">return</span> <span class="kw">false</span>;

  <span class="co">// Равны поэлементно =&gt; равны.</span>
  <span class="kw">return</span> <span class="kw">true</span>;
}


<span class="co">///</span> Получить указатель на строку с заданным номером (только для чтения).
<span class="kw">inline</span> <span class="dt">const</span> <span class="dt">double</span>* get_row(<span class="dt">const</span> Matrix_info *m, size_t i)
{
  <span class="kw">return</span> m-&gt;data + i * m-&gt;cols;
}

<span class="co">///</span> Получить указатель на строку с заданным номером.
<span class="kw">inline</span> <span class="dt">double</span>* get_row(Matrix_info *m, size_t i)
{
  <span class="kw">return</span> m-&gt;data + i * m-&gt;cols;
}

<span class="co">///</span> Извлечь элемент по номерам строки и столбца.
<span class="kw">inline</span> <span class="dt">double</span> get_element(<span class="dt">const</span> Matrix_info *m, size_t i, size_t j)
{
  <span class="kw">return</span> m-&gt;data[i * m-&gt;cols + j];
}

<span class="co">///</span> Установить элемент с заданными номерами строки и столбца.
<span class="kw">inline</span> <span class="dt">void</span> set_element(Matrix_info *m, size_t i, size_t j, <span class="dt">double</span> value)
{
  m-&gt;data[i * m-&gt;cols + j] = value;
}

<span class="ot">#endif</span><span class="co">//AMATRIX_HPP_INCLUDED_AMA700</span></code></pre></div>
<p><br>
</p>
<h1 id="transpose_naive.cpp">0710-transpose_naive.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// transpose_naive.cpp</span>
<span class="co">// Транспонирование матрицы</span>
<span class="ot">#include "amatrix.hpp"</span>

<span class="co">///</span> Создать новую матрицу mt как результат транспонирования m.
<span class="dt">void</span> make_transpose_naive(<span class="dt">const</span> Matrix_info *m, Matrix_info *mt)
{
  <span class="co">// размеры</span>
  <span class="dt">const</span> <span class="kw">auto</span>
    rows = m-&gt;rows,
    cols = m-&gt;cols;

  <span class="co">// подготовить место</span>
  realloc_matrix(mt, cols, rows);

  <span class="kw">auto</span> m_row  = m-&gt;data;  <span class="co">// начало текущей строки в m</span>
  <span class="kw">auto</span> mt_col = mt-&gt;data; <span class="co">// начало текущего столбца в mt</span>

  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; rows; ++i)
  {
    <span class="kw">auto</span> mt_pos = mt_col; <span class="co">// позиция записи</span>
    <span class="kw">for</span> (size_t j = <span class="dv">0</span>; j &lt; cols; ++j)
    {
      <span class="co">// соседние элементы строки идут в массиве друг за другом непосредственно (шаг = 1)</span>
      *mt_pos = m_row[j];
      <span class="co">// соседние элементы столбца идут в массиве с шагом в одну строку</span>
      <span class="co">// (шаг = rows -- количество столбцов в mt)</span>
      mt_pos += rows;
    }

    ++mt_col; <span class="co">// перейти на следующий столбец в mt</span>
    m_row += cols; <span class="co">// перейти к следующей строке в m</span>
  }

  <span class="co">// простой вариант:</span>
  <span class="co">//for (size_t i = 0; i &lt; rows; ++i)</span>
  <span class="co">//  for (size_t j = 0; j &lt; cols; ++j)</span>
  <span class="co">//    mt-&gt;data[j * mt-&gt;cols + i] = m-&gt;data[i * m-&gt;cols + j];</span>
  <span class="co">// код выше избавлен от умножений</span>
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="co">///</span> Тестирование функции, выполняющей транспозицию.
<span class="dt">int</span> test_transpose()
{
  <span class="dt">int</span> result = <span class="dv">0</span>;
  Matrix_info m = {}, mt = {}, mt2 = {}; <span class="co">// = {} заполняет поля нулями</span>

  <span class="co">// Квадратная матрица, заполненная константой после транспонирования совпдает сама с собой.</span>
  alloc_matrix(&amp;m, <span class="dv">100</span>, <span class="dv">100</span>);
  fill_matrix(&amp;m, <span class="fl">1.0</span>);
  make_transpose_naive(&amp;m, &amp;mt);

  <span class="co">// Серия проверок.</span>
  <span class="kw">if</span> (!matrices_are_equal(&amp;m, &amp;mt))
    result = <span class="dv">1</span>;

  <span class="co">// Единичная матрица при транспонировании тоже не изменяется.</span>
  identity(&amp;m, <span class="dv">90</span>);
  make_transpose_naive(&amp;m, &amp;mt);
  <span class="kw">if</span> (!matrices_are_equal(&amp;m, &amp;mt))
    result = <span class="dv">2</span>;

  <span class="co">// Теперь сделаем так, чтобы транспонированная матрица не была равна исходной,</span>
  <span class="co">// повторное транспонирование должно вернуть исходную матрицу.</span>
  set_element(&amp;m, <span class="dv">1</span>, <span class="dv">25</span>, <span class="fl">100.</span>);
  make_transpose_naive(&amp;m, &amp;mt);
  make_transpose_naive(&amp;mt, &amp;mt2);
  <span class="kw">if</span> (get_element(&amp;mt, <span class="dv">1</span>, <span class="dv">25</span>) != <span class="fl">0.</span>)   result = <span class="dv">3</span>;
  <span class="kw">if</span> (get_element(&amp;mt, <span class="dv">25</span>, <span class="dv">1</span>) != <span class="fl">100.</span>) result = <span class="dv">4</span>;
  <span class="kw">if</span> (matrices_are_equal(&amp;m, &amp;mt))     result = <span class="dv">5</span>;
  <span class="kw">if</span> (!matrices_are_equal(&amp;m, &amp;mt2))   result = <span class="dv">6</span>;

  <span class="co">// Освободим память.</span>
  free_matrix(&amp;m);
  free_matrix(&amp;mt);
  <span class="kw">return</span> result;
}


<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  cout &lt;&lt; test_transpose() &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="matrix_zero_block.cpp">0720-matrix_zero_block.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// matrix_zero_block.cpp</span>
<span class="co">// Требуется определить, являются ли строки или столбцы за пределами максимальной квадратной</span>
<span class="co">// угловой подматрицы нулевыми. В случае, когда исходная матрица квадратная, возвращать истину.</span>
<span class="co">// Формально записать это условие можно следующим образом.</span>
<span class="co">// Пусть A = (a_ij) -- матрица размера n x m.</span>
<span class="co">// Пусть k = min(n, m), проверить, равны ли нулю все элементы a_ij при k&lt;i&lt;=n или k&lt;j&lt;=m.</span>
<span class="ot">#include "amatrix.hpp"</span>

<span class="co">///</span> Определить, являются ли внешние по отношению к квадратной подматрице строки или столбцы нулевыми.
<span class="dt">bool</span> are_outer_lines_zeroes(<span class="dt">const</span> Matrix_info *mtx)
{
  <span class="dt">const</span> <span class="kw">auto</span> data = mtx-&gt;data;
  <span class="dt">const</span> <span class="kw">auto</span> rows = mtx-&gt;rows, cols = mtx-&gt;cols;

  <span class="kw">if</span> (rows &lt; cols)
  {
    <span class="co">// Строк меньше, чем столбцов -- проверим "хвосты" строк на равенство нулю.</span>
    <span class="co">// Длина "хвоста".</span>
    <span class="dt">const</span> <span class="kw">auto</span> diff = cols - rows;
    <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; rows; ++i)
    {
      <span class="co">// Вычислим указатель на первый элемент "хвоста" i-й строки.</span>
      <span class="dt">const</span> <span class="kw">auto</span> tail = data + i * cols + rows;
      <span class="co">// Проверим элементы "хвоста" на равенство нулю.</span>
      <span class="kw">for</span> (size_t j = <span class="dv">0</span>; j &lt; diff; ++j)
        <span class="kw">if</span> (tail[j] != <span class="dv">0</span>)
          <span class="kw">return</span> <span class="kw">false</span>;
    }
  }
  <span class="kw">else</span> <span class="kw">if</span> (cols &lt; rows)
  {
    <span class="co">// Столбцов меньше, чем строк -- проверим "лишние" строки на равенство нулю.</span>
    <span class="co">// Вычислим указатель на первую "лишнюю" строку,</span>
    <span class="co">// все последующие элементы массива принадлежат "лишним" строкам, проверим их на равенство нулю.</span>
    <span class="dt">const</span> <span class="kw">auto</span> excess = data + cols * cols;
    <span class="dt">const</span> <span class="kw">auto</span> size  = (rows - cols) * cols; <span class="co">// сколько оставшихся элементов</span>
    <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; size; ++i)
      <span class="kw">if</span> (excess[i] != <span class="dv">0</span>)
        <span class="kw">return</span> <span class="kw">false</span>;
  }
  
  <span class="co">// Либо матрица является квадратной, либо проверка в ветках if прошла успешно.</span>
  <span class="kw">return</span> <span class="kw">true</span>;
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Тестирование</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> test_are_outer_lines_zeroes()
{
  <span class="dt">int</span> result = <span class="dv">0</span>;
  Matrix_info m = {};
  alloc_matrix(&amp;m, <span class="dv">10</span>, <span class="dv">20</span>);
  fill_matrix(&amp;m, <span class="fl">0.</span>);
  <span class="kw">if</span> (!are_outer_lines_zeroes(&amp;m))
    result = <span class="dv">1</span>;

  set_element(&amp;m, <span class="dv">5</span>, <span class="dv">15</span>, <span class="fl">42.</span>);
  <span class="kw">if</span> (are_outer_lines_zeroes(&amp;m))
    result = <span class="dv">2</span>;

  realloc_matrix(&amp;m, <span class="dv">20</span>, <span class="dv">10</span>);
  fill_matrix(&amp;m, <span class="fl">0.</span>);
  <span class="kw">if</span> (!are_outer_lines_zeroes(&amp;m))
    result = <span class="dv">3</span>;

  set_element(&amp;m, <span class="dv">15</span>, <span class="dv">5</span>, <span class="fl">42.</span>);
  <span class="kw">if</span> (are_outer_lines_zeroes(&amp;m))
    result = <span class="dv">4</span>;

  realloc_matrix(&amp;m, <span class="dv">15</span>, <span class="dv">15</span>);
  fill_matrix(&amp;m, <span class="fl">123.</span>);
  <span class="kw">if</span> (!are_outer_lines_zeroes(&amp;m))
    result = <span class="dv">5</span>;

  free_matrix(&amp;m);
  <span class="kw">return</span> result;
}


<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  cout &lt;&lt; test_are_outer_lines_zeroes() &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="matrix_multiply.cpp">0730-matrix_multiply.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// matrix_multiply.cpp</span>
<span class="co">// Тестирование различных вариантов реализации алгоритма умножения матриц "по определению".</span>
<span class="ot">#include "amatrix.hpp"</span>

<span class="co">// Закомментировать при отсутствии ассемблерных вариантов:</span>
<span class="ot">#define USE_ASSEMBLY_VARIANTS</span>


<span class="co">// Вариант 1 "в лоб".</span>
<span class="dt">bool</span> multiply_v1(<span class="dt">const</span> Matrix_info *a, <span class="dt">const</span> Matrix_info *b, Matrix_info *c)
{
  <span class="dt">const</span> <span class="kw">auto</span> n = a-&gt;rows, s = a-&gt;cols, m = b-&gt;cols;
  <span class="kw">if</span> (n == <span class="dv">0</span> || s == <span class="dv">0</span> || m == <span class="dv">0</span> || s != b-&gt;rows)
    <span class="kw">return</span> <span class="kw">false</span>;

  realloc_matrix(c, n, m);
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; n; ++i)
  {
    <span class="kw">for</span> (size_t k = <span class="dv">0</span>; k &lt; m; ++k)
    {
      <span class="dt">double</span> sum = <span class="fl">0.</span>;
      <span class="kw">for</span> (size_t j = <span class="dv">0</span>; j &lt; s; ++j)
        sum += get_element(a, i, j) * get_element(b, j, k);
      set_element(c, i, k, sum);
    }
  }

  <span class="kw">return</span> <span class="kw">true</span>;
}


<span class="co">// Вариант 2: прямое манипулирование указателями.</span>
<span class="dt">bool</span> multiply_v2(<span class="dt">const</span> Matrix_info *a, <span class="dt">const</span> Matrix_info *b, Matrix_info *c)
{
  <span class="dt">const</span> <span class="kw">auto</span> n = a-&gt;rows, s = a-&gt;cols, m = b-&gt;cols;
  <span class="dt">const</span> <span class="kw">auto</span> b_data = b-&gt;data; <span class="co">// Указатель на массив элементов матрицы b.</span>
  <span class="kw">if</span> (n == <span class="dv">0</span> || s == <span class="dv">0</span> || m == <span class="dv">0</span> || s != b-&gt;rows)
    <span class="kw">return</span> <span class="kw">false</span>;

  realloc_matrix(c, n, m);
  <span class="kw">auto</span> a_row = a-&gt;data,  <span class="co">// Указатель на текущую строку матрицы a.</span>
       c_item = c-&gt;data; <span class="co">// Указатель на текущий элемент матрицы c.</span>

  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; n; ++i, a_row += s)
  {
    <span class="kw">for</span> (size_t k = <span class="dv">0</span>; k &lt; m; ++k)
    {
      <span class="dt">double</span> sum = <span class="fl">0.</span>;
      <span class="kw">auto</span> b_item = b_data + k; <span class="co">// k-й столбец в j-й строке матрицы b.</span>
      <span class="kw">for</span> (size_t j = <span class="dv">0</span>; j &lt; s; ++j, b_item += m)
        sum += a_row[j] * (*b_item);
      *c_item++ = sum;
    }
  }

  <span class="kw">return</span> <span class="kw">true</span>;
}


<span class="co">// Вариант 3: последовательный порядок доступа к памяти.</span>
<span class="dt">bool</span> multiply_v3(<span class="dt">const</span> Matrix_info *a, <span class="dt">const</span> Matrix_info *b, Matrix_info *c)
{
  <span class="dt">const</span> <span class="kw">auto</span> n = a-&gt;rows, s = a-&gt;cols, m = b-&gt;cols;
  <span class="kw">if</span> (n == <span class="dv">0</span> || s == <span class="dv">0</span> || m == <span class="dv">0</span> || s != b-&gt;rows)
    <span class="kw">return</span> <span class="kw">false</span>;

  realloc_matrix(c, n, m);
  fill_matrix(c, <span class="fl">0.</span>);
  <span class="kw">auto</span> a_row = a-&gt;data, <span class="co">// Указатель на текущую строку матрицы a.</span>
       c_row = c-&gt;data; <span class="co">// Указатель на текущую строку матрицы c.</span>

  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; n; ++i, a_row += s, c_row += m)
  {
    <span class="kw">auto</span> b_row = b-&gt;data; <span class="co">// Указатель на текущую строку матрицы b.</span>
    <span class="kw">for</span> (size_t j = <span class="dv">0</span>; j &lt; s; ++j, b_row += m)
    {
      <span class="dt">const</span> <span class="kw">auto</span> aij = a_row[j];
      <span class="kw">for</span> (size_t k = <span class="dv">0</span>; k &lt; m; ++k)
        c_row[k] += aij * b_row[k];
    }
  }

  <span class="kw">return</span> <span class="kw">true</span>;
}


<span class="ot">#ifdef USE_ASSEMBLY_VARIANTS</span>
<span class="co">// Ссылка на процедуру в ассемблерном коде.</span>
<span class="dt">extern</span> <span class="st">"C"</span> <span class="dt">void</span> addmtxmul(<span class="dt">double</span>*, <span class="dt">double</span>*, <span class="dt">double</span>*, size_t, size_t, size_t);

<span class="co">// Вариант 4: обёртка ассемблерного кода.</span>
<span class="dt">bool</span> multiply_v4(<span class="dt">const</span> Matrix_info *a, <span class="dt">const</span> Matrix_info *b, Matrix_info *c)
{
  <span class="dt">const</span> <span class="kw">auto</span> n = a-&gt;rows, s = a-&gt;cols, m = b-&gt;cols;
  <span class="kw">if</span> (n == <span class="dv">0</span> || s == <span class="dv">0</span> || m == <span class="dv">0</span> || s != b-&gt;rows)
    <span class="kw">return</span> <span class="kw">false</span>;

  realloc_matrix(c, n, m);
  fill_matrix(c, <span class="fl">0.</span>);

  addmtxmul(a-&gt;data, b-&gt;data, c-&gt;data, n, s, m);
  <span class="kw">return</span> <span class="kw">true</span>;
}
<span class="ot">#endif</span><span class="co">//USE_ASSEMBLY_VARIANTS</span>


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Тестирование</span>

<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;iterator&gt; </span><span class="co">// begin, end</span>
<span class="ot">#include &lt;chrono&gt;   </span><span class="co">// высокоточный таймер</span>
<span class="ot">#include &lt;random&gt;   </span><span class="co">// генераторы (псевдо)случайных чисел</span>


<span class="co">//////////////////////////////</span>
<span class="co">// Тестирование корректности</span>

<span class="co">// Заполнить матрицу случайными целыми числами из диапазона [-100, 100].</span>
<span class="dt">void</span> random100_matrix(size_t seed, Matrix_info *m)
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  <span class="co">// Генератор псевдослучайной последовательности -- "вихрь Мерсенна".</span>
  std::mt19937_64 rng(seed);
  <span class="co">// Случайное распределение -- равномерное на [-1, 1].</span>
  std::uniform_int_distribution&lt;&gt; dist(<span class="dv">-100</span>, <span class="dv">100</span>);
  <span class="co">// Заполнить матрицу.</span>
  <span class="dt">const</span> <span class="kw">auto</span> sz = matrix_size(m);
  <span class="dt">const</span> <span class="kw">auto</span> data = m-&gt;data;
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; sz; ++i)
    data[i] = dist(rng);
}


<span class="kw">typedef</span> <span class="dt">bool</span> (*Mtx_multiply)(<span class="dt">const</span> Matrix_info*, <span class="dt">const</span> Matrix_info*, Matrix_info*);

<span class="dt">int</span> test_multiply(Mtx_multiply mtx_mul)
{
  Matrix_info a = {}, b = {}, c = {}, t = {};

  <span class="co">// Тестирование на заранее заданных матрицах</span>
  <span class="dt">const</span> <span class="dt">double</span> a_items[<span class="dv">5</span>][<span class="dv">6</span>] =
  {
    { <span class="dv">-10</span>,  <span class="dv">-5</span>,  <span class="dv">-1</span>,   <span class="dv">2</span>,  <span class="dv">6</span>, <span class="dv">12</span> },
    {  <span class="dv">-8</span>,  <span class="dv">-4</span>,   <span class="dv">0</span>,   <span class="dv">1</span>,  <span class="dv">5</span>, <span class="dv">10</span> },
    {  <span class="dv">-4</span>,  <span class="dv">-2</span>,  <span class="dv">-1</span>,   <span class="dv">3</span>,  <span class="dv">5</span>, <span class="dv">15</span> },
    {  <span class="dv">24</span>,  <span class="dv">12</span>,  <span class="dv">10</span>,   <span class="dv">8</span>,  <span class="dv">4</span>,  <span class="dv">2</span> },
    {  <span class="dv">16</span>, <span class="dv">-10</span>,  <span class="dv">30</span>, <span class="dv">-20</span>, <span class="dv">18</span>, <span class="dv">-6</span> }
  };
  matrix_from_array(&amp;a, <span class="dv">5</span>, <span class="dv">6</span>, &amp;a_items[<span class="dv">0</span>][<span class="dv">0</span>]);

  <span class="dt">const</span> <span class="dt">double</span> b_items[<span class="dv">6</span>][<span class="dv">4</span>] =
  {
    {  <span class="dv">1</span>,  <span class="dv">2</span>,  <span class="dv">3</span>,  <span class="dv">4</span> },
    { <span class="dv">40</span>, <span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">10</span> },
    {  <span class="dv">0</span>, <span class="dv">-5</span>, <span class="dv">-6</span>, <span class="dv">-7</span> },
    {  <span class="dv">3</span>,  <span class="dv">5</span>,  <span class="dv">7</span>, <span class="dv">11</span> },
    { <span class="dv">13</span>, <span class="dv">17</span>, <span class="dv">19</span>, <span class="dv">23</span> },
    { <span class="dv">-4</span>, <span class="dv">-3</span>, <span class="dv">-2</span>, <span class="dv">-1</span> }
  };
  matrix_from_array(&amp;b, <span class="dv">6</span>, <span class="dv">4</span>, &amp;b_items[<span class="dv">0</span>][<span class="dv">0</span>]);

  <span class="dt">const</span> <span class="dt">double</span> t_items[<span class="dv">5</span>][<span class="dv">4</span>] =
  {
    { <span class="dv">-174</span>, <span class="dv">-39</span>,  <span class="dv">-70</span>,  <span class="dv">65</span> },
    { <span class="dv">-140</span>, <span class="dv">-36</span>,  <span class="dv">-62</span>,  <span class="dv">44</span> },
    {  <span class="dv">-70</span>,  <span class="dv">12</span>,   <span class="dv">20</span>, <span class="dv">104</span> },
    {  <span class="dv">572</span>, <span class="dv">340</span>,  <span class="dv">500</span>, <span class="dv">324</span> },
    { <span class="dv">-186</span>, <span class="dv">-94</span>, <span class="dv">-218</span>, <span class="dv">-46</span> }
  };
  matrix_from_array(&amp;t, <span class="dv">5</span>, <span class="dv">4</span>, &amp;t_items[<span class="dv">0</span>][<span class="dv">0</span>]);

  <span class="dt">int</span> result = <span class="dv">0</span>;
  <span class="kw">if</span> (!mtx_mul(&amp;a, &amp;b, &amp;c))
  {
    result = <span class="dv">1</span>;
  }
  <span class="kw">else</span> <span class="kw">if</span> (!matrices_are_equal(&amp;c, &amp;t))
  {
    <span class="dt">double</span> cd[<span class="dv">5</span>][<span class="dv">4</span>] = {};
    memcpy(&amp;cd[<span class="dv">0</span>][<span class="dv">0</span>], c.data, <span class="dv">20</span>); <span class="co">// для того, чтобы в отладчике можно было увидеть полученную матрицу</span>
    result = <span class="dv">2</span>;
  }

  <span class="co">// Тестирование на случайных матрицах</span>
  <span class="dt">const</span> size_t Ns[] = { <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">25</span>, <span class="dv">113</span> };
  <span class="dt">const</span> size_t Ss[] = { <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">3</span>, <span class="dv">11</span>, <span class="dv">23</span>, <span class="dv">25</span>, <span class="dv">37</span> };
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>, i_bnd = std::end(Ns) - std::begin(Ns); i &lt; i_bnd; ++i)
  {
    realloc_matrix(&amp;a, Ns[i], Ss[i]);
    random100_matrix(i * <span class="dv">1234</span>, &amp;a);
    
    realloc_matrix(&amp;b, Ss[i], Ns[i]);
    random100_matrix(i * <span class="dv">4321</span>, &amp;b);

    <span class="kw">if</span> (multiply_v1(&amp;a, &amp;b, &amp;t) != mtx_mul(&amp;a, &amp;b, &amp;c))
    {
      result = <span class="dv">3</span>;
      <span class="kw">break</span>;
    }

    <span class="kw">if</span> (!matrices_are_equal(&amp;c, &amp;t))
    {
      result = <span class="dv">4</span>;
      <span class="kw">break</span>;
    }
  }

  free_matrix(&amp;a);
  free_matrix(&amp;b);
  free_matrix(&amp;c);
  free_matrix(&amp;t);
  <span class="kw">return</span> result;
}


<span class="co">//////////////////////////</span>
<span class="co">// Тестирование скорости</span>

<span class="co">// Заполнить матрицу случайными числами из диапазона [-1, 1].</span>
<span class="dt">void</span> random_matrix(Matrix_info *m)
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  <span class="co">// Используем системный генератор случайных чисел для генерации зерна псевдослучайной последовательности.</span>
  random_device seed_gen;
  <span class="co">// Генератор псевдослучайной последовательности -- "вихрь Мерсенна".</span>
  std::mt19937_64 rng(seed_gen());
  <span class="co">// Случайное распределение -- равномерное на [-1, 1].</span>
  std::uniform_real_distribution&lt;&gt; dist(<span class="fl">-1.</span>, <span class="fl">1.</span>);
  <span class="co">// Заполнить матрицу.</span>
  <span class="dt">const</span> <span class="kw">auto</span> sz = matrix_size(m);
  <span class="dt">const</span> <span class="kw">auto</span> data = m-&gt;data;
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; sz; ++i)
    data[i] = dist(rng);
}

<span class="co">// Замерить время, потраченное на перемножение.</span>
<span class="dt">double</span> test_speed(Mtx_multiply mtx_mul, size_t m, size_t s, size_t n, size_t rounds = <span class="dv">1</span>)
{
  <span class="kw">using</span> <span class="kw">namespace</span> std::chrono;
  <span class="dt">volatile</span> <span class="kw">auto</span>
    a = <span class="kw">new</span> Matrix_info[rounds],
    b = <span class="kw">new</span> Matrix_info[rounds],
    c = <span class="kw">new</span> Matrix_info[rounds];

  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; rounds; ++i)
  {
    alloc_matrix(a + i, m, s);
    alloc_matrix(b + i, s, n);
    alloc_matrix(c + i, m, n);

    random_matrix(a + i);
    random_matrix(b + i);
  }

  <span class="co">// Стартовый момент времени.</span>
  <span class="dt">const</span> <span class="kw">auto</span> t0 = high_resolution_clock::now();

  <span class="co">// rounds раз выполнить перемножение.</span>
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; rounds; ++i)
    mtx_mul(a + i, b + i, c + i);

  <span class="co">// Получить продолжительность в секундах (на MSVC 2013 низкая точность).</span>
  <span class="dt">const</span> <span class="kw">auto</span> t1 = high_resolution_clock::now();

  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; rounds; ++i)
  {
    free_matrix(a + i);
    free_matrix(b + i);
    free_matrix(c + i);
  }

  <span class="kw">return</span> duration&lt;<span class="dt">double</span>&gt;(t1 - t0).count() / rounds;
}


<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  <span class="dt">int</span> v = <span class="dv">1</span>;
  Mtx_multiply variants[] =
  {
    multiply_v1, multiply_v2,
    multiply_v3,
  <span class="ot">#ifdef USE_ASSEMBLY_VARIANTS</span>
    multiply_v4
  <span class="ot">#endif</span>
  };

  <span class="kw">for</span> (<span class="kw">auto</span> variant : variants)
    cout &lt;&lt; v++ &lt;&lt; <span class="st">") "</span> &lt;&lt; test_multiply(variant)
    <span class="ot">#if defined(DEBUG) || defined(_DEBUG)</span>
         &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">104 x 104 "</span> &lt;&lt; test_speed(variant, <span class="dv">104</span>, <span class="dv">104</span>, <span class="dv">104</span>)
    <span class="ot">#else</span>
         &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">36 x 36 "</span> &lt;&lt; test_speed(variant, <span class="dv">36</span>, <span class="dv">36</span>, <span class="dv">36</span>, <span class="dv">200000</span>)     <span class="co">// 32kb in L1</span>
         &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">104 x 104 "</span> &lt;&lt; test_speed(variant, <span class="dv">104</span>, <span class="dv">104</span>, <span class="dv">104</span>, <span class="dv">1000</span>)  <span class="co">// 256kb in L2</span>
         &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">208 x 208 "</span> &lt;&lt; test_speed(variant, <span class="dv">208</span>, <span class="dv">208</span>, <span class="dv">208</span>, <span class="dv">200</span>)   <span class="co">// 1Mb in L3</span>
         &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">416 x 416 "</span> &lt;&lt; test_speed(variant, <span class="dv">416</span>, <span class="dv">416</span>, <span class="dv">416</span>, <span class="dv">40</span>)    <span class="co">// 4Mb in L3</span>
         &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">590 x 590 "</span> &lt;&lt; test_speed(variant, <span class="dv">590</span>, <span class="dv">590</span>, <span class="dv">590</span>, <span class="dv">20</span>)    <span class="co">// 8Mb in L3</span>
         &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">3k x 1k "</span> &lt;&lt; test_speed(variant, <span class="dv">3000</span>, <span class="dv">1000</span>, <span class="dv">3000</span>, <span class="dv">5</span>)
         &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">1k x 3k "</span> &lt;&lt; test_speed(variant, <span class="dv">1000</span>, <span class="dv">3000</span>, <span class="dv">1000</span>, <span class="dv">5</span>)
         &lt;&lt; <span class="st">"</span><span class="ch">\n</span><span class="st">2k x 2k "</span> &lt;&lt; test_speed(variant, <span class="dv">2000</span>, <span class="dv">2000</span>, <span class="dv">2000</span>, <span class="dv">5</span>)
    <span class="ot">#endif</span>
         &lt;&lt; endl;

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="cvarargs.cpp">0740-cvarargs.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// cvarargs.cpp</span>
<span class="ot">#include &lt;cmath&gt;</span>
<span class="ot">#include &lt;cstdarg&gt;</span>

<span class="co">///</span> Длина вектора с количеством компонент comps.
<span class="co">///</span> Компоненты вектора передаются параметрами функции.
<span class="dt">double</span> vec_len(<span class="dt">int</span> comps, ...)
{
  std::va_list args;
  va_start(args, comps);

  <span class="dt">double</span> s = <span class="fl">0.0</span>;
  <span class="kw">while</span> (comps-- &gt; <span class="dv">0</span>)
  {
    <span class="dt">const</span> <span class="dt">double</span> arg = va_arg(args, <span class="dt">double</span>);
    s += arg * arg;
  }

  va_end(args);
  <span class="kw">return</span> std::sqrt(s);
}


<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  cout &lt;&lt; vec_len(<span class="dv">1</span>, <span class="fl">2.0</span>) &lt;&lt; endl
    &lt;&lt; vec_len(<span class="dv">2</span>, <span class="fl">1.f</span>, <span class="fl">2.f</span>) &lt;&lt; endl
    &lt;&lt; vec_len(<span class="dv">4</span>, <span class="fl">0.</span>, <span class="fl">0.</span>, <span class="fl">-1.</span>, <span class="fl">0.</span>) &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="recursion.cpp">0750-recursion.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// recursion.cpp</span>

<span class="co">// Демонстрация перехода "рекурсия -&gt; рекурсия через "хвостовой" вызов -&gt; итеративное решение (цикл)".</span>
<span class="co">// Примеры: факториал, числа Фибоначчи, линейный поиск, двоичный поиск.</span>
<span class="co">// При запуске выполняет автоматическое тестирование всех вариантов (кроме линейного поиска).</span>

<span class="co">// rec == "recursive"</span>
<span class="co">// tcr == "tail-call recursion"</span>
<span class="co">// itr == "iterative"</span>

<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// factorial</span>

<span class="dt">double</span> rec_fact(<span class="dt">unsigned</span> n)
{
  <span class="kw">return</span> n == <span class="dv">0</span> ? <span class="fl">1.0</span> : n * rec_fact(n - <span class="dv">1</span>);
}

<span class="dt">double</span> tcr_fact(<span class="dt">unsigned</span> n, <span class="dt">double</span> fact = <span class="fl">1.0</span>)
{
  <span class="kw">return</span> n == <span class="dv">0</span> ? fact : tcr_fact(n - <span class="dv">1</span>, n * fact);
}

<span class="dt">double</span> tcr_fact_caller(<span class="dt">unsigned</span> n)
{
  <span class="kw">return</span> tcr_fact(n);
}

<span class="dt">double</span> itr_fact_0(<span class="dt">unsigned</span> n)
{
  <span class="dt">double</span> fact = <span class="fl">1.0</span>;
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="kw">if</span> (n == <span class="dv">0</span>)
      <span class="kw">return</span> fact;

    <span class="dt">const</span> <span class="kw">auto</span> old_n = n;
    <span class="dt">const</span> <span class="kw">auto</span> old_fact = fact;

    n = old_n - <span class="dv">1</span>;
    fact = old_n * old_fact;
  }
}

<span class="dt">double</span> itr_fact(<span class="dt">unsigned</span> n)
{
  <span class="dt">double</span> fact = <span class="fl">1.0</span>;
  <span class="kw">for</span> (; n != <span class="dv">0</span>; --n)
    fact *= n;
  <span class="kw">return</span> fact;
}


<span class="kw">typedef</span> <span class="dt">double</span> (*fact_variant)(<span class="dt">unsigned</span>);
<span class="dt">int</span> test_fact(fact_variant fact)
{
  <span class="dt">const</span> <span class="dt">unsigned</span> ns[] = { <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">10</span> };
  <span class="dt">const</span> <span class="dt">double</span> fs[] = { <span class="fl">1.</span>, <span class="fl">1.</span>, <span class="fl">2.</span>, <span class="fl">120.</span>, <span class="fl">5040.</span>, <span class="fl">3628800.</span> };
  <span class="kw">for</span> (<span class="dt">unsigned</span> i = <span class="dv">0</span>; i &lt; <span class="kw">sizeof</span>(fs) / <span class="kw">sizeof</span>(<span class="dt">double</span>); ++i)
    <span class="kw">if</span> (fact(ns[i]) != fs[i])
      <span class="kw">return</span> i + <span class="dv">1</span>;
  <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Fibonacci</span>

<span class="dt">double</span> rec_fib(<span class="dt">unsigned</span> n)
{
  <span class="kw">return</span> n &lt; <span class="dv">2</span> ? n : rec_fib(n - <span class="dv">1</span>) + rec_fib(n - <span class="dv">2</span>);
}

<span class="dt">double</span> tcr_fib(<span class="dt">unsigned</span> n, <span class="dt">double</span> a = <span class="fl">0.0</span>, <span class="dt">double</span> b = <span class="fl">1.0</span>)
{
  <span class="kw">return</span> n == <span class="dv">0</span> ? a : tcr_fib(n - <span class="dv">1</span>, b, a + b);
}

<span class="dt">double</span> tcr_fib_caller(<span class="dt">unsigned</span> n)
{
  <span class="kw">return</span> tcr_fib(n);
}

<span class="dt">double</span> itr_fib_0(<span class="dt">unsigned</span> n)
{
  <span class="dt">double</span> a = <span class="fl">0.0</span>, b = <span class="fl">1.0</span>;
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="kw">if</span> (n == <span class="dv">0</span>)
      <span class="kw">return</span> a;

    <span class="dt">const</span> <span class="kw">auto</span> old_n = n;
    <span class="dt">const</span> <span class="kw">auto</span> old_a = a, old_b = b;

    a = old_b;
    b = old_a + old_b;
    n = old_n - <span class="dv">1</span>;
  }
}

<span class="dt">double</span> itr_fib(<span class="dt">unsigned</span> n)
{
  <span class="dt">double</span> a = <span class="fl">0.0</span>, b = <span class="fl">1.0</span>;
  <span class="kw">while</span> (n-- &gt; <span class="dv">0</span>)
  {
    <span class="dt">const</span> <span class="kw">auto</span> sum = a + b;
    a = b;
    b = sum;
  }

  <span class="kw">return</span> a;
}


<span class="kw">typedef</span> <span class="dt">double</span>(*fib_variant)(<span class="dt">unsigned</span>);
<span class="dt">int</span> test_fib(fib_variant fact)
{
  <span class="dt">const</span> <span class="dt">unsigned</span> ns[] = { <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">10</span> };
  <span class="dt">const</span> <span class="dt">double</span> fs[] = { <span class="fl">0.</span>, <span class="fl">1.</span>, <span class="fl">1.</span>, <span class="fl">3.</span>, <span class="fl">8.</span>, <span class="fl">55.</span> };
  <span class="kw">for</span> (<span class="dt">unsigned</span> i = <span class="dv">0</span>; i &lt; <span class="kw">sizeof</span>(fs) / <span class="kw">sizeof</span>(<span class="dt">double</span>); ++i)
    <span class="kw">if</span> (fact(ns[i]) != fs[i])
      <span class="kw">return</span> i + <span class="dv">1</span>;
  <span class="kw">return</span> <span class="dv">0</span>;
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// lsr == "linear search right"</span>

<span class="dt">const</span> <span class="dt">int</span>* rec_lsr(<span class="dt">const</span> <span class="dt">int</span> *begin, <span class="dt">const</span> <span class="dt">int</span> *end, <span class="dt">int</span> x)
{
  <span class="kw">if</span> (begin == end)
    <span class="kw">return</span> end;
  <span class="kw">return</span> *begin == x ? begin : rec_lsr(begin + <span class="dv">1</span>, end, x);
}

<span class="dt">const</span> <span class="dt">int</span>* itr_lsr(<span class="dt">const</span> <span class="dt">int</span> *begin, <span class="dt">const</span> <span class="dt">int</span> *end, <span class="dt">int</span> x)
{
  <span class="kw">for</span> (; begin != end; ++begin)
    <span class="kw">if</span> (*begin == x)
      <span class="kw">break</span>;

  <span class="kw">return</span> begin;
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// bsl == "binary search left"</span>

<span class="dt">const</span> <span class="dt">int</span>* rec_bsl(<span class="dt">const</span> <span class="dt">int</span> *begin, <span class="dt">const</span> <span class="dt">int</span> *end, <span class="dt">int</span> x)
{
  <span class="dt">const</span> <span class="kw">auto</span> mid = begin + (end - begin) / <span class="dv">2</span>;
  <span class="kw">if</span> (mid == begin)
    <span class="kw">return</span> begin == end || *begin &lt; x ? end : begin;

  <span class="kw">return</span> *mid &lt; x ?
    rec_bsl(mid + <span class="dv">1</span>, end, x)
    : rec_bsl(begin, mid, x);
}


<span class="dt">const</span> <span class="dt">int</span>* itr_bsl(<span class="dt">const</span> <span class="dt">int</span> *begin, <span class="dt">const</span> <span class="dt">int</span> *end, <span class="dt">int</span> x)
{
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="dt">const</span> <span class="kw">auto</span> mid = begin + (end - begin) / <span class="dv">2</span>;
    <span class="kw">if</span> (mid == begin)
      <span class="kw">return</span> begin == end || *begin &lt; x ? end : begin;

    <span class="kw">if</span> (*mid &lt; x)
      begin = mid + <span class="dv">1</span>;
    <span class="kw">else</span>
      end = mid;
  }
}


<span class="kw">typedef</span> <span class="dt">const</span> <span class="dt">int</span>* (*bsl_variant)(<span class="dt">const</span> <span class="dt">int</span>*, <span class="dt">const</span> <span class="dt">int</span>*, <span class="dt">int</span>);
<span class="dt">int</span> test_bsl(bsl_variant bsl)
{
  <span class="dt">const</span> <span class="dt">int</span> data[] = { <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">11</span>, <span class="dv">11</span>, <span class="dv">11</span>, <span class="dv">20</span> };
  <span class="dt">const</span> <span class="kw">struct</span> {
    <span class="dt">int</span> b, e, x, r;
  } ts[] =
    {
      { <span class="dv">0</span>, <span class="dv">15</span>, <span class="dv">0</span>, <span class="dv">0</span> }, <span class="co">//1</span>
      { <span class="dv">0</span>, <span class="dv">15</span>, <span class="dv">1</span>, <span class="dv">3</span> }, <span class="co">//2</span>
      { <span class="dv">0</span>, <span class="dv">15</span>, <span class="dv">2</span>, <span class="dv">7</span> }, <span class="co">//3</span>
      { <span class="dv">0</span>, <span class="dv">15</span>, <span class="dv">3</span>, <span class="dv">8</span> }, <span class="co">//4</span>
      { <span class="dv">0</span>, <span class="dv">15</span>, <span class="dv">5</span>, <span class="dv">9</span> }, <span class="co">//5</span>
      { <span class="dv">0</span>, <span class="dv">15</span>, <span class="dv">4</span>, <span class="dv">9</span> }, <span class="co">//6</span>
      { <span class="dv">0</span>, <span class="dv">15</span>, <span class="dv">7</span>, <span class="dv">10</span> },  <span class="co">//7</span>
      { <span class="dv">0</span>, <span class="dv">15</span>, <span class="dv">10</span>, <span class="dv">10</span> }, <span class="co">//8</span>
      { <span class="dv">0</span>, <span class="dv">15</span>, <span class="dv">11</span>, <span class="dv">11</span> }, <span class="co">//9</span>
      { <span class="dv">0</span>, <span class="dv">15</span>, <span class="dv">20</span>, <span class="dv">14</span> }, <span class="co">//10</span>
      { <span class="dv">0</span>, <span class="dv">15</span>, <span class="dv">25</span>, <span class="dv">15</span> }, <span class="co">//11</span>
      { <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">0</span> }, <span class="co">//12</span>
      { <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span> },  <span class="co">//13</span>
      { <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">1</span> }, <span class="co">//14</span>
      { <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span> },  <span class="co">//15</span>
      { <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">0</span> },  <span class="co">//16</span>
      { <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">3</span> },  <span class="co">//17</span>
      { <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">0</span> },  <span class="co">//18</span>
      { <span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">4</span> },  <span class="co">//19</span>
      { <span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">3</span> },  <span class="co">//20</span>
      { <span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">0</span>, <span class="dv">0</span> },  <span class="co">//21</span>
      { <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">5</span> },  <span class="co">//22</span>
      { <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">3</span> },  <span class="co">//23</span>
      { <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">1</span> },  <span class="co">//24</span>
      { <span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">2</span>, <span class="dv">6</span> },  <span class="co">//25</span>
      { <span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">1</span>, <span class="dv">3</span> },  <span class="co">//26</span>
      { <span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">0</span>, <span class="dv">2</span> },  <span class="co">//27</span>
      { <span class="dv">13</span>, <span class="dv">15</span>, <span class="dv">15</span>, <span class="dv">14</span> } <span class="co">//28</span>
    };
  <span class="dt">int</span> test = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="kw">auto</span> &amp;t : ts)
  {
    ++test;
    <span class="kw">if</span> (bsl(data + t.b, data + t.e, t.x) - data != t.r)
      <span class="kw">return</span> test;
  }

  <span class="kw">return</span> <span class="dv">0</span>;
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>

<span class="dt">void</span> report(<span class="dt">int</span> test_result, <span class="dt">const</span> <span class="dt">char</span>* msg)
{
  <span class="kw">if</span> (test_result)
    std::cout &lt;&lt; msg &lt;&lt; <span class="st">": "</span> &lt;&lt; test_result &lt;&lt; std::endl;
}

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;

  cout &lt;&lt; <span class="st">"Testing factorial variants:</span><span class="ch">\n</span><span class="st">"</span>;
  {
    <span class="dt">const</span> <span class="kw">struct</span> {
      fact_variant fact;
      <span class="dt">const</span> <span class="dt">char</span> *name;
    } vs[] =
      {
        { rec_fact, <span class="st">"rec"</span> },
        { tcr_fact_caller, <span class="st">"tcr"</span> },
        { itr_fact_0, <span class="st">"itr0"</span> },
        { itr_fact, <span class="st">"itr"</span> }
      };
    <span class="kw">for</span> (<span class="kw">auto</span> &amp;v : vs)
      report(test_fact(v.fact), v.name);
  }
  
  cout &lt;&lt; <span class="st">"done.</span><span class="ch">\n</span><span class="st">Testing fib variants:</span><span class="ch">\n</span><span class="st">"</span>;
  {
    <span class="dt">const</span> <span class="kw">struct</span> {
      fib_variant fib;
      <span class="dt">const</span> <span class="dt">char</span> *name;
    } vs[] =
      {
        { rec_fib, <span class="st">"rec"</span> },
        { tcr_fib_caller, <span class="st">"tcr"</span> },
        { itr_fib_0, <span class="st">"itr0"</span> },
        { itr_fib, <span class="st">"itr"</span> }
      };
    <span class="kw">for</span> (<span class="kw">auto</span> &amp;v : vs)
      report(test_fib(v.fib), v.name);
  }

  cout &lt;&lt; <span class="st">"done.</span><span class="ch">\n</span><span class="st">Testing binary search variants:</span><span class="ch">\n</span><span class="st">"</span>;
  {
    <span class="dt">const</span> <span class="kw">struct</span> {
      bsl_variant bsl;
      <span class="dt">const</span> <span class="dt">char</span> *name;
    } vs[] =
      {
        { rec_bsl, <span class="st">"rec"</span> },
        { itr_bsl, <span class="st">"itr"</span> }
      };
    <span class="kw">for</span> (<span class="kw">auto</span> &amp;v : vs)
      report(test_bsl(v.bsl), v.name);
  }

  cout &lt;&lt; <span class="st">"done."</span> &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="memoized_fib.cpp">0755-memoized_fib.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// memoized_fib.cpp</span>
<span class="co">// Результат применения техники мемоизации к рекурсивной функции,</span>
<span class="co">// вычисляющей числа Фибоначчи "по определению".</span>
<span class="co">// Мемоизация заключается в запоминании вычисленных значений функции</span>
<span class="co">// и извлечении их при повторном вызове функции с теми же параметрами.</span>
<span class="co">// В данном случае мемоизация позволяет "линеаризовать" вычисление --</span>
<span class="co">// вместо экспоненциального по номеру числа времени требуется линейное</span>
<span class="co">// (или постоянное при повторных вызовах).</span>
<span class="ot">#include &lt;cmath&gt; </span><span class="co">// HUGE_VAL</span>

<span class="dt">double</span> fib(<span class="dt">unsigned</span> n)
{
  <span class="co">// Хранилище вычисленных значений -- достаточно 1500 элементов,</span>
  <span class="co">// так как в диапазон IEEE-754 double precision не вписываются числа Фибоначчи за номером 1500 и более.</span>
  <span class="co">// В общем случае мемоизации могут понадобиться сложные структуры данных,</span>
  <span class="co">// оперирующие динамической памятью.</span>
  <span class="dt">static</span> <span class="dt">const</span> <span class="dt">unsigned</span> N = <span class="dv">1500</span>;
  <span class="dt">static</span> <span class="dt">double</span> value[N] = { <span class="fl">0.</span>, <span class="fl">1.</span> };
  <span class="co">// Признак того, что значение уже вычисленно и надо извлечь его из таблицы value.</span>
  <span class="dt">static</span> <span class="dt">bool</span> stored[N] = { <span class="kw">true</span>, <span class="kw">true</span> };

  <span class="kw">if</span> (N &lt;= n)
    <span class="kw">return</span> HUGE_VAL;
  
  <span class="kw">if</span> (stored[n]) <span class="co">// уже посчитано?</span>
    <span class="kw">return</span> value[n]; <span class="co">// да -- вернуть сохранённое</span>
  <span class="co">// ещё не посчитано -- посчитать по определению, сохранить и вернуть:</span>
  stored[n] = <span class="kw">true</span>;
  <span class="kw">return</span> value[n] = fib(n - <span class="dv">1</span>) + fib(n - <span class="dv">2</span>);
}


<span class="ot">#include &lt;iostream&gt;</span>
<span class="dt">int</span> main()
{
  <span class="kw">for</span> (<span class="dt">unsigned</span> n; std::cin &gt;&gt; n;)
    std::cout &lt;&lt; fib(n) &lt;&lt; std::endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="memoized_fib_thread_local.cpp">0756-memoized_fib_thread_local.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// memoized_fib_thread_local.cpp</span>
<span class="co">// Пример использования хранилища потока (ключевого слова thread_local) для</span>
<span class="co">// реализации потокобезопасной (thread-safe) версии memoized_fib.</span>
<span class="co">// Т.е. fib из этого примера можно без проблем выполнять одновременно из разных нитей (threads) исполнения.</span>
<span class="ot">#include &lt;cmath&gt; </span><span class="co">// HUGE_VAL</span>

<span class="dt">double</span> fib(<span class="dt">unsigned</span> n)
{
  <span class="dt">static</span> <span class="dt">const</span> <span class="dt">unsigned</span> N = <span class="dv">1500</span>;
  <span class="dt">thread_local</span> <span class="dt">static</span> <span class="dt">double</span> value[N] = { <span class="fl">0.</span>, <span class="fl">1.</span> };
  <span class="dt">thread_local</span> <span class="dt">static</span> <span class="dt">bool</span> stored[N] = { <span class="kw">true</span>, <span class="kw">true</span> };

  <span class="kw">if</span> (N &lt;= n)
    <span class="kw">return</span> HUGE_VAL;
  
  <span class="kw">if</span> (stored[n])
    <span class="kw">return</span> value[n];

  stored[n] = <span class="kw">true</span>;
  <span class="kw">return</span> value[n] = fib(n - <span class="dv">1</span>) + fib(n - <span class="dv">2</span>);
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Проверочный код.</span>

<span class="co">// Вариант fib, не использующий глобальную память.</span>
<span class="co">// Используется для тестирования варианта fib, приведённого выше.</span>
<span class="dt">double</span> reference_fib(<span class="dt">unsigned</span> n)
{
  <span class="dt">double</span> a = <span class="fl">0.</span>, b = <span class="fl">1.</span>;
  <span class="kw">while</span> (n--)
  {
    <span class="dt">const</span> <span class="kw">auto</span> sum = a + b;
    a = b;
    b = sum;
  }
  <span class="kw">return</span> a;
}

<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;thread&gt;</span>
<span class="ot">#include &lt;random&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main()
{
  <span class="dt">void</span> thread_body(<span class="dt">unsigned</span>);
  <span class="co">// Создать три нити исполнения, которые будут вычислять разные значения fib</span>
  <span class="co">// и сравнивать с результатом reference_fib.</span>
  thread a(thread_body, <span class="dv">1</span>), b(thread_body, <span class="dv">2</span>), c(thread_body, <span class="dv">3</span>);
  <span class="co">// Дождаться завершения вычислений.</span>
  a.join();
  b.join();
  c.join();
  <span class="co">// Задержка экрана.</span>
  cin.ignore();
  <span class="kw">return</span> EXIT_SUCCESS;
}

<span class="co">// Код, выполняемый параллельно.</span>
<span class="dt">void</span> thread_body(<span class="dt">unsigned</span> tid)
{
  random_device seed_gen; <span class="co">// генератор случайного зерна</span>
  mt19937_64 rng(seed_gen() + tid); <span class="co">// генератор псевдослучайных целых чисел</span>
  uniform_int_distribution&lt;&gt; ud(<span class="dv">0</span>, <span class="dv">1501</span>); <span class="co">// генератор равномерно распределённых в [0, 1501] целых чисел</span>
  <span class="kw">for</span> (<span class="dt">int</span> rounds = <span class="dv">1000</span>; rounds--;)
  {
    <span class="dt">const</span> <span class="kw">auto</span> n = ud(rng); <span class="co">// следующий псевдослучайный аргумент fib</span>
    <span class="kw">if</span> (fib(n) != reference_fib(n)) <span class="co">// проверить корректность вычисления</span>
      <span class="kw">return</span> (<span class="dt">void</span>)cout.put(<span class="st">'0'</span>); <span class="co">// ошибка</span>
  }

  cout.put(<span class="st">'1'</span>); <span class="co">// все раунды успешны</span>
}</code></pre></div>
<p><br>
</p>
<h1 id="prefix_calc.cpp">0760-prefix_calc.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// prefix_calc.cpp</span>
<span class="co">// Рекурсивная реализация калькулятора с поддержкой четырёх арифметических действий,</span>
<span class="co">// принимающего выражения в префиксной записи (она же "польская нотация").</span>
<span class="co">// Грамматика выражения: операция операнд операнд, где операнд может быть числом или опять выражением</span>
<span class="co">// Например, + * 2 3 4 ==&gt; (2 * 3) + 4 == 10</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstring&gt; </span><span class="co">// strchr</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Читает выражение с cin, возвращает вычисленное значение выражения.</span>
<span class="dt">double</span> prefix()
{
  <span class="co">// Выражение?</span>
  <span class="dt">char</span> op;
  <span class="kw">if</span> (cin &gt;&gt; op)
  {
    <span class="co">// Считали знак операции?</span>
    <span class="kw">if</span> (strchr(<span class="st">"+-*/"</span>, op)) 
    {
      <span class="co">// Вычислить операнды.</span>
      <span class="dt">double</span> x = prefix(), y = prefix();
      <span class="co">// Вычислить результат выполнения операции.</span>
      <span class="kw">switch</span> (op)
      {
      <span class="kw">case</span> <span class="st">'+'</span>: <span class="kw">return</span> x + y;
      <span class="kw">case</span> <span class="st">'-'</span>: <span class="kw">return</span> x - y;
      <span class="kw">case</span> <span class="st">'*'</span>: <span class="kw">return</span> x * y;
      <span class="kw">case</span> <span class="st">'/'</span>: <span class="kw">return</span> x / y;
      }
    }
    <span class="kw">else</span> <span class="co">// не знак операции -- вернуть считанный символ</span>
      cin.unget();
  }

  <span class="co">// Число?</span>
  <span class="dt">double</span> value;
  <span class="kw">if</span> (cin &gt;&gt; value)
    <span class="kw">return</span> value;

  <span class="co">// Ошибка ввода.</span>
  cerr &lt;&lt; <span class="st">"input error</span><span class="ch">\n</span><span class="st">"</span>;
  <span class="kw">return</span> <span class="fl">0.</span>;
}


<span class="dt">int</span> main()
{
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="dt">double</span> answer = prefix();
    <span class="co">// Сброс потока ввода.</span>
    cin.clear();
    cin.ignore(cin.rdbuf()-&gt;in_avail());
    cin.sync();
    <span class="co">// Вывод ответа.</span>
    cout &lt;&lt; <span class="st">"answer = "</span> &lt;&lt; answer &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="postfix_calc.cpp">0770-postfix_calc.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// postfix_calc.cpp</span>
<span class="co">// Рекурсивная реализация калькулятора с поддержкой четырёх арифметических действий,</span>
<span class="co">// принимающего выражения в постфиксной записи (она же "обратная польская нотация").</span>
<span class="co">// Грамматика выражения: операнд операнд операция, где операнд может быть числом или опять выражением</span>
<span class="co">// Например, 4 3 2 * + ==&gt; 4 + (3 * 2) == 10</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Читает выражение из потока cin, возвращает вычисленное значение.</span>
<span class="co">// Для того, чтобы суметь выполнить прочитанную операцию, надо получить уже ранее прочитанные операнды.</span>
<span class="co">// Эти операнды передадим через параметры x (первый операнд), y (второй операнд).</span>
<span class="dt">double</span> postfix(<span class="dt">double</span> x = <span class="fl">0.</span>, <span class="dt">double</span> y = <span class="fl">0.</span>)
{
  <span class="co">// Операция?</span>
  <span class="dt">char</span> op;
  <span class="kw">if</span> (cin &gt;&gt; op)
  {
    <span class="kw">switch</span> (op)
    {
      <span class="co">// Вычислить значение выражения (операнды уже известны -- x, y) и вернуть результат.</span>
    <span class="kw">case</span> <span class="st">'+'</span>: <span class="kw">return</span> x + y;
    <span class="kw">case</span> <span class="st">'-'</span>: <span class="kw">return</span> x - y;
    <span class="kw">case</span> <span class="st">'*'</span>: <span class="kw">return</span> x * y;
    <span class="kw">case</span> <span class="st">'/'</span>: <span class="kw">return</span> x / y;
      <span class="co">// Не операция? вернуть считанный символ в поток.</span>
    <span class="kw">default</span>: cin.unget();
    }
  }

  <span class="co">// Число?</span>
  <span class="dt">double</span> z;
  <span class="kw">if</span> (cin &gt;&gt; z)
    <span class="kw">return</span> postfix(x, postfix(y, z));
  <span class="co">// Новые операнды -- y и считанное z.</span>
  <span class="co">// Но x тоже никуда не делся. После того, как будет вычислено значение над ним,</span>
  <span class="co">// может быть считана операция, которая задействует x. Отсюда второй рекурсивный вызов.</span>
  <span class="co">// Этот последний вызов является хвостовым и может быть раскрыт в цикл.</span>
  
  <span class="co">// Иначе конец ввода или ошибка, вернём последнее вычисленное значение (операнд y).</span>
  <span class="kw">return</span> y;
}


<span class="dt">int</span> main()
{
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="dt">double</span> answer = postfix();
    <span class="co">// Сброс потока.</span>
    cin.clear();
    cin.ignore(cin.rdbuf()-&gt;in_avail());
    cin.sync();
    <span class="co">// Вывод ответа.</span>
    cout &lt;&lt; <span class="st">"answer = "</span> &lt;&lt; answer &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="postfix_calc_tc.cpp">0771-postfix_calc_tc.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// postfix_calc_tc.cpp</span>
<span class="co">// Рекурсивная реализация калькулятора с поддержкой четырёх арифметических действий,</span>
<span class="co">// принимающего выражения в постфиксной записи (она же "обратная польская нотация").</span>
<span class="co">// Грамматика выражения: операнд операнд операция, где операнд может быть числом или опять выражением</span>
<span class="co">// Например, 4 3 2 * + ==&gt; 4 + (3 * 2) == 10</span>
<span class="co">// От postfix_calc.cpp отличается тем, что один из рекурсивных вызовов раскрыт в цикл.</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Читает выражение из потока cin, возвращает вычисленное значение.</span>
<span class="co">// Для того, чтобы суметь выполнить прочитанную операцию, надо получить уже ранее прочитанные операнды.</span>
<span class="co">// Эти операнды передадим через параметры x (первый операнд), y (второй операнд).</span>
<span class="dt">double</span> postfix(<span class="dt">double</span> x = <span class="fl">0.</span>, <span class="dt">double</span> y = <span class="fl">0.</span>)
{
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="co">// Операция?</span>
    <span class="dt">char</span> op;
    <span class="kw">if</span> (cin &gt;&gt; op)
    {
      <span class="kw">switch</span> (op)
      {
        <span class="co">// Вычислить значение выражения (операнды уже известны -- x, y) и вернуть результат.</span>
      <span class="kw">case</span> <span class="st">'+'</span>: <span class="kw">return</span> x + y;
      <span class="kw">case</span> <span class="st">'-'</span>: <span class="kw">return</span> x - y;
      <span class="kw">case</span> <span class="st">'*'</span>: <span class="kw">return</span> x * y;
      <span class="kw">case</span> <span class="st">'/'</span>: <span class="kw">return</span> x / y;
        <span class="co">// Не операция? вернуть считанный символ в поток.</span>
      <span class="kw">default</span>: cin.unget();
      }
    }

    <span class="co">// Число?</span>
    <span class="dt">double</span> z;
    <span class="kw">if</span> (cin &gt;&gt; z)
      y = postfix(y, z);
    <span class="kw">else</span>
      <span class="kw">return</span> y;
  }
}


<span class="dt">int</span> main()
{
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="dt">double</span> answer = postfix();
    <span class="co">// Сброс потока.</span>
    cin.clear();
    cin.ignore(cin.rdbuf()-&gt;in_avail());
    cin.sync();
    <span class="co">// Вывод ответа.</span>
    cout &lt;&lt; <span class="st">"answer = "</span> &lt;&lt; answer &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="postfix_calc_stack.cpp">0780-postfix_calc_stack.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// postfix_calc_stack.cpp</span>
<span class="co">// Реализация калькулятора с поддержкой четырёх арифметических действий,</span>
<span class="co">// принимающего выражения в постфиксной записи (она же "обратная польская нотация").</span>
<span class="co">// Грамматика выражения: операнд операнд операция, где операнд может быть числом или опять выражением</span>
<span class="co">// Например, 4 3 2 * + ==&gt; 4 + (3 * 2) == 10</span>
<span class="co">// От postfix_calc.cpp отличается тем, что вместо рекурсии и неявного использования стека вызовов</span>
<span class="co">// для хранения промежуточных результатов (операндов) используется явный стек чисел в виде</span>
<span class="co">// статического массива (размер зафиксирован в момент компиляции).</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstring&gt; </span><span class="co">// strchr</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Читает выражение из потока cin, возвращает вычисленное значение.</span>
<span class="dt">double</span> postfix()
{
  <span class="dt">static</span> <span class="dt">const</span> <span class="dt">unsigned</span> STACK_SIZE = <span class="dv">1024</span>; <span class="co">// Размер стека.</span>
  <span class="dt">double</span> operand[STACK_SIZE]; <span class="co">// Стек (на основе массива).</span>
  <span class="dt">unsigned</span> operand_top = <span class="dv">0</span>; <span class="co">/* Индекс элемента массива, </span>
<span class="co">    который станет вершиной стека при добавлении элемента. */</span>

  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="co">// Операция?</span>
    <span class="dt">char</span> op;
    <span class="kw">if</span> (cin &gt;&gt; op)
    {
      <span class="dt">double</span> z;
      <span class="kw">if</span> (strchr(<span class="st">"+-*/"</span>, op))
      {
        <span class="co">// Убедиться, что в стеке есть хотя бы два числа.</span>
        <span class="kw">if</span> (operand_top &lt; <span class="dv">2</span>)
        {
          cerr &lt;&lt; <span class="st">"stack underflow: at least 2 items are needed</span><span class="ch">\n</span><span class="st">"</span>;
          <span class="kw">break</span>;
        }

        <span class="co">// Извлечь операнды (для сокращения записи).</span>
        <span class="dt">const</span> <span class="dt">double</span>
          x = operand[operand_top - <span class="dv">2</span>],
          y = operand[operand_top - <span class="dv">1</span>];
        operand_top -= <span class="dv">2</span>;

        <span class="co">// Вычислить значение выражения (операнды уже известны -- x, y).</span>
        <span class="kw">switch</span> (op)
        {
        <span class="kw">case</span> <span class="st">'+'</span>: z = x + y; <span class="kw">break</span>;
        <span class="kw">case</span> <span class="st">'-'</span>: z = x - y; <span class="kw">break</span>;
        <span class="kw">case</span> <span class="st">'*'</span>: z = x * y; <span class="kw">break</span>;
        <span class="kw">case</span> <span class="st">'/'</span>: z = x / y; <span class="kw">break</span>;
        }

        <span class="co">// Записать новое значение в стек.</span>
        operand[operand_top++] = z;

        <span class="co">// Проверить переполнение стека.</span>
        <span class="kw">if</span> (operand_top == STACK_SIZE)
        {
          cerr &lt;&lt; <span class="st">"stack overflow</span><span class="ch">\n</span><span class="st">"</span>;
          <span class="kw">break</span>;
        }
      }
      <span class="kw">else</span> <span class="co">// Не операция? вернуть считанный символ в поток.</span>
      {
        cin.unget();
        <span class="co">// Число?</span>
        <span class="kw">if</span> (cin &gt;&gt; z)
        {
          <span class="co">// Записать новое значение в стек.</span>
          operand[operand_top++] = z;

          <span class="co">// Проверить переполнение стека.</span>
          <span class="kw">if</span> (operand_top == STACK_SIZE)
          {
            cerr &lt;&lt; <span class="st">"stack overflow</span><span class="ch">\n</span><span class="st">"</span>;
            <span class="kw">break</span>;
          }
        }
        <span class="kw">else</span> <span class="co">// Ошибка ввода.</span>
          <span class="kw">break</span>;
      }
    }
    <span class="kw">else</span> <span class="co">// Ошибка ввода.</span>
      <span class="kw">break</span>;
  }

  <span class="co">// Вернуть текущую вершину стека.</span>
  <span class="kw">if</span> (operand_top == <span class="dv">0</span>) <span class="co">// Стек пуст.</span>
  {
    cerr &lt;&lt; <span class="st">"stack underflow: at least 1 item is needed</span><span class="ch">\n</span><span class="st">"</span>;
    <span class="kw">return</span> <span class="fl">0.</span>;
  }
   
  <span class="kw">return</span> operand[operand_top - <span class="dv">1</span>];
}


<span class="dt">int</span> main()
{
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="dt">double</span> answer = postfix();
    <span class="co">// Сброс потока.</span>
    cin.clear();
    cin.ignore(cin.rdbuf()-&gt;in_avail());
    cin.sync();
    <span class="co">// Вывод ответа.</span>
    cout &lt;&lt; <span class="st">"answer = "</span> &lt;&lt; answer &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="postfix_calc_stack_std.cpp">0781-postfix_calc_stack_std.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// postfix_calc_stack_std.cpp</span>
<span class="co">// Реализация калькулятора с поддержкой четырёх арифметических действий,</span>
<span class="co">// принимающего выражения в постфиксной записи (она же "обратная польская нотация").</span>
<span class="co">// Грамматика выражения: операнд операнд операция, где операнд может быть числом или опять выражением</span>
<span class="co">// Например, 4 3 2 * + ==&gt; 4 + (3 * 2) == 10</span>
<span class="co">// От postfix_calc_stack.cpp отличается тем, что вместо статического массива (размер зафиксирован в момент компиляции)</span>
<span class="co">// для хранения промежуточных результатов (операндов) используется стек чисел на основе стандартного класса stack,</span>
<span class="co">// автоматически увеличивающийся по мере надобности (располагает данные в динамической памяти).</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstring&gt; </span><span class="co">// strchr</span>
<span class="ot">#include &lt;stack&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Читает выражение из потока cin, возвращает вычисленное значение.</span>
<span class="dt">double</span> postfix()
{
  stack&lt;<span class="dt">double</span>&gt; operands; <span class="co">// Стек операндов.</span>
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="co">// Операция?</span>
    <span class="dt">char</span> op;
    <span class="kw">if</span> (cin &gt;&gt; op)
    {
      <span class="dt">double</span> x, y, z;
      <span class="kw">if</span> (strchr(<span class="st">"+-*/"</span>, op))
      {
        <span class="co">// Извлечь операнды, проверяя их наличие.</span>
        <span class="kw">if</span> (operands.empty())
          <span class="kw">goto</span> Stack_underflow_error;
        y = operands.top();
        operands.pop();

        <span class="kw">if</span> (operands.empty())
          <span class="kw">goto</span> Stack_underflow_error;
        x = operands.top();
        operands.pop();

        <span class="co">// Вычислить значение выражения (операнды уже известны -- x, y).</span>
        <span class="kw">switch</span> (op)
        {
        <span class="kw">case</span> <span class="st">'+'</span>: z = x + y; <span class="kw">break</span>;
        <span class="kw">case</span> <span class="st">'-'</span>: z = x - y; <span class="kw">break</span>;
        <span class="kw">case</span> <span class="st">'*'</span>: z = x * y; <span class="kw">break</span>;
        <span class="kw">case</span> <span class="st">'/'</span>: z = x / y; <span class="kw">break</span>;
        }

        <span class="co">// Записать новое значение в стек.</span>
        operands.push(z);
      }
      <span class="kw">else</span> <span class="co">// Не операция? вернуть считанный символ в поток.</span>
      {
        cin.unget();
        <span class="co">// Число?</span>
        <span class="kw">if</span> (cin &gt;&gt; z)
          operands.push(z);
        <span class="kw">else</span> <span class="co">// Ошибка ввода.</span>
          <span class="kw">break</span>;
      }
    }
    <span class="kw">else</span> <span class="co">// Ошибка ввода.</span>
      <span class="kw">break</span>;
  }

  <span class="co">// Вернуть текущую вершину стека.</span>
  <span class="kw">if</span> (operands.empty()) <span class="co">// Стек пуст.</span>
  {
Stack_underflow_error:
    cerr &lt;&lt; <span class="st">"stack underflow</span><span class="ch">\n</span><span class="st">"</span>;
    <span class="kw">return</span> <span class="fl">0.</span>;
  }
   
  <span class="kw">return</span> operands.top();
}


<span class="dt">int</span> main()
{
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="dt">double</span> answer = postfix();
    <span class="co">// Сброс потока.</span>
    cin.clear();
    cin.ignore(cin.rdbuf()-&gt;in_avail());
    cin.sync();
    <span class="co">// Вывод ответа.</span>
    cout &lt;&lt; <span class="st">"answer = "</span> &lt;&lt; answer &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="prefix_calc_stack_std.cpp">0790-prefix_calc_stack_std.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// prefix_calc_stack_std.cpp</span>
<span class="co">// Реализация калькулятора с поддержкой четырёх арифметических действий,</span>
<span class="co">// принимающего выражения в префиксной записи (она же "польская нотация").</span>
<span class="co">// Грамматика выражения: операция операнд операнд, где операнд может быть числом или опять выражением</span>
<span class="co">// Например, + * 2 3 4 ==&gt; (2 * 3) + 4 == 10</span>
<span class="co">// Для хранения промежуточных данных используются стеки на основе стандартного класса stack.</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstring&gt; </span><span class="co">// strchr</span>
<span class="ot">#include &lt;stack&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Читает выражение с cin, возвращает вычисленное значение выражения.</span>
<span class="dt">double</span> prefix()
{
  stack&lt;<span class="dt">char</span>&gt; ops;   <span class="co">// Стек отложенных значений op.</span>
  stack&lt;<span class="dt">double</span>&gt; xs;  <span class="co">// Стек отложенных значений x.</span>
  stack&lt;<span class="dt">bool</span>&gt; has_x; <span class="co">// Стек признака "операция уже имеет первый операнд в стеке xs".</span>

  <span class="dt">double</span> y = <span class="fl">0.</span>; <span class="co">// Второй операнд.</span>
  <span class="kw">do</span>
  {
    <span class="dt">char</span> op;
    <span class="kw">if</span> (cin &gt;&gt; op)
    {
      <span class="kw">if</span> (strchr(<span class="st">"+-*/"</span>, op)) <span class="co">// Считали знак операции.</span>
      {
        ops.push(op);
        has_x.push(<span class="kw">false</span>); <span class="co">// Новая операция -- ещё нет ни одного операнда.</span>
      }
      <span class="kw">else</span> <span class="co">// не знак операции -- вернуть считанный символ и прочитать число</span>
      {
        cin.unget();
        <span class="kw">if</span> (cin &gt;&gt; y) <span class="co">// Считали число.</span>
        {
          <span class="co">// Можно выполнить "свёртку" операций, для которых есть первый операнд.</span>
          <span class="kw">while</span> (!ops.empty() &amp;&amp; has_x.top())
          {
            <span class="co">// Извлечь из стека первый аргумент операции.</span>
            <span class="dt">const</span> <span class="kw">auto</span> x = xs.top();
            xs.pop();

            <span class="kw">switch</span> (ops.top())
            {
            <span class="kw">case</span> <span class="st">'+'</span>: y = x + y; <span class="kw">break</span>;
            <span class="kw">case</span> <span class="st">'-'</span>: y = x - y; <span class="kw">break</span>;
            <span class="kw">case</span> <span class="st">'*'</span>: y = x * y; <span class="kw">break</span>;
            <span class="kw">case</span> <span class="st">'/'</span>: y = x / y; <span class="kw">break</span>;
            }
            <span class="co">// Убрать вычисленную операцию.</span>
            ops.pop();
            has_x.pop();
          }

          <span class="co">// Получили первый операнд некоторой операции?</span>
          <span class="kw">if</span> (!ops.empty())
          {
            has_x.top() = <span class="kw">true</span>;
            xs.push(y);
          }
        }
      }
    }
    <span class="kw">else</span>
    {
      <span class="co">// Ошибка ввода.</span>
      cerr &lt;&lt; <span class="st">"input error</span><span class="ch">\n</span><span class="st">"</span>;
      <span class="kw">break</span>;
    }
  } <span class="kw">while</span> (!ops.empty()); <span class="co">// Продолжать, пока есть ещё операции.</span>
  <span class="kw">return</span> y;
}


<span class="dt">int</span> main()
{
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="dt">double</span> answer = prefix();
    <span class="co">// Сброс потока ввода.</span>
    cin.clear();
    cin.ignore(cin.rdbuf()-&gt;in_avail());
    cin.sync();
    <span class="co">// Вывод ответа.</span>
    cout &lt;&lt; <span class="st">"answer = "</span> &lt;&lt; answer &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="infix_calc.cpp">0800-infix_calc.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// infix_calc.cpp</span>
<span class="co">// Инфиксный калькулятор без учёта приоритетов операций и без поддержки скобок.</span>
<span class="co">// Пример: 2+2*2 ==&gt; 8 (выполняет операции подряд).</span>
<span class="co">// Рекурсивная реализация.</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Читает из потока cin, возвращает значение выражения.</span>
<span class="dt">double</span> infix(<span class="dt">double</span> x)
{
  <span class="dt">char</span> op;
  <span class="kw">if</span> (cin &gt;&gt; op)
  {
    <span class="dt">double</span> y;
    <span class="kw">if</span> (cin &gt;&gt; y)
    {
      <span class="kw">switch</span> (op)
      {
      <span class="kw">case</span> <span class="st">'+'</span>: <span class="kw">return</span> infix(x + y);
      <span class="kw">case</span> <span class="st">'-'</span>: <span class="kw">return</span> infix(x - y);
      <span class="kw">case</span> <span class="st">'*'</span>: <span class="kw">return</span> infix(x * y);
      <span class="kw">case</span> <span class="st">'/'</span>: <span class="kw">return</span> infix(x / y);
      <span class="kw">default</span>:
        cerr &lt;&lt; <span class="st">"unknown operation '"</span> &lt;&lt; op &lt;&lt; <span class="st">"'</span><span class="ch">\n</span><span class="st">"</span>;
        <span class="kw">return</span> x;
      }
    }
    <span class="kw">else</span>
      cerr &lt;&lt; <span class="st">"number expected</span><span class="ch">\n</span><span class="st">"</span>;
  }
  
  <span class="kw">return</span> x;
}

<span class="dt">double</span> infix()
{
  <span class="dt">double</span> x;
  <span class="kw">if</span> (cin &gt;&gt; x)
    <span class="kw">return</span> infix(x);

  cerr &lt;&lt; <span class="st">"number expected</span><span class="ch">\n</span><span class="st">"</span>;
  <span class="kw">return</span> <span class="fl">0.</span>;
}


<span class="dt">int</span> main()
{
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="dt">double</span> answer = infix();
    cin.clear();
    cin.ignore(cin.rdbuf()-&gt;in_avail());
    cin.sync();
    cout &lt;&lt; <span class="st">"answer = "</span> &lt;&lt; answer &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="infix_calc_tc.cpp">0801-infix_calc_tc.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// infix_calc_tc.cpp</span>
<span class="co">// Инфиксный калькулятор без учёта приоритетов операций и без поддержки скобок.</span>
<span class="co">// Пример: 2+2*2 ==&gt; 8 (выполняет операции подряд).</span>
<span class="co">// Получен из infix_calc.cpp путём замены рекурсии на итерацию</span>
<span class="co">// (нетрудно заметить, что в рекурсивном варианте только хвостовые вызовы).</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Читает из потока cin, возвращает значение выражения.</span>
<span class="dt">double</span> infix(<span class="dt">double</span> x)
{
  <span class="dt">char</span> op;
  <span class="kw">while</span> (cin &gt;&gt; op)
  {
    <span class="dt">double</span> y;
    <span class="kw">if</span> (cin &gt;&gt; y)
    {
      <span class="kw">switch</span> (op)
      {
      <span class="kw">case</span> <span class="st">'+'</span>: x = x + y; <span class="kw">break</span>;
      <span class="kw">case</span> <span class="st">'-'</span>: x = x - y; <span class="kw">break</span>;
      <span class="kw">case</span> <span class="st">'*'</span>: x = x * y; <span class="kw">break</span>;
      <span class="kw">case</span> <span class="st">'/'</span>: x = x / y; <span class="kw">break</span>;
      <span class="kw">default</span>:
        cerr &lt;&lt; <span class="st">"unknown operation '"</span> &lt;&lt; op &lt;&lt; <span class="st">"'</span><span class="ch">\n</span><span class="st">"</span>;
        <span class="kw">return</span> x;
      }
    }
    <span class="kw">else</span>
      cerr &lt;&lt; <span class="st">"number expected</span><span class="ch">\n</span><span class="st">"</span>;
  }
  
  <span class="kw">return</span> x;
}

<span class="dt">double</span> infix()
{
  <span class="dt">double</span> x;
  <span class="kw">if</span> (cin &gt;&gt; x)
    <span class="kw">return</span> infix(x);

  cerr &lt;&lt; <span class="st">"number expected</span><span class="ch">\n</span><span class="st">"</span>;
  <span class="kw">return</span> <span class="fl">0.</span>;
}


<span class="dt">int</span> main()
{
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="dt">double</span> answer = infix();
    cin.clear();
    cin.ignore(cin.rdbuf()-&gt;in_avail());
    cin.sync();
    cout &lt;&lt; <span class="st">"answer = "</span> &lt;&lt; answer &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="infix_calc_tc_2.cpp">0802-infix_calc_tc_2.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// infix_calc_tc_2.cpp</span>
<span class="co">// Инфиксный калькулятор без учёта приоритетов операций и без поддержки скобок.</span>
<span class="co">// Пример: 2+2*2 ==&gt; 8 (выполняет операции подряд).</span>
<span class="co">// Получен из infix_calc_tc.cpp слиянием двух функций infix в одну</span>
<span class="co">// (без рекурсии два варианта уже не нужны).</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Читает из потока cin, возвращает значение выражения.</span>
<span class="dt">double</span> infix()
{
  <span class="dt">double</span> x;
  <span class="kw">if</span> (!(cin &gt;&gt; x))
  {
    cerr &lt;&lt; <span class="st">"number expected</span><span class="ch">\n</span><span class="st">"</span>;
    <span class="kw">return</span> <span class="fl">0.</span>;
  }

  <span class="kw">for</span> (<span class="dt">char</span> op; cin &gt;&gt; op;)
  {
    <span class="dt">double</span> y;
    <span class="kw">if</span> (cin &gt;&gt; y)
    {
      <span class="kw">switch</span> (op)
      {
      <span class="kw">case</span> <span class="st">'+'</span>: x = x + y; <span class="kw">break</span>;
      <span class="kw">case</span> <span class="st">'-'</span>: x = x - y; <span class="kw">break</span>;
      <span class="kw">case</span> <span class="st">'*'</span>: x = x * y; <span class="kw">break</span>;
      <span class="kw">case</span> <span class="st">'/'</span>: x = x / y; <span class="kw">break</span>;
      <span class="kw">default</span>:
        cerr &lt;&lt; <span class="st">"unknown operation '"</span> &lt;&lt; op &lt;&lt; <span class="st">"'</span><span class="ch">\n</span><span class="st">"</span>;
        <span class="kw">return</span> x;
      }
    }
    <span class="kw">else</span>
      cerr &lt;&lt; <span class="st">"number expected</span><span class="ch">\n</span><span class="st">"</span>;
  }
  
  <span class="kw">return</span> x;
}


<span class="dt">int</span> main()
{
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="dt">double</span> answer = infix();
    cin.clear();
    cin.ignore(cin.rdbuf()-&gt;in_avail());
    cin.sync();
    cout &lt;&lt; <span class="st">"answer = "</span> &lt;&lt; answer &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="infix_calc_p.cpp">0810-infix_calc_p.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// infix_calc_p.cpp</span>
<span class="co">// Инфиксный калькулятор без учёта приоритетов операций, но с поддержкой скобок.</span>
<span class="co">// Пример: 2+(2*2) ==&gt; 6.</span>
<span class="co">// Грамматика:</span>
<span class="co">//  Терм --&gt; Число | '(' Выражение ')'    // term</span>
<span class="co">//  Выражение --&gt; Терм { Операция Терм }  // infix</span>
<span class="co">// Рекурсивная реализация на основе грамматики.</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Вспомогательная функция: </span>
<span class="co">// посмотреть следующий непробельный символ в потоке cin, не извлекая его.</span>
<span class="co">// (Пробельные символы пропускаются. Возвращает EOF если поток закончился.)</span>
<span class="dt">char</span> peek()
{
  <span class="dt">char</span> ch = EOF;
  <span class="kw">if</span> (cin &gt;&gt; ch)
    cin.unget();
  <span class="kw">return</span> ch;
}

<span class="co">// Вспомогательная функция для установки ошибки.</span>
<span class="dt">void</span> error(<span class="dt">const</span> <span class="dt">char</span> *message)
{
  cerr &lt;&lt; message;
  cin.setstate(ios::failbit);
}


<span class="dt">double</span> infix();
<span class="co">// Терм --&gt; Число | '(' Выражение ')'</span>
<span class="dt">double</span> term()
{
  <span class="dt">double</span> result = <span class="fl">0.</span>;
  <span class="kw">switch</span> (peek()) <span class="co">// Ожидается число или открывающая скобка.</span>
  {
  <span class="kw">case</span> <span class="st">'-'</span>: <span class="kw">case</span> <span class="st">'+'</span>: <span class="kw">case</span> <span class="st">'.'</span>:
  <span class="kw">case</span> <span class="st">'0'</span>: <span class="kw">case</span> <span class="st">'1'</span>: <span class="kw">case</span> <span class="st">'2'</span>: <span class="kw">case</span> <span class="st">'3'</span>: <span class="kw">case</span> <span class="st">'4'</span>:
  <span class="kw">case</span> <span class="st">'5'</span>: <span class="kw">case</span> <span class="st">'6'</span>: <span class="kw">case</span> <span class="st">'7'</span>: <span class="kw">case</span> <span class="st">'8'</span>: <span class="kw">case</span> <span class="st">'9'</span>:
    <span class="kw">if</span> (!(cin &gt;&gt; result))
      error(<span class="st">"number expected</span><span class="ch">\n</span><span class="st">"</span>);
    <span class="kw">return</span> result;
    
  <span class="kw">case</span> <span class="st">'('</span>:
    cin.ignore(); <span class="co">// Пропустить '('.</span>
    result = infix();
    <span class="kw">if</span> (peek() != <span class="st">')'</span>)
      error(<span class="st">"unmatched '(' found</span><span class="ch">\n</span><span class="st">"</span>);
    <span class="kw">else</span>
      cin.ignore(); <span class="co">// Пропустить ')'.</span>
    <span class="kw">return</span> result;

  <span class="kw">case</span> <span class="st">')'</span>:
    error(<span class="st">"unmatched ')' found</span><span class="ch">\n</span><span class="st">"</span>);
    <span class="kw">return</span> <span class="fl">0.</span>;

  <span class="kw">default</span>:
    error(<span class="st">"term expected, '"</span>);
    cerr &lt;&lt; peek() &lt;&lt; <span class="st">"' found</span><span class="ch">\n</span><span class="st">"</span>;
    <span class="kw">return</span> <span class="fl">0.</span>;
  }
}

<span class="co">// Выражение --&gt; Терм { Операция Терм }</span>
<span class="dt">double</span> infix()
{
  <span class="dt">double</span> x = term(), y = <span class="fl">0.</span>;
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="kw">switch</span> (<span class="dt">char</span> op = peek()) <span class="co">// Ожидается операция.</span>
    {
    <span class="kw">case</span> <span class="st">'+'</span>: <span class="kw">case</span> <span class="st">'-'</span>: <span class="kw">case</span> <span class="st">'*'</span>: <span class="kw">case</span> <span class="st">'/'</span>:
      cin.ignore();
      y = term(); <span class="co">// Получить второй операнд.</span>
      <span class="kw">if</span> (!cin)
      {
        error(<span class="st">"no second argument for operation '"</span>);
        cerr &lt;&lt; op &lt;&lt; <span class="st">"'</span><span class="ch">\n</span><span class="st">"</span>;
        <span class="kw">return</span> x;
      }

      <span class="kw">switch</span> (op) <span class="co">// Вычислить результат операции.</span>
      {
      <span class="kw">case</span> <span class="st">'+'</span>: x = x + y; <span class="kw">break</span>;
      <span class="kw">case</span> <span class="st">'-'</span>: x = x - y; <span class="kw">break</span>;
      <span class="kw">case</span> <span class="st">'*'</span>: x = x * y; <span class="kw">break</span>;
      <span class="kw">case</span> <span class="st">'/'</span>: x = x / y; <span class="kw">break</span>;
      }
      <span class="kw">break</span>;

    <span class="kw">case</span> <span class="st">')'</span>: <span class="kw">case</span> EOF:
      <span class="kw">return</span> x;

    <span class="kw">default</span>:
      error(<span class="st">"unknown operation: '"</span>);
      cerr &lt;&lt; op &lt;&lt; <span class="st">"'</span><span class="ch">\n</span><span class="st">"</span>;
      <span class="kw">return</span> x;
    }
  }
}


<span class="dt">int</span> main()
{
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="dt">double</span> answer = infix();
    cin.clear();
    cin.ignore(cin.rdbuf()-&gt;in_avail());
    cin.sync();
    cout &lt;&lt; <span class="st">"answer = "</span> &lt;&lt; answer &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="infix_calc_p_stack_std.cpp">0820-infix_calc_p_stack_std.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// infix_calc_p_stack.cpp</span>
<span class="co">// Инфиксный калькулятор без учёта приоритетов операций, но с поддержкой скобок.</span>
<span class="co">// Пример: 2+(2*2) ==&gt; 6.</span>
<span class="co">// Грамматика:</span>
<span class="co">//  Терм --&gt; Число | '(' Выражение ')'    // term</span>
<span class="co">//  Выражение --&gt; Терм { Операция Терм }  // infix</span>
<span class="co">// Конверсия рекурсивного варианта infix_calc_p.cpp в вариант с использованием стека.</span>
<span class="co">// Добавлены операции взятия остатка (реализована через std::fmod) и</span>
<span class="co">// возведения в степень (реализована через std::pow) -- символы '%' и '^'.</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>
<span class="ot">#include &lt;stack&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Вспомогательная функция: </span>
<span class="co">// посмотреть следующий непробельный символ в потоке cin, не извлекая его.</span>
<span class="co">// (Пробельные символы пропускаются. Возвращает EOF если поток закончился.)</span>
<span class="dt">char</span> peek()
{
  <span class="dt">char</span> ch = EOF;
  <span class="kw">if</span> (cin &gt;&gt; ch)
    cin.unget();
  <span class="kw">return</span> ch;
}

<span class="co">// Вспомогательная функция для установки ошибки.</span>
<span class="dt">void</span> error(<span class="dt">const</span> <span class="dt">char</span> *message)
{
  cerr &lt;&lt; message;
  cin.setstate(ios::failbit);
}


<span class="dt">double</span> infix()
{
  stack&lt;<span class="dt">char</span>&gt; ops;  <span class="co">// Стек операций.</span>
  stack&lt;<span class="dt">double</span>&gt; xs; <span class="co">// Стек операндов.</span>

  <span class="co">// Вложенная функция, выполняющая операцию на вершине стека ops.</span>
  <span class="co">// Возвращает "успех" (false если произошла ошибка, true если выполнено успешно).</span>
  <span class="kw">auto</span> do_next_op = [&amp;]() -&gt; <span class="dt">bool</span>
  {
    <span class="dt">double</span> x, y;
    <span class="kw">if</span> (xs.empty())
    {
      error(<span class="st">"not enough operands</span><span class="ch">\n</span><span class="st">"</span>);
      <span class="kw">return</span> <span class="kw">false</span>;
    }

    y = xs.top();
    xs.pop();

    <span class="kw">if</span> (xs.empty())
    {
      xs.push(y);
      error(<span class="st">"not enough operands</span><span class="ch">\n</span><span class="st">"</span>);
      <span class="kw">return</span> <span class="kw">false</span>;
    }

    x = xs.top();

    <span class="kw">switch</span> (ops.top())
    {
    <span class="kw">case</span> <span class="st">'+'</span>: x = x + y; <span class="kw">break</span>;
    <span class="kw">case</span> <span class="st">'-'</span>: x = x - y; <span class="kw">break</span>;
    <span class="kw">case</span> <span class="st">'*'</span>: x = x * y; <span class="kw">break</span>;
    <span class="kw">case</span> <span class="st">'/'</span>: x = x / y; <span class="kw">break</span>;
    <span class="kw">case</span> <span class="st">'%'</span>: x = fmod(x, y); <span class="kw">break</span>;
    <span class="kw">case</span> <span class="st">'^'</span>: x = pow(x, y); <span class="kw">break</span>;
    <span class="kw">default</span>:
      error(<span class="st">"internal error</span><span class="ch">\n</span><span class="st">"</span>);
      <span class="kw">return</span> <span class="kw">false</span>;
    }

    <span class="co">// Сохранить результат операции вместо операндов на стеке xs.</span>
    xs.top() = x;
    <span class="co">// Убрать со стека операций выполненную операцию.</span>
    ops.pop();
    <span class="kw">return</span> <span class="kw">true</span>;
  };


  <span class="dt">bool</span> awaiting_term = <span class="kw">true</span>; <span class="co">// Ожидает терм (true) или операцию (false)?</span>
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="kw">if</span> (awaiting_term)
    {
      <span class="dt">double</span> x;
      <span class="kw">switch</span> (peek())
      {
      <span class="kw">case</span> <span class="st">'-'</span>: <span class="kw">case</span> <span class="st">'+'</span>: <span class="kw">case</span> <span class="st">'.'</span>:
      <span class="kw">case</span> <span class="st">'0'</span>: <span class="kw">case</span> <span class="st">'1'</span>: <span class="kw">case</span> <span class="st">'2'</span>: <span class="kw">case</span> <span class="st">'3'</span>: <span class="kw">case</span> <span class="st">'4'</span>:
      <span class="kw">case</span> <span class="st">'5'</span>: <span class="kw">case</span> <span class="st">'6'</span>: <span class="kw">case</span> <span class="st">'7'</span>: <span class="kw">case</span> <span class="st">'8'</span>: <span class="kw">case</span> <span class="st">'9'</span>:
        <span class="kw">if</span> (!(cin &gt;&gt; x))
        {
          error(<span class="st">"number expected</span><span class="ch">\n</span><span class="st">"</span>);
          <span class="kw">goto</span> Finish;
        }
        
        xs.push(x);
        awaiting_term = <span class="kw">false</span>;
        <span class="kw">break</span>;

      <span class="kw">case</span> <span class="st">'('</span>:
        cin.ignore(); <span class="co">// Убрать открывающую скобку из потока.</span>
        ops.push(<span class="st">'('</span>);
        <span class="kw">break</span>;

      <span class="kw">case</span> <span class="st">')'</span>:
        error(<span class="st">"unmatched ')' found</span><span class="ch">\n</span><span class="st">"</span>);
        <span class="kw">goto</span> Finish;

      <span class="kw">default</span>:
        error(<span class="st">"term expected, '"</span>);
        cerr &lt;&lt; peek() &lt;&lt; <span class="st">"' found</span><span class="ch">\n</span><span class="st">"</span>;
        <span class="kw">goto</span> Finish;
      }
    }
    <span class="kw">else</span>
    {
      <span class="kw">switch</span> (<span class="dt">char</span> op = peek())
      {
      <span class="kw">case</span> <span class="st">'+'</span>: <span class="kw">case</span> <span class="st">'-'</span>: <span class="kw">case</span> <span class="st">'*'</span>: <span class="kw">case</span> <span class="st">'/'</span>: <span class="kw">case</span> <span class="st">'%'</span>: <span class="kw">case</span> <span class="st">'^'</span>:
        cin.ignore(); <span class="co">// Убрать знак операции с потока.</span>
        <span class="co">// Выполнить предыдущую операцию, положить на стек следующую.</span>
        <span class="kw">if</span> (!ops.empty() &amp;&amp; ops.top() != <span class="st">'('</span> &amp;&amp; !do_next_op())
          <span class="kw">goto</span> Finish;

        <span class="co">// Положить на стек операций следующую операцию.</span>
        ops.push(op);
        <span class="co">// Теперь ожидаем терм.</span>
        awaiting_term = <span class="kw">true</span>;
        <span class="kw">break</span>;

      <span class="kw">case</span> <span class="st">')'</span>:
        <span class="co">// Убрать скобку с потока cin.</span>
        cin.ignore();
        <span class="co">// Выполнять операции, пока не встретится открывающая скобка.</span>
        <span class="kw">while</span> (<span class="kw">true</span>)
        {
          <span class="kw">if</span> (ops.empty())
          {
            error(<span class="st">"unmatched ')' found</span><span class="ch">\n</span><span class="st">"</span>);
            <span class="kw">goto</span> Finish;
          }

          <span class="kw">if</span> (ops.top() == <span class="st">'('</span>)
          {
            ops.pop();
            <span class="kw">break</span>;
          }

          <span class="kw">if</span> (!do_next_op())
            <span class="kw">goto</span> Finish;
        }
        <span class="kw">break</span>;

      <span class="kw">case</span> EOF:
        <span class="co">// Выполнить все оставшиеся операции.</span>
        <span class="kw">while</span> (!ops.empty())
        {
          <span class="kw">if</span> (ops.top() == <span class="st">'('</span>)
          {
            error(<span class="st">"unmatched '(' found</span><span class="ch">\n</span><span class="st">"</span>);
            <span class="kw">break</span>;
          }

          <span class="kw">if</span> (!do_next_op())
            <span class="kw">break</span>;
        }
        <span class="kw">goto</span> Finish;

      <span class="kw">default</span>:
        error(<span class="st">"operation expected: '"</span>);
        cerr &lt;&lt; op &lt;&lt; <span class="st">"'</span><span class="ch">\n</span><span class="st">"</span>;
        <span class="kw">goto</span> Finish;
      }
    }
  }

Finish:
  <span class="kw">if</span> (xs.empty())
  {
    error(<span class="st">"not enough operands</span><span class="ch">\n</span><span class="st">"</span>);
    <span class="kw">return</span> <span class="fl">0.</span>;
  }

  <span class="kw">return</span> xs.top();
}


<span class="dt">int</span> main()
{
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="dt">double</span> answer = infix();
    cin.clear();
    cin.ignore(cin.rdbuf()-&gt;in_avail());
    cin.sync();
    cout &lt;&lt; <span class="st">"answer = "</span> &lt;&lt; answer &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="infix_calc_shunting_yard.cpp">0830-infix_calc_shunting_yard.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// infix_calc_shunting_yard.cpp</span>
<span class="co">// Инфиксный калькулятор с учётом приоритетов и ассоциативности операций и поддержкой скобок.</span>
<span class="co">// Пример: 2+(2*2) ==&gt; 6.</span>
<span class="co">// Упрощённая грамматика:</span>
<span class="co">//  Терм --&gt; Число | '(' Выражение ')'    // term</span>
<span class="co">//  Выражение --&gt; Терм { Операция Терм }  // infix</span>
<span class="co">// Реализован алгоритм сортировочной станции Э.Дейкстры на основе примера infix_calc_p_stack_std.cpp.</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>
<span class="ot">#include &lt;stack&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Вспомогательная функция: </span>
<span class="co">// посмотреть следующий непробельный символ в потоке cin, не извлекая его.</span>
<span class="co">// (Пробельные символы пропускаются. Возвращает EOF если поток закончился.)</span>
<span class="dt">char</span> peek()
{
  <span class="dt">char</span> ch = EOF;
  <span class="kw">if</span> (cin &gt;&gt; ch)
    cin.unget();
  <span class="kw">return</span> ch;
}

<span class="co">// Вспомогательная функция для установки ошибки.</span>
<span class="dt">void</span> error(<span class="dt">const</span> <span class="dt">char</span> *message)
{
  cerr &lt;&lt; message;
  cin.setstate(ios::failbit);
}

<span class="co">// Числовой приоритет операции.</span>
<span class="dt">int</span> precedence(<span class="dt">char</span> op)
{
  <span class="kw">switch</span> (op)
  {
  <span class="kw">case</span> <span class="st">'+'</span>: <span class="kw">case</span> <span class="st">'-'</span>: <span class="kw">return</span> <span class="dv">100</span>;
  <span class="kw">case</span> <span class="st">'*'</span>: <span class="kw">case</span> <span class="st">'/'</span>: <span class="kw">case</span> <span class="st">'%'</span>: <span class="kw">return</span> <span class="dv">200</span>;
  <span class="kw">case</span> <span class="st">'^'</span>: <span class="kw">return</span> <span class="dv">300</span>;
  <span class="kw">default</span>: <span class="kw">return</span> <span class="dv">0</span>;
  }
}

<span class="co">// Операция op связывает операнды слева направо?</span>
<span class="dt">bool</span> is_left_associative(<span class="dt">char</span> op)
{
  <span class="kw">return</span> op != <span class="st">'^'</span>;
}


<span class="dt">double</span> infix()
{
  stack&lt;<span class="dt">char</span>&gt; ops;  <span class="co">// Стек операций.</span>
  stack&lt;<span class="dt">double</span>&gt; xs; <span class="co">// Стек операндов.</span>

  <span class="co">// Вложенная функция, выполняющая операцию на вершине стека ops.</span>
  <span class="co">// Возвращает "успех" (false если произошла ошибка, true если выполнено успешно).</span>
  <span class="kw">auto</span> do_next_op = [&amp;]() -&gt; <span class="dt">bool</span>
  {
    <span class="dt">double</span> x, y;
    <span class="kw">if</span> (xs.empty())
    {
      error(<span class="st">"not enough operands</span><span class="ch">\n</span><span class="st">"</span>);
      <span class="kw">return</span> <span class="kw">false</span>;
    }

    y = xs.top();
    xs.pop();

    <span class="kw">if</span> (xs.empty())
    {
      xs.push(y);
      error(<span class="st">"not enough operands</span><span class="ch">\n</span><span class="st">"</span>);
      <span class="kw">return</span> <span class="kw">false</span>;
    }

    x = xs.top();

    <span class="kw">switch</span> (ops.top())
    {
    <span class="kw">case</span> <span class="st">'+'</span>: x = x + y; <span class="kw">break</span>;
    <span class="kw">case</span> <span class="st">'-'</span>: x = x - y; <span class="kw">break</span>;
    <span class="kw">case</span> <span class="st">'*'</span>: x = x * y; <span class="kw">break</span>;
    <span class="kw">case</span> <span class="st">'/'</span>: x = x / y; <span class="kw">break</span>;
    <span class="kw">case</span> <span class="st">'%'</span>: x = fmod(x, y); <span class="kw">break</span>;
    <span class="kw">case</span> <span class="st">'^'</span>: x = pow(x, y); <span class="kw">break</span>;
    <span class="kw">default</span>:
      error(<span class="st">"internal error</span><span class="ch">\n</span><span class="st">"</span>);
      <span class="kw">return</span> <span class="kw">false</span>;
    }

    <span class="co">// Сохранить результат операции вместо операндов на стеке xs.</span>
    xs.top() = x;
    <span class="co">// Убрать со стека операций выполненную операцию.</span>
    ops.pop();
    <span class="kw">return</span> <span class="kw">true</span>;
  };


  <span class="dt">bool</span> awaiting_term = <span class="kw">true</span>; <span class="co">// Ожидает терм (true) или операцию (false)?</span>
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="kw">if</span> (awaiting_term) <span class="co">// Ожидается терм.</span>
    {
      <span class="dt">double</span> x;
      <span class="kw">switch</span> (<span class="dt">char</span> ch = peek())
      {
      <span class="co">// - и + могут стоять перед скобкой (, а не перед числом,</span>
      <span class="co">// поэтому обрабатываем этот случай особо.</span>
      <span class="kw">case</span> <span class="st">'-'</span>: <span class="kw">case</span> <span class="st">'+'</span>:
        <span class="kw">if</span> (cin.ignore() &amp;&amp; cin.peek() == <span class="st">'('</span>)
        {
          <span class="co">// Имитируем отрицание вычитанием из нуля.</span>
          <span class="kw">if</span> (ch == <span class="st">'-'</span>)
          {
            xs.push(<span class="dv">0</span>);
            ops.push(<span class="st">'-'</span>);
          }
          
          cin.ignore(); <span class="co">// Убрать открывающую скобку из потока.</span>
          ops.push(<span class="st">'('</span>);
          <span class="kw">break</span>;
        }
        cin.unget(); <span class="co">// Не скобка -- возвращаем - или + обратно.</span>
        <span class="co">// "Полноценный калькулятор" должен поддерживать унарные операции непосредственно.</span>
        <span class="co">// Данный пример упрощён: поддерживаются только бинарные инфиксные операции.</span>
      
      <span class="kw">case</span> <span class="st">'.'</span>:
      <span class="kw">case</span> <span class="st">'0'</span>: <span class="kw">case</span> <span class="st">'1'</span>: <span class="kw">case</span> <span class="st">'2'</span>: <span class="kw">case</span> <span class="st">'3'</span>: <span class="kw">case</span> <span class="st">'4'</span>:
      <span class="kw">case</span> <span class="st">'5'</span>: <span class="kw">case</span> <span class="st">'6'</span>: <span class="kw">case</span> <span class="st">'7'</span>: <span class="kw">case</span> <span class="st">'8'</span>: <span class="kw">case</span> <span class="st">'9'</span>:
        <span class="kw">if</span> (!(cin &gt;&gt; x))
        {
          error(<span class="st">"number expected</span><span class="ch">\n</span><span class="st">"</span>);
          <span class="kw">goto</span> Finish;
        }
        
        xs.push(x);
        awaiting_term = <span class="kw">false</span>;
        <span class="kw">break</span>;

      <span class="kw">case</span> <span class="st">'('</span>:
        cin.ignore(); <span class="co">// Убрать открывающую скобку из потока.</span>
        ops.push(<span class="st">'('</span>);
        <span class="kw">break</span>;

      <span class="kw">case</span> <span class="st">')'</span>:
        error(<span class="st">"unmatched ')' found</span><span class="ch">\n</span><span class="st">"</span>);
        <span class="kw">goto</span> Finish;

      <span class="kw">default</span>:
        error(<span class="st">"term expected, '"</span>);
        cerr &lt;&lt; peek() &lt;&lt; <span class="st">"' found</span><span class="ch">\n</span><span class="st">"</span>;
        <span class="kw">goto</span> Finish;
      }
    }
    <span class="kw">else</span> <span class="co">// Ожидается операция.</span>
    {
      <span class="kw">switch</span> (<span class="dt">char</span> op = peek())
      {
      <span class="kw">case</span> <span class="st">'+'</span>: <span class="kw">case</span> <span class="st">'-'</span>: <span class="kw">case</span> <span class="st">'*'</span>: <span class="kw">case</span> <span class="st">'/'</span>: <span class="kw">case</span> <span class="st">'%'</span>: <span class="kw">case</span> <span class="st">'^'</span>:
        <span class="co">// Основное отличие от предыдущего варианта калькулятора,</span>
        <span class="co">// позволяющее учитывать приоритеты операций, находится здесь.</span>
        {
          cin.ignore(); <span class="co">// Убрать знак операции с потока.</span>
          <span class="dt">const</span> <span class="kw">auto</span> op_prec = precedence(op); <span class="co">// Приоритет считанной операции.</span>
          <span class="dt">const</span> <span class="kw">auto</span> op_ltr = is_left_associative(op); <span class="co">// Левоассоциирующая операция?</span>

          <span class="co">// Выполнить все предыдущие операции, имеющие приоритет выше op,</span>
          <span class="co">// либо равный приоритет при условии, что op -- левоассоциирующая.</span>
          <span class="kw">while</span> (!ops.empty() &amp;&amp; ops.top() != <span class="st">'('</span>)
          {
            <span class="dt">const</span> <span class="kw">auto</span> left_op_prec = precedence(ops.top());
            <span class="co">// Отрицание условия, записанного в комментарии выше (условие выхода из цикла).</span>
            <span class="kw">if</span> ((op_ltr &amp;&amp; left_op_prec &lt; op_prec)
            ||  (!op_ltr &amp;&amp; left_op_prec &lt;= op_prec))
              <span class="kw">break</span>;
            
            <span class="kw">if</span> (!do_next_op())
              <span class="kw">goto</span> Finish;
          }

          <span class="co">// Положить на стек операций следующую операцию.</span>
          ops.push(op);
          <span class="co">// Теперь ожидаем терм.</span>
          awaiting_term = <span class="kw">true</span>;
        }
        <span class="kw">break</span>;

      <span class="kw">case</span> <span class="st">')'</span>:
        <span class="co">// Убрать скобку с потока cin.</span>
        cin.ignore();
        <span class="co">// Выполнять операции, пока не встретится открывающая скобка.</span>
        <span class="kw">while</span> (<span class="kw">true</span>)
        {
          <span class="kw">if</span> (ops.empty())
          {
            error(<span class="st">"unmatched ')' found</span><span class="ch">\n</span><span class="st">"</span>);
            <span class="kw">goto</span> Finish;
          }

          <span class="kw">if</span> (ops.top() == <span class="st">'('</span>)
          {
            ops.pop();
            <span class="kw">break</span>;
          }

          <span class="kw">if</span> (!do_next_op())
            <span class="kw">goto</span> Finish;
        }
        <span class="kw">break</span>;

      <span class="kw">case</span> EOF:
        <span class="co">// Выполнить все оставшиеся операции.</span>
        <span class="kw">while</span> (!ops.empty())
        {
          <span class="kw">if</span> (ops.top() == <span class="st">'('</span>)
          {
            error(<span class="st">"unmatched '(' found</span><span class="ch">\n</span><span class="st">"</span>);
            <span class="kw">break</span>;
          }

          <span class="kw">if</span> (!do_next_op())
            <span class="kw">break</span>;
        }
        <span class="kw">goto</span> Finish;

      <span class="kw">default</span>:
        error(<span class="st">"operation expected: '"</span>);
        cerr &lt;&lt; op &lt;&lt; <span class="st">"'</span><span class="ch">\n</span><span class="st">"</span>;
        <span class="kw">goto</span> Finish;
      }
    }
  }

Finish:
  <span class="kw">if</span> (xs.empty())
  {
    error(<span class="st">"not enough operands</span><span class="ch">\n</span><span class="st">"</span>);
    <span class="kw">return</span> <span class="fl">0.</span>;
  }

  <span class="kw">return</span> xs.top();
}


<span class="dt">int</span> main()
{
  cout.precision(<span class="dv">16</span>);
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="dt">double</span> answer = infix();
    cin.clear();
    cin.ignore(cin.rdbuf()-&gt;in_avail());
    cin.sync();
    cout &lt;&lt; <span class="st">"answer = "</span> &lt;&lt; answer &lt;&lt; endl;
  }
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="merge_sort.cpp">0840-merge_sort.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// merge_sort.cpp</span>
<span class="co">// Сортировка слияниями (рекурсивный вариант и вариант с явным стеком).</span>
<span class="co">// Сортирует массивы целых.</span>
<span class="ot">#include &lt;cstddef&gt;</span>
<span class="ot">#include &lt;cassert&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Операция слияния двух упорядоченных массивов (a и b)</span>
<span class="co">// в третий упорядоченный массив c.</span>
<span class="co">// Предполагается, что c имеет размер не менее, чем an + bn.</span>
<span class="co">// Функция возвращает индекс следующего элемента за последним записанным в c.</span>
size_t merge(<span class="dt">const</span> <span class="dt">int</span> a[], size_t an, <span class="dt">const</span> <span class="dt">int</span> b[], size_t bn, <span class="dt">int</span> c[])
{
  assert(an != <span class="dv">0</span> &amp;&amp; bn != <span class="dv">0</span>);
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>, j = <span class="dv">0</span>, k = <span class="dv">0</span>;; ++k)
  {
    <span class="kw">if</span> (b[j] &lt; a[i])
    {
      c[k] = b[j];
      <span class="kw">if</span> (++j == bn)
      {
        <span class="kw">while</span> (i != an)
          c[++k] = a[i++];
        <span class="kw">return</span> k + <span class="dv">1</span>;
      }
    }
    <span class="kw">else</span>
    {
      c[k] = a[i];
      <span class="kw">if</span> (++i == an)
      {
        <span class="kw">while</span> (j != bn)
          c[++k] = b[j++];
        <span class="kw">return</span> k + <span class="dv">1</span>;
      }
    }
  }
}


<span class="co">// Сортировка слияниями с внешнем буфером.</span>
<span class="co">// Сортирует массив a на месте, используя buf для хранения промежуточных результатов.</span>
<span class="co">// Размер buf должен быть не меньше an.</span>
<span class="dt">void</span> merge_sort(<span class="dt">int</span> a[], size_t an, <span class="dt">int</span> buf[])
{
  <span class="kw">if</span> (<span class="dv">1</span> &lt; an)
  {
    <span class="co">// Размеры сортируемых "половин": p1 -- левая, p2 -- правая.</span>
    <span class="dt">const</span> <span class="kw">auto</span> p1 = an / <span class="dv">2</span>, p2 = an - p1;
    <span class="co">// Отсортировать левую половину.</span>
    merge_sort(a, p1, buf);
    <span class="co">// Отсортировать правую половину.</span>
    merge_sort(a + p1, p2, buf);
    <span class="co">// Выполнить слияние отсортированных половин в буфер.</span>
    merge(a, p1, a + p1, p2, buf);
    <span class="co">// Скопировать содержимое буфера в исходный массив.</span>
    <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; an; ++i)
      a[i] = buf[i];
  }
}

<span class="co">// Сортировка слияниями, создающая свой буфер.</span>
<span class="co">// Использует предыдущий алгоритм.</span>
<span class="dt">void</span> merge_sort(<span class="dt">int</span> a[], size_t an)
{
  <span class="dt">int</span> *buf = <span class="kw">new</span> <span class="dt">int</span>[an];
  merge_sort(a, an, buf);
  <span class="kw">delete</span>[] buf;
}


<span class="co">// Сортировка слияниями на основе цикла и стека.</span>
<span class="co">// Представляет собой модификацию рекурсивного варианта.</span>
<span class="co">// Использует буфер того же размера, что и исходный массив (создаёт и удаляет буфер динамически).</span>
<span class="dt">void</span> merge_sort_s(<span class="dt">int</span> a[], size_t an)
{
  <span class="co">// Стек отложенных задач реализован в виде статического массива размера 64.</span>
  <span class="co">// Предполагается, что адреса не более, чем 64-битные.</span>
  <span class="kw">struct</span> {
    <span class="dt">int</span> *a;    <span class="co">// Указатель на начало сортируемого диапазона.</span>
    size_t an; <span class="co">// Размер сортируемого диапазона.</span>
    <span class="dt">int</span> stage; <span class="co">// Стадия сортировки диапазона (0, 1, 2, 3).</span>
  } ds[<span class="dv">64</span>];

  size_t sp = <span class="dv">0</span>; <span class="co">// Индекс текущей вершины стека.</span>
  <span class="dt">int</span> *buf = <span class="kw">new</span> <span class="dt">int</span>[an];

  <span class="co">// Положить в стек первоначальную задачу -- весь исходный массив.</span>
  ds[<span class="dv">0</span>].a = a;
  ds[<span class="dv">0</span>].an = an;
  ds[<span class="dv">0</span>].stage = <span class="dv">0</span>;
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="co">// На каждой стадии выполняется своё действие.</span>
    <span class="kw">switch</span> (ds[sp].stage++)
    {
    <span class="kw">case</span> <span class="dv">0</span>: <span class="co">// Создать задачу для сортировки левой половины.</span>
      <span class="kw">if</span> (<span class="dv">1</span> &lt; an)
      {
        an /= <span class="dv">2</span>;

        <span class="kw">auto</span> &amp;t = ds[++sp];
        t.a = a;
        t.an = an;
        t.stage = <span class="dv">0</span>;
      }
      <span class="kw">break</span>;

    <span class="kw">case</span> <span class="dv">1</span>: <span class="co">// Создать задачу для сортировки правой половины.</span>
      <span class="kw">if</span> (<span class="dv">1</span> &lt; an)
      {
        <span class="dt">const</span> <span class="kw">auto</span> p = an / <span class="dv">2</span>;
        a += p;
        an -= p;

        <span class="kw">auto</span> &amp;t = ds[++sp];
        t.a = a;
        t.an = an;
        t.stage = <span class="dv">0</span>;
      }
      <span class="kw">break</span>;

    <span class="kw">case</span> <span class="dv">2</span>: <span class="co">// Выполнить слияние отсортированных половин.</span>
      <span class="kw">if</span> (<span class="dv">1</span> &lt; an)
      {
        <span class="dt">const</span> <span class="kw">auto</span> p = an / <span class="dv">2</span>;
        merge(a, p, a + p, an - p, buf);
        <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; an; ++i)
          a[i] = buf[i];
      }
      <span class="kw">break</span>;

    <span class="kw">default</span>: <span class="co">// Убрать задачу из стека.</span>
      <span class="kw">if</span> (sp-- == <span class="dv">0</span>)
      {
        <span class="co">// Все задачи выполнены, завершить работу.</span>
        <span class="kw">delete</span>[] buf;
        <span class="kw">return</span>;
      }
      <span class="kw">else</span>
      {
        <span class="kw">auto</span> &amp;t = ds[sp];
        a = t.a;
        an = t.an;
      }
    }    
  }
}</code></pre></div>
<p><br>
</p>
<h1 id="sll_merge_sort.cpp">0845-sll_merge_sort.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// sll_merge.cpp</span>
<span class="co">// Односвязный список (singly-linked list, SLL) и сортировка слияниями.</span>
<span class="ot">#include &lt;cassert&gt;</span>
<span class="ot">#include &lt;cstddef&gt;</span>

<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Односвязный список</span>

<span class="co">// Тип значений, хранимый в списке.</span>
<span class="kw">typedef</span> <span class="dt">long</span> Value;

<span class="co">// Звено односвязного списка.</span>
<span class="kw">struct</span> Link
{
  Link *next;  <span class="co">// указатель на следующее звено</span>
  Value value; <span class="co">// значение, хранящееся в звене</span>

  <span class="co">// Элементарные конструкторы</span>
  Link(): next(<span class="kw">nullptr</span>) {}
  <span class="kw">explicit</span> Link(Value value, Link *next = <span class="kw">nullptr</span>)
    : next(next), value(value) {}
};


<span class="co">// Добавить значение в начало списка.</span>
Link* push_front(Link *list, Value value)
{
  <span class="kw">return</span> <span class="kw">new</span> Link(value, list);
}

<span class="co">// Создать список из массива.</span>
Link* list_from_array(<span class="dt">const</span> Value a[], std::size_t n)
{
  Link *head = <span class="kw">nullptr</span>;
  <span class="kw">while</span> (n != <span class="dv">0</span>)
    head = push_front(head, a[--n]);
  <span class="kw">return</span> head;
}


<span class="co">// Удалить начальное звено списка.</span>
<span class="co">// Если removed_value != nullptr, то по этому адресу будет записано значение удалённого узла.</span>
Link* pop_front(Link *list, Value *removed_value = <span class="kw">nullptr</span>)
{
  assert(list);
  <span class="dt">const</span> <span class="kw">auto</span> next = list-&gt;next;
  <span class="kw">if</span> (removed_value)
    *removed_value = list-&gt;value;
  <span class="kw">delete</span> list;
  <span class="kw">return</span> next;
}

<span class="co">// Удалить список целиком.</span>
<span class="dt">void</span> delete_list(Link *list)
{
  <span class="kw">while</span> (list)
    list = pop_front(list);
}


<span class="co">// Проверить, является ли список закольцованным.</span>
<span class="co">// Данная функция приводится как пример, далее она не используется (только тестируется).</span>
<span class="dt">bool</span> has_loop(Link *list)
{
  <span class="kw">auto</span> slow = list;
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="co">// Два шага по list.</span>
    <span class="kw">if</span> (!list)
      <span class="kw">return</span> <span class="kw">false</span>;
    list = list-&gt;next;
    <span class="kw">if</span> (!list)
      <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">if</span> (list == slow)
      <span class="kw">return</span> <span class="kw">true</span>;
    list = list-&gt;next;
    <span class="kw">if</span> (list == slow)
      <span class="kw">return</span> <span class="kw">true</span>;

    <span class="co">// Один шаг по slow.</span>
    slow = slow-&gt;next;
  }
}

<span class="co">// Тест работоспособности has_loop.</span>
<span class="dt">int</span> test_has_loop()
{
  <span class="co">// Незакольцованный список.</span>
  Link a, b, c, d, e;
  a.next = &amp;b;
  b.next = &amp;c;
  c.next = &amp;d;
  d.next = &amp;e;
  <span class="kw">if</span> (has_loop(&amp;a))
    <span class="kw">return</span> <span class="dv">1</span>;

  <span class="co">// Закольцованный список.</span>
  e.next = &amp;a;
  <span class="kw">if</span> (!has_loop(&amp;a))
    <span class="kw">return</span> <span class="dv">2</span>;

  <span class="co">// "Лассо".</span>
  e.next = &amp;c;
  <span class="kw">if</span> (!has_loop(&amp;a))
    <span class="kw">return</span> <span class="dv">3</span>;
  <span class="kw">return</span> <span class="dv">0</span>;
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Сортировка списка слияниями</span>
<span class="co">// Требует O(N log N) время и O(1) память.</span>

<span class="co">// Вспомогательная функция: возвращает указатель на звено с минимальным значением.</span>
<span class="co">// Продвигает переменную, указывающую на возвращённое звено на следующую позицию.</span>
<span class="kw">inline</span> Link* merging_next(Link *&amp;a, Link *&amp;b)
{
  assert(a &amp;&amp; b);
  <span class="kw">auto</span> result = a;
  <span class="kw">if</span> (b-&gt;value &lt; a-&gt;value)
  {
    result = b;
    b = b-&gt;next;
  }
  <span class="kw">else</span>
    a = a-&gt;next;
  <span class="kw">return</span> result;
}

<span class="co">// Слияние двух упорядоченных списков в один упорядоченный список.</span>
Link* merge(Link *a, Link *b)
{
  <span class="co">// Если один из списков пуст...</span>
  <span class="kw">if</span> (!a)
    <span class="kw">return</span> b;
  <span class="kw">if</span> (!b)
    <span class="kw">return</span> a;

  <span class="co">// Оба непусты: головой нового списка будет голова с меньшим значением.</span>
  <span class="kw">for</span> (<span class="kw">auto</span> head = merging_next(a, b), tail = head;;)
  {
    <span class="kw">if</span> (!a)
    {
      tail-&gt;next = b;
      <span class="kw">return</span> head;
    }

    <span class="kw">if</span> (!b)
    {
      tail-&gt;next = a;
      <span class="kw">return</span> head;
    }

    tail = tail-&gt;next = merging_next(a, b);
  }
}

<span class="co">// Найти элемент перед средним элементом списка.</span>
Link* list_premiddle(Link *list)
{
  <span class="co">// Два шага по list -- один шаг по mid.</span>
  <span class="kw">for</span> (<span class="kw">auto</span> premid = list, mid = premid;;)
  {
    <span class="kw">if</span> (!list)
      <span class="kw">return</span> premid;
    list = list-&gt;next;
    <span class="kw">if</span> (!list)
      <span class="kw">return</span> premid;
    list = list-&gt;next;
    premid = mid;
    mid = mid-&gt;next;
  }
}

<span class="co">// Собственно сортировка слияниями (рекурсивный нисходящий вариант).</span>
<span class="co">// Возвращает новую голову исходного списка.</span>
Link* merge_sort(Link *list)
{
  <span class="co">// Менее двух элементов?</span>
  <span class="kw">if</span> (!list || !list-&gt;next)
    <span class="kw">return</span> list;

  <span class="co">// Разрезать на два списка посередине.</span>
  <span class="kw">auto</span> premid = list_premiddle(list);
  <span class="kw">auto</span> tail = premid-&gt;next;
  premid-&gt;next = <span class="kw">nullptr</span>;
  <span class="co">// Отсортировать списки по отдельности.</span>
  list = merge_sort(list);
  tail = merge_sort(tail);
  <span class="co">// Слить в общий и вернуть.</span>
  <span class="kw">return</span> merge(list, tail);
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Тестирование работоспособности сортировки</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;random&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Генерирует случайные списки, сортирует и сравнивает с результатом стандартной сортировки на исходном массиве.</span>
<span class="dt">int</span> test_merge_sort()
{
  mt19937_64 rng(<span class="dv">5151</span>);
  uniform_int_distribution&lt;Value&gt; vg;

  <span class="dt">static</span> <span class="dt">const</span> <span class="kw">auto</span> MAX_LENGTH = <span class="dv">2049</span>;
  vector&lt;Value&gt; reference;

  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; MAX_LENGTH; ++i)
  {
    <span class="co">// Заполнить референс-массив.</span>
    reference.resize(i);
    <span class="kw">for</span> (<span class="kw">auto</span> &amp;item : reference)
      item = vg(rng);
    
    <span class="co">// Скопировать массив в новый список.</span>
    <span class="kw">auto</span> list = list_from_array(reference.data(), reference.size());

    <span class="co">// Отсортировать и то и другое.</span>
    sort(reference.begin(), reference.end());
    list = merge_sort(list);

    <span class="co">// Сравнить на равенство содержимое массива и списка.</span>
    <span class="dt">bool</span> error = <span class="kw">false</span>;
    <span class="kw">auto</span> pos = list;
    <span class="kw">for</span> (<span class="kw">auto</span> &amp;item : reference)
    {
      <span class="kw">if</span> (item != pos-&gt;value)
      {
        error = <span class="kw">true</span>;
        <span class="kw">break</span>;
      }

      pos = pos-&gt;next;
    }

    <span class="co">// Удалить список.</span>
    delete_list(list);

    <span class="co">// Нашли ошибку?</span>
    <span class="kw">if</span> (error)
      <span class="kw">return</span> i<span class="dv">+1</span>;
  }

  <span class="kw">return</span> <span class="dv">0</span>;
}


<span class="dt">int</span> main()
{
  cout &lt;&lt; <span class="st">"test_has_loop: "</span> &lt;&lt; test_has_loop() &lt;&lt; endl;
  cout &lt;&lt; <span class="st">"test_merge_sort: "</span> &lt;&lt; test_merge_sort() &lt;&lt; endl;
  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="quick_sort.cpp">0850-quick_sort.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// quick_sort.cpp</span>
<span class="co">// Быстрая сортировка (рекурсивный вариант, вариант с одной веткой рекурсии и вариант с явным стеком).</span>
<span class="co">// Сортирует массивы целых.</span>
<span class="ot">#include &lt;cstddef&gt;</span>
<span class="ot">#include &lt;cassert&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Выполнить обмен значениями двух целочисленных ячеек памяти (переменных).</span>
<span class="dt">void</span> swap(<span class="dt">int</span> &amp;a, <span class="dt">int</span> &amp;b)
{
  <span class="dt">int</span> t = a;
  a = b;
  b = t;
}

<span class="co">// Разделить элементы массива a (перемещая их внутри массива) на две части:</span>
<span class="co">// Левая часть: все элементы a, меньшие key.</span>
<span class="co">// Правая часть: все элементы a, не меньшие key.</span>
<span class="co">// Возвращает размер левой части (т.е. индекс первого элемента правой части).</span>
<span class="co">// Левая часть может быть пустой (массив не содержит элементов, меньших key),</span>
<span class="co">// в этом случае функция возвращает 0.</span>
<span class="co">// Предполагается, что массив не пуст (n != 0), и значение key содержится в массиве, поэтому</span>
<span class="co">// правая часть пустой быть не может и результат функции обязательно меньше n.</span>
size_t qpartition(<span class="dt">int</span> a[], size_t n, <span class="dt">int</span> key)
{
  assert(n != <span class="dv">0</span>);
  <span class="co">// Движемся в массиве с левого конца (указатель l) вправо</span>
  <span class="co">// и с правого конца (указатель r) влево.</span>
  <span class="dt">int</span> *l = a, *r = a + n - <span class="dv">1</span>;
  <span class="co">// Говорим, что "произошло пересечение", если случается ситуация r &lt;= l.</span>
  <span class="co">// В случае, когда произошло пересечение, разделение завершено, и можно закончить.</span>
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="co">// Установим l на следующую позицию, в которой находится элемент, не меньший key.</span>
    <span class="kw">while</span> (*l &lt; key)
      <span class="kw">if</span> (r &lt; ++l) <span class="co">// Произошло пересечение?</span>
        <span class="kw">return</span> l - a;

    <span class="co">// Установим r на следующую позицию, в которой находится элемент, меньший key.</span>
    <span class="kw">while</span> (!(*r &lt; key))
      <span class="kw">if</span> (--r &lt; l) <span class="co">// Произошло пересечение?</span>
        <span class="kw">return</span> l - a;

    <span class="co">// Все элементы слева от l меньше key.</span>
    <span class="co">// Элемент по адресу l не меньше key.</span>
    <span class="co">// Все элементы справа от r не меньше key.</span>
    <span class="co">// Элемент по адресу r меньше key.</span>
    <span class="co">// Обменять элементы на позициях l и r.</span>
    swap(*l, *r);

    <span class="co">// Переместить l и r на следующие позиции и проверить наличие пересечения.</span>
    <span class="kw">if</span> (--r &lt;= ++l)
    {
      <span class="co">// Может возникнуть ситуация, когда между l и r находился один элемент,</span>
      <span class="co">// меньший key. В этом случае, его надо отнести к левой половине.</span>
      <span class="kw">if</span> (*l &lt; key) ++l;
      <span class="kw">return</span> l - a;
    }
  }
}


<span class="co">// Быстрая сортировка, рекурсивный вариант.</span>
<span class="co">// Сортирует массив a на месте.</span>
<span class="dt">void</span> quick_sort(<span class="dt">int</span> a[], size_t n)
{
  <span class="kw">if</span> (n &gt; <span class="dv">1</span>)
  {
    <span class="co">// Выберем в качестве ключа элемент посередине массива</span>
    <span class="co">// (можно выбирать любой элемент, средний -- произвольный выбор автора)</span>
    <span class="co">// и выполним разделение по нему.</span>
    size_t left_n = qpartition(a, n, a[n / <span class="dv">2</span>]);
    <span class="kw">if</span> (left_n == <span class="dv">0</span>)
    {
      <span class="co">// Все элементы a не меньше, чем средний элемент,</span>
      <span class="co">// т.е. средний элемент равен минимуму из всех элементов массива.</span>
      <span class="co">// В этом случае qpartition не изменяет исходный массив.</span>
      <span class="co">// Обменяем средний элемент массива с начальным.</span>
      swap(a[<span class="dv">0</span>], a[n / <span class="dv">2</span>]);
      <span class="co">// Отсортируем рекурсивно оставшуюся часть из n - 1 элемента.</span>
      quick_sort(a + <span class="dv">1</span>, n - <span class="dv">1</span>);
    }
    <span class="kw">else</span>
    {
      <span class="co">// Удалось разделить массив на две части.</span>
      <span class="co">// Так как любой элемент из левой части меньше любого элемента из правой части,</span>
      <span class="co">// то теперь достаточно независимо отсортировать обе части,</span>
      <span class="co">// что мы и выполним рекурсивно.</span>
      quick_sort(a, left_n);
      quick_sort(a + left_n, n - left_n);
    }
  }
}


<span class="co">// Быстрая сортировка, рекурсивный вариант с раскрытием одной ветки рекурсии в цикл.</span>
<span class="co">// Засчёт того, что рекурсивный вызов выполняется для части минимального размера,</span>
<span class="co">// позволяет избежать переполнения стека вызовов (полностью рекурсивный вариант,</span>
<span class="co">// приведённый выше, может выполнять до n вложенных рекурсивных вызовов).</span>
<span class="dt">void</span> quick_sort_tc(<span class="dt">int</span> a[], size_t n)
{
  <span class="co">// Пока есть что сортировать.</span>
  <span class="kw">while</span> (n &gt; <span class="dv">1</span>)
  {
    <span class="co">// Выполним разделение диапазона по среднему элементу.</span>
    size_t left_n = qpartition(a, n, a[n / <span class="dv">2</span>]);

    <span class="kw">if</span> (left_n == <span class="dv">0</span>)
    {
      <span class="co">// Разделить не удалось, т.к. средний элемент равен минимуму всех элементов.</span>
      <span class="co">// Обменяем его с начальным элементом,</span>
      swap(a[<span class="dv">0</span>], a[n / <span class="dv">2</span>]);
      <span class="co">// а на следующей итерации цикла начнём сортировать оставшуюся часть.</span>
      ++a;
      --n;
    }
    <span class="kw">else</span> <span class="kw">if</span> (left_n &lt; n - left_n)
    {
      <span class="co">// Левая часть меньше правой, отсортируем её рекурсивно.</span>
      quick_sort_tc(a, left_n);
      <span class="co">// Правую часть отсортируем в цикле.</span>
      a += left_n;
      n -= left_n;
    }
    <span class="kw">else</span>
    {
      <span class="co">// Правая часть не больше левой, отсортируем её рекурсивно.</span>
      quick_sort(a + left_n, n - left_n);
      <span class="co">// Левую часть отсортируем в цикле.</span>
      n = left_n;
    }
  }
}


<span class="co">// Быстрая сортировка, вариант с раскрытием одной ветки в цикле и явным стеком отложенных веток.</span>
<span class="dt">void</span> quick_sort_s(<span class="dt">int</span> a[], size_t n)
{
  <span class="co">// Предполагаем, что размер адреса не превосходит 64 бит.</span>
  <span class="co">// Благодаря тому, что откладываются только "меньшие" части,</span>
  <span class="co">//  глубина стека не может превзойти 64.</span>
  <span class="kw">struct</span> {
    <span class="dt">int</span> *a;
    size_t n;
  } ds[<span class="dv">64</span>];

  size_t sp = <span class="dv">0</span>; <span class="co">// Количество элементов, помещённых в стек.</span>
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="kw">while</span> (n &gt; <span class="dv">1</span>)
    {
      <span class="co">// Выполним разделение диапазона по среднему элементу.</span>
      size_t left_n = qpartition(a, n, a[n / <span class="dv">2</span>]);

      <span class="kw">if</span> (left_n == <span class="dv">0</span>)
      {
        <span class="co">// Разделить не удалось, обменяем начальный элемент со средним</span>
        swap(a[<span class="dv">0</span>], a[n / <span class="dv">2</span>]);
        <span class="co">// и будем дальше сортировать оставшиеся.</span>
        ++a;
        --n;
      }
      <span class="kw">else</span> <span class="kw">if</span> (left_n &lt; n - left_n)
      {
        <span class="co">// Вместо выполнения рекурсивного вызова для левой (меньшей) части</span>
        <span class="co">// отложим её в стек.</span>
        <span class="kw">auto</span> &amp;t = ds[sp++];
        t.a = a;
        t.n = left_n;

        <span class="co">// Дальше сортируем правую часть.</span>
        a += left_n;
        n -= left_n;
      }
      <span class="kw">else</span>
      {
        <span class="co">// Вместо выполнения рекурсивного вызова для правой части</span>
        <span class="co">// отложим её в стек.</span>
        <span class="kw">auto</span> &amp;t = ds[sp++];
        t.a = a + left_n;
        t.n = n - left_n;

        <span class="co">// Дальше сортируем левую часть.</span>
        n = left_n;
      }
    }

    <span class="co">// Нет отложенных задач? Завершить работу.</span>
    <span class="kw">if</span> (sp == <span class="dv">0</span>)
      <span class="kw">return</span>;

    <span class="co">// Есть отложенные задачи. Извлечь самую верхнюю из них.</span>
    <span class="kw">auto</span> &amp;t = ds[--sp];
    a = t.a;
    n = t.n;
  }
}</code></pre></div>
<p><br>
</p>
<h1 id="bitmap_works.cpp">0860-bitmap_works.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// bitmap_works.cpp</span>
<span class="co">// Поиск в глубину и поиск в ширину на картинке:</span>
<span class="co">// заливка связной области картинки заданным цветом,</span>
<span class="co">// обведение контуром заданной ширины (сглаживание не реализовано).</span>
<span class="co">// Загружает и сохраняет 32-битные BMP без сжатия.</span>
<span class="ot">#include &lt;cassert&gt;</span>
<span class="ot">#include &lt;cstddef&gt; </span><span class="co">// size_t</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;cstdint&gt; </span><span class="co">// uint32_t etc</span>
<span class="ot">#include &lt;cstring&gt; </span><span class="co">// memcpy</span>
<span class="ot">#include &lt;utility&gt; </span><span class="co">// swap</span>
<span class="ot">#include &lt;stack&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;fstream&gt;</span>


<span class="co">///</span> Тип <span class="st">"цвет"</span><span class="co">.</span> Синоним <span class="dv">32</span>-битного беззнакового целого.
<span class="kw">using</span> Color = std::uint32_t;

<span class="co">///</span> Тип <span class="st">"координата"</span><span class="co">.</span> Синоним <span class="dv">32</span>-битного беззнакового целого.
<span class="kw">using</span> Coordinate = std::uint32_t;


<span class="co">///</span> Тип <span class="st">"точка"</span><span class="co">.</span> Имеет две координаты.
<span class="kw">struct</span> Point
{
  Coordinate x, y;
  <span class="co">///</span> Создать точку в начале координат.
  Point()
    : x(<span class="dv">0</span>), y(<span class="dv">0</span>) {}
  <span class="co">///</span> Создать точку с заданными координатами.
  Point(Coordinate x, Coordinate y)
    : x(x), y(y) {}
};


<span class="co">///</span> Тип <span class="st">"размеры"</span><span class="co"> </span>(прямоугольной области). Два размера: ширина и высота.
<span class="kw">struct</span> Extents
{
  Coordinate width, height;
  <span class="co">///</span> Создать область нулевых размеров.
  Extents()
    : width(<span class="dv">0</span>), height(<span class="dv">0</span>) {}
  <span class="co">///</span> Создать область с заданными шириной и высотой.
  Extents(Coordinate width, Coordinate height)
    : width(width), height(height) {}

  <span class="co">///</span> Вычислить площадь области.
  std::size_t area() <span class="dt">const</span> { <span class="kw">return</span> std::size_t(width) * height; }
  <span class="co">///</span> Проверить, выходят ли координаты точки за пределы области.
  <span class="dt">bool</span> contains(Point point) <span class="dt">const</span>
  {
    <span class="kw">return</span> point.x &lt; width &amp;&amp; point.y &lt; height;
  }
};


<span class="co">///</span> Тип <span class="st">"картинка"</span><span class="co">.</span> Управляет массивом пикселей.
<span class="kw">class</span> Picture
{
  Color *pixels; <span class="co">// упакованный двумерный массив</span>
  Extents extents;

  <span class="co">///</span> Выделить память и выполнить копирование данных из другой картинки.
  <span class="dt">void</span> copy_other(<span class="dt">const</span> Picture &amp;other)
  {
    <span class="dt">const</span> <span class="kw">auto</span> area = extents.area();
    pixels = <span class="kw">new</span> Color[area];
    std::memcpy(pixels, other.pixels, area);
  }

  <span class="co">///</span> Удостовериться, что координаты точки корректны.
  <span class="dt">void</span> assert_point(Point point) <span class="dt">const</span>
  {
    assert(extents.contains(point));
  }

<span class="kw">public</span>:
  <span class="co">///</span> Освободить занимаемую память.
  <span class="dt">void</span> clear()
  {
    <span class="kw">delete</span>[] pixels;
    pixels = <span class="kw">nullptr</span>;
    extents = Extents();
  }

  <span class="co">///</span> Обменять содержимое двух объектов.
  <span class="dt">void</span> swap(Picture &amp;other)
  {
    std::swap(pixels, other.pixels);
    std::swap(extents, other.extents);
  }

  <span class="co">///</span> Завершить существование объекта картинки.
  ~Picture() { clear(); }
  
  <span class="co">///</span> Создать пустую картинку.
  Picture()
    : pixels(<span class="kw">nullptr</span>) {}

  <span class="co">///</span> Создать картинку заданных размеров с неопределённым содержимым.
  <span class="kw">explicit</span> Picture(Extents extents)
    : pixels(<span class="kw">nullptr</span>), extents(extents)
  {
    pixels = <span class="kw">new</span> Color[extents.area()];
  }

  <span class="co">///</span> Создать копию картинки.
  Picture(<span class="dt">const</span> Picture &amp;other)
    : pixels(<span class="kw">nullptr</span>), extents(other.extents)
  {
    copy_other(other);
  }

  <span class="co">///</span> Скопировать картинку присваиванием.
  Picture&amp; <span class="kw">operator</span>=(<span class="dt">const</span> Picture &amp;other)
  {
    <span class="kw">return</span> *<span class="kw">this</span> = Picture(other);
  }

  <span class="co">///</span> Переместить картинку, не копируя данные.
  Picture(Picture &amp;&amp;other)
    : pixels(other.pixels), extents(other.extents)
  {
    other.pixels = <span class="kw">nullptr</span>;
    other.extents = Extents();
  }

  <span class="co">///</span> Переместить картинку при присваивании, не копируя данные.
  Picture&amp; <span class="kw">operator</span>=(Picture &amp;&amp;other)
  {
    assert(<span class="kw">this</span> != &amp;other);
    clear();
    swap(other);
    <span class="kw">return</span> *<span class="kw">this</span>;
  }

  <span class="co">///</span> Получить размеры картинки.
  <span class="dt">const</span> Extents&amp; size() <span class="dt">const</span> { <span class="kw">return</span> extents; }

  <span class="co">///</span> Получить указатель на пиксели.
  <span class="dt">const</span> Color* data() <span class="dt">const</span> { <span class="kw">return</span> pixels; }
  Color* data() { <span class="kw">return</span> pixels; }

  <span class="co">///</span> Обратиться к одному пикселю по его координатам.
  <span class="dt">const</span> Color&amp; <span class="kw">operator</span>()(Point point) <span class="dt">const</span>
  {
    assert_point(point);
    <span class="kw">return</span> pixels[point.x + extents.width * point.y];
  }

  Color&amp; <span class="kw">operator</span>()(Point point)
  {
    assert_point(point);
    <span class="kw">return</span> pixels[point.x + extents.width * point.y];
  }
};


<span class="co">///</span> Получить значение цвета в формате BGRX для заданных значений трёх каналов модели RGB.
<span class="kw">inline</span> Color bgrx(<span class="dt">unsigned</span> red, <span class="dt">unsigned</span> green, <span class="dt">unsigned</span> blue)
{
  <span class="kw">return</span> (blue &amp; <span class="bn">0xFF</span>) | ((green &amp; <span class="bn">0xFF</span>) &lt;&lt; <span class="dv">8</span>) | ((red &amp; <span class="bn">0xFF</span>) &lt;&lt; <span class="dv">16</span>);
}


<span class="co">///</span> Закрасить картинку целиком одним цветом.
<span class="dt">void</span> fill(Picture &amp;picture, Color color)
{
  <span class="dt">const</span> <span class="kw">auto</span> pixels = picture.size().area();
  <span class="dt">const</span> <span class="kw">auto</span> data = picture.data();
  <span class="kw">for</span> (std::size_t i = <span class="dv">0</span>; i &lt; pixels; ++i)
    data[i] = color;
}


<span class="co">///</span> Заливка связной области.
<span class="co">///</span> Рекурсия заменена на стек+цикл = поиск в глубину по соседним пикселям.
<span class="dt">void</span> flood_fill(Picture &amp;picture, Point start, Color color)
{
  <span class="dt">const</span> <span class="kw">auto</span> target_color = picture(start);
  std::stack&lt;Point&gt; points;
  points.push(start);
  <span class="kw">do</span>
  {
    start = points.top();
    points.pop();
    <span class="kw">if</span> (picture.size().contains(start) &amp;&amp; picture(start) == target_color)
    {
      picture(start) = color;
      points.emplace(start.x - <span class="dv">1</span>, start.y);
      points.emplace(start.x + <span class="dv">1</span>, start.y);
      points.emplace(start.x, start.y - <span class="dv">1</span>);
      points.emplace(start.x, start.y + <span class="dv">1</span>);
    }
  } <span class="kw">while</span> (!points.empty());
}


<span class="co">///</span> Обвести фрагменты заданного цвета (what) контуром заданной толщины (в пикселях).
<span class="co">///</span> Алгоритм основан на ограниченном поиске в ширину.
<span class="dt">void</span> make_outline(Picture &amp;picture, Color what, Color outline, <span class="dt">unsigned</span> width)
{
  <span class="kw">struct</span> Pos
  {
    Point pos;
    Color* ptr;
    <span class="dt">unsigned</span> distance;
    Pos(Coordinate x, Coordinate y, Color *ptr, <span class="dt">unsigned</span> d)
      : pos(x, y), ptr(ptr), distance(d) {}
  };

  std::queue&lt;Pos&gt; positions;
  <span class="dt">const</span> <span class="kw">auto</span> data = picture.data();
  <span class="dt">const</span> <span class="kw">auto</span> pw = picture.size().width,
             ph = picture.size().height;
  
  <span class="co">// Сканируем картинку в поисках пикселей цвета what и</span>
  <span class="co">// добавляем их координаты в очередь со значением distances == 0.</span>
  <span class="kw">for</span> (Coordinate row = <span class="dv">0</span>, i = <span class="dv">0</span>; row &lt; ph; ++row)
    <span class="kw">for</span> (Coordinate col = <span class="dv">0</span>; col &lt; pw; ++col, ++i)
      <span class="kw">if</span> (data[i] == what)
        positions.emplace(col, row, data + i, <span class="dv">0</span>);

  <span class="co">// Выполняем ограниченный по дальности поиск в ширину, используя накопленную очередь.</span>
  <span class="kw">while</span> (!positions.empty())
  {
    <span class="dt">const</span> <span class="kw">auto</span> &amp;cur = positions.front();
    <span class="dt">const</span> <span class="kw">auto</span> x = cur.pos.x, y = cur.pos.y;
    <span class="dt">const</span> <span class="kw">auto</span> ptr = cur.ptr;
    <span class="kw">auto</span> distance = cur.distance;
    positions.pop();

    <span class="kw">if</span> (*ptr != what)
      *ptr = outline;

    <span class="kw">if</span> (++distance &lt; width)
    {
      <span class="kw">if</span> (x != <span class="dv">0</span>)
        positions.emplace(x - <span class="dv">1</span>, y, ptr - <span class="dv">1</span>, distance);
      <span class="kw">if</span> (x != pw - <span class="dv">1</span>)
        positions.emplace(x + <span class="dv">1</span>, y, ptr + <span class="dv">1</span>, distance);
      <span class="kw">if</span> (y != <span class="dv">0</span>)
        positions.emplace(x, y - <span class="dv">1</span>, ptr - pw, distance);
      <span class="kw">if</span> (y != ph - <span class="dv">1</span>)
        positions.emplace(x, y + <span class="dv">1</span>, ptr + pw, distance);
    }
  }
}


<span class="co">// Загрузка и сохранение простого варианта BMP.</span>
<span class="co">// По данным https://en.wikipedia.org/wiki/BMP_file_format</span>

<span class="co">///</span> Follows minimalistic BITMAPINFOHEADER structure.
<span class="ot">#if defined(_MSC_VER) </span><span class="co">// Компилируем MSVC?</span>
<span class="ot">#pragma pack(push) </span><span class="co">// Сохранить текущее значение упаковки структур.</span>
<span class="ot">#pragma pack(1) </span><span class="co">// Нестандартное расширение MSVC: упакованная структура.</span>
<span class="kw">struct</span>
<span class="ot">#else</span>
<span class="kw">struct</span> <span class="ot">__attribute__</span>((packed)) <span class="co">// Нестандартное расширение GCC: упакованная структура.</span>
<span class="ot">#endif</span>
Bmp_header
{
  <span class="co">// BMP header</span>
  <span class="dt">char</span> b = <span class="st">'B'</span>, m = <span class="st">'M'</span>;
  std::uint32_t file_size = <span class="dv">54</span>; <span class="co">// == data_offset + pixels size in bytes</span>
  std::uint16_t reserved1 = <span class="dv">0</span>, reserved2 = <span class="dv">0</span>;
  std::uint32_t data_offset = <span class="dv">54</span>; <span class="co">// this header size in bytes</span>

  <span class="co">// DIB header (BITMAPINFOHEADER)</span>
  std::uint32_t header_size = <span class="dv">40</span>;
  std::int32_t bitmap_width = <span class="dv">0</span>, bitmap_height = <span class="dv">0</span>;
  std::uint16_t color_planes = <span class="dv">1</span>;
  std::uint16_t bpp = <span class="dv">32</span>; <span class="co">// bits per pixel</span>
  std::uint32_t compression_method = <span class="dv">0</span>; <span class="co">// 0 = none (BGRX), 3 = XBGR</span>
  std::uint32_t image_size = <span class="dv">0</span>;
  std::uint32_t x_dpi = <span class="dv">96</span>, y_dpi = <span class="dv">96</span>; <span class="co">// actually ignored</span>
  std::uint32_t palette_size = <span class="dv">0</span>;
  std::uint32_t important_colors = <span class="dv">0</span>;

  <span class="co">///</span> Конструктор по умолчанию (пустая картинка).
  Bmp_header() = <span class="kw">default</span>;
  <span class="co">///</span> Конструктор на основе картинки.
  <span class="kw">explicit</span> Bmp_header(<span class="dt">const</span> Picture &amp;picture)
  {
    bitmap_width = picture.size().width;
    bitmap_height = picture.size().height;
    file_size = <span class="dv">54</span> + picture.size().area() * <span class="kw">sizeof</span>(Color); <span class="co">// возможно переполнение</span>
  }

  <span class="co">///</span> Проверка заголовка на корректность (ограничено возможностями данной реализации).
  <span class="dt">bool</span> is_valid() <span class="dt">const</span>
  {
    <span class="kw">return</span> b == <span class="st">'B'</span> &amp;&amp; m == <span class="st">'M'</span> &amp;&amp;
      data_offset &gt;= <span class="dv">54</span> &amp;&amp; header_size &gt;= <span class="dv">40</span> &amp;&amp;
      bitmap_width != <span class="dv">0</span> &amp;&amp; bitmap_height != <span class="dv">0</span> &amp;&amp; color_planes == <span class="dv">1</span> &amp;&amp;
      bpp == <span class="dv">32</span> &amp;&amp; (compression_method == <span class="dv">0</span> || compression_method == <span class="dv">3</span>);
    <span class="co">// other values ignored</span>
  }
};
<span class="ot">#if defined(_MSC_VER)</span>
<span class="ot">#pragma pack(pop) </span><span class="co">// Восстановить предыдущее значение упаковки структур.</span>
<span class="ot">#endif</span>


<span class="co">// Вспомогательные функции, выполняющие насилие над системой типов</span>
<span class="co">// (конверсия произвольного указателя в указатель на char/const char).</span>
<span class="kw">inline</span> <span class="dt">char</span>* to_byte_ptr(<span class="dt">void</span> *ptr) { <span class="kw">return</span> (<span class="dt">char</span>*)ptr; }
<span class="kw">inline</span> <span class="dt">const</span> <span class="dt">char</span>* to_byte_ptr(<span class="dt">const</span> <span class="dt">void</span> *ptr) { <span class="kw">return</span> (<span class="dt">const</span> <span class="dt">char</span>*)ptr; }

<span class="co">///</span> Преобразование формата пикселя.
<span class="kw">inline</span> Color xbgr_to_bgrx(Color color)
{
  <span class="kw">return</span> (color &lt;&lt; <span class="dv">24</span>) | (color &gt;&gt; <span class="dv">8</span>);
}


<span class="co">///</span> Прочитать BMP из потока (фиксированный формат: <span class="dv">32</span> бита на пиксель, нет сжатия).
<span class="co">///</span> Поток должен быть открыт в двоичном режиме.
std::istream&amp; read_bmp_32bpp(std::istream &amp;is, Picture &amp;picture)
{
  <span class="co">// Считать заголовок из файла.</span>
  Bmp_header header;
  is.read(to_byte_ptr(&amp;header), header.data_offset);
  <span class="kw">if</span> (!is || !header.is_valid())
  {
    is.setstate(std::ios::failbit);
    <span class="kw">return</span> is;
  }

  <span class="co">// Создать картинку нужных размеров.</span>
  picture = Picture(Extents(header.bitmap_width, header.bitmap_height));
  <span class="co">// Пропустить заданное число байт после заголовка.</span>
  is.ignore(header.data_offset - <span class="kw">sizeof</span>(header));

  <span class="co">// Считать пиксели.</span>
  is.read(to_byte_ptr(picture.data()), picture.size().area() * <span class="kw">sizeof</span>(Color));

  <span class="co">// Если "метод компрессии" == 3 (RGBA, результат работы GIMP), обратить порядок байт.</span>
  <span class="kw">if</span> (header.compression_method == <span class="dv">3</span>)
  {
    <span class="dt">const</span> <span class="kw">auto</span> data = picture.data();
    <span class="dt">const</span> <span class="kw">auto</span> sz = picture.size().area();
    <span class="kw">for</span> (std::size_t i = <span class="dv">0</span>; i &lt; sz; ++i)
      data[i] = xbgr_to_bgrx(data[i]);
  }

  <span class="co">// Вернуть результирующую картинку.</span>
  <span class="kw">return</span> is;
}


<span class="co">///</span> Записать BMP в двоичный поток.
std::ostream&amp; write_bmp_32bpp(std::ostream &amp;os, <span class="dt">const</span> Picture &amp;picture)
{
  <span class="co">// Построить и записать в файл соответствующий картинке заголовок.</span>
  Bmp_header header(picture);
  os.write(to_byte_ptr(&amp;header), header.data_offset);

  <span class="co">// Записать пиксели.</span>
  os.write(to_byte_ptr(picture.data()), picture.size().area() * <span class="kw">sizeof</span>(Color));
  <span class="kw">return</span> os;
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Тестирование</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  <span class="co">// Test 1.</span>
  fstream bmp(<span class="st">"100x50orange.bmp"</span><span class="co">,</span> ios::binary | ios::out | ios::trunc);
  Picture picture(Extents(<span class="dv">100</span>, <span class="dv">50</span>));
  fill(picture, bgrx(<span class="dv">255</span>, <span class="dv">144</span>, <span class="dv">0</span>));
  write_bmp_32bpp(bmp, picture);
  bmp.close();

  <span class="co">// Test 2.</span>
  picture.clear();
  bmp.open(<span class="st">"input.bmp"</span><span class="co">,</span> ios::binary | ios::in);
  read_bmp_32bpp(bmp, picture);
  bmp.close();

  <span class="co">// Заливка белым из центра.</span>
  flood_fill(picture,
    Point(picture.size().width / <span class="dv">2</span>, picture.size().height / <span class="dv">2</span>),
    <span class="bn">0xFFFFFFFF</span>);

  bmp.open(<span class="st">"flood_fill.bmp"</span><span class="co">,</span> ios::binary | ios::out | ios::trunc);
  write_bmp_32bpp(bmp, picture);
  bmp.close();

  <span class="co">// Test 3.</span>
  picture.clear();
  bmp.open(<span class="st">"input.bmp"</span><span class="co">,</span> ios::binary | ios::in);
  read_bmp_32bpp(bmp, picture);
  bmp.close();

  <span class="co">// Белый контур вокруг чёрных пикселей.</span>
  make_outline(picture, bgrx(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>), bgrx(<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>), <span class="dv">4</span>);
  bmp.open(<span class="st">"outline.bmp"</span><span class="co">,</span> ios::binary | ios::out | ios::trunc);
  write_bmp_32bpp(bmp, picture);
  bmp.close();

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<h1 id="ageo2d.hpp">0900-ageo2d.hpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// ageo2d.hpp</span>
<span class="co">// Точки и вектора на плоскости, элементарные определения.</span>
<span class="ot">#ifndef AGEO2D_HPP_INCLUDED_</span>
<span class="ot">#define AGEO2D_HPP_INCLUDED_</span>

<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Вектора</span>

<span class="co">///</span> Двумерный вектор.
<span class="kw">struct</span> Vector_2
{
  <span class="dt">double</span> x, y;
  <span class="co">///</span> Конструктор по умолчанию -- нулевой вектор.
  Vector_2()
    : x(<span class="fl">0.</span>), y(<span class="fl">0.</span>) {}
  <span class="co">///</span> Создать вектор с заданными координатами.
  Vector_2(<span class="dt">double</span> x, <span class="dt">double</span> y)
    : x(x), y(y) {}

  <span class="co">///</span> Добавить другой вектор <span class="st">"на месте"</span><span class="co">.</span>
  Vector_2&amp; <span class="kw">operator</span>+=(<span class="dt">const</span> Vector_2 &amp;other)
  {
    x += other.x;
    y += other.y;
    <span class="kw">return</span> *<span class="kw">this</span>;
  }

  <span class="co">///</span> Вычесть другой вектор <span class="st">"на месте"</span><span class="co">.</span>
  Vector_2&amp; <span class="kw">operator</span>-=(<span class="dt">const</span> Vector_2 &amp;other)
  {
    x -= other.x;
    y -= other.y;
    <span class="kw">return</span> *<span class="kw">this</span>;
  }

  <span class="co">///</span> Домножить на скаляр <span class="st">"на месте"</span><span class="co">.</span>
  Vector_2&amp; <span class="kw">operator</span>*=(<span class="dt">double</span> factor)
  {
    x *= factor;
    y *= factor;
    <span class="kw">return</span> *<span class="kw">this</span>;
  }
};


<span class="co">///</span> Проверка пары векторов на равенство.
<span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>==(<span class="dt">const</span> Vector_2 &amp;a, <span class="dt">const</span> Vector_2 &amp;b)
{
  <span class="kw">return</span> a.x == b.x &amp;&amp; a.y == b.y;
}

<span class="co">///</span> Проверка пары векторов на неравенство.
<span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>!=(<span class="dt">const</span> Vector_2 &amp;a, <span class="dt">const</span> Vector_2 &amp;b)
{
  <span class="kw">return</span> !(a == b);
}

<span class="co">///</span> Сумма векторов: операция <span class="st">"+"</span><span class="co">.</span>
<span class="kw">inline</span> Vector_2 <span class="kw">operator</span>+(<span class="dt">const</span> Vector_2 &amp;a, <span class="dt">const</span> Vector_2 &amp;b)
{
  <span class="kw">return</span> Vector_2(a.x + b.x, a.y + b.y);
}

<span class="co">///</span> Разность векторов: операция <span class="st">"-"</span><span class="co">.</span>
<span class="kw">inline</span> Vector_2 <span class="kw">operator</span>-(<span class="dt">const</span> Vector_2 &amp;a, <span class="dt">const</span> Vector_2 &amp;b)
{
  <span class="kw">return</span> Vector_2(a.x - b.x, a.y - b.y);
}

<span class="co">///</span> Унарный минус.
<span class="kw">inline</span> Vector_2 <span class="kw">operator</span>-(<span class="dt">const</span> Vector_2 &amp;a)
{
  <span class="kw">return</span> Vector_2(-a.x, -a.y);
}

<span class="co">///</span> Умножение вектора на скаляр слева: операция <span class="st">"*"</span><span class="co">.</span>
<span class="kw">inline</span> Vector_2 <span class="kw">operator</span>*(<span class="dt">double</span> factor, <span class="dt">const</span> Vector_2 &amp;vec)
{
  <span class="kw">return</span> Vector_2(factor * vec.x, factor * vec.y);
}

<span class="co">///</span> Умножение вектора на скаляр справа: операция <span class="st">"*"</span><span class="co">.</span>
<span class="kw">inline</span> Vector_2 <span class="kw">operator</span>*(<span class="dt">const</span> Vector_2 &amp;vec, <span class="dt">double</span> factor)
{
  <span class="kw">return</span> factor * vec; <span class="co">// то же, что и слева</span>
}


<span class="co">///</span> Скалярное произведение векторов.
<span class="kw">inline</span> <span class="dt">double</span> dotp(<span class="dt">const</span> Vector_2 &amp;a, <span class="dt">const</span> Vector_2 &amp;b)
{
  <span class="kw">return</span> a.x * b.x + a.y * b.y;
}

<span class="co">///</span> Псевдоскалярное произведение векторов.
<span class="co">///</span> Равно произведению длин векторов на синус угла между ними.
<span class="kw">inline</span> <span class="dt">double</span> crossp(<span class="dt">const</span> Vector_2 &amp;a, <span class="dt">const</span> Vector_2 &amp;b)
{
  <span class="kw">return</span> a.x * b.y - a.y * b.x;
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Точки</span>

<span class="co">///</span> Точка на плоскости.
<span class="kw">struct</span> Point_2
{
  <span class="dt">double</span> x, y;
  <span class="co">///</span> Конструктор по умолчанию -- начало координат.
  Point_2()
    : x(<span class="fl">0.</span>), y(<span class="fl">0.</span>) {}
  <span class="co">///</span> Создать точку с заданными координатами.
  Point_2(<span class="dt">double</span> x, <span class="dt">double</span> y)
    : x(x), y(y) {}

  <span class="co">///</span> Радиус-вектор точки.
  Vector_2 radius() <span class="dt">const</span>
  {
    <span class="kw">return</span> Vector_2(x, y);
  }

  <span class="co">///</span> Сместить эту точку на заданный вектор.
  Point_2&amp; <span class="kw">operator</span>+=(<span class="dt">const</span> Vector_2 &amp;delta)
  {
    x += delta.x;
    y += delta.y;
    <span class="kw">return</span> *<span class="kw">this</span>;
  }

  <span class="co">///</span> Сместить эту точку на -delta.
  Point_2&amp; <span class="kw">operator</span>-=(<span class="dt">const</span> Vector_2 &amp;delta)
  {
    x -= delta.x;
    y -= delta.y;
    <span class="kw">return</span> *<span class="kw">this</span>;
  }
};

<span class="co">///</span> Проверка пары точек на равенство.
<span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>==(<span class="dt">const</span> Point_2 &amp;a, <span class="dt">const</span> Point_2 &amp;b)
{
  <span class="kw">return</span> a.x == b.x &amp;&amp; a.y == b.y;
}

<span class="co">///</span> Проверка пары точек на неравенство.
<span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>!=(<span class="dt">const</span> Point_2 &amp;a, <span class="dt">const</span> Point_2 &amp;b)
{
  <span class="kw">return</span> !(a == b);
}

<span class="co">///</span> Разность двух точек даёт вектор.
<span class="kw">inline</span> Vector_2 <span class="kw">operator</span>-(<span class="dt">const</span> Point_2 &amp;a, <span class="dt">const</span> Point_2 &amp;b)
{
  <span class="kw">return</span> Vector_2(a.x - b.x, a.y - b.y);
}

<span class="co">///</span> К точке можно добавить вектор, чтобы получить смещённую точку.
<span class="kw">inline</span> Point_2 <span class="kw">operator</span>+(<span class="dt">const</span> Point_2 &amp;a, <span class="dt">const</span> Vector_2 &amp;delta)
{
  <span class="kw">return</span> Point_2(a.x + delta.x, a.y + delta.y);
}

<span class="co">///</span> К точке можно добавить вектор, чтобы получить смещённую точку.
<span class="kw">inline</span> Point_2 <span class="kw">operator</span>+(<span class="dt">const</span> Vector_2 &amp;delta, <span class="dt">const</span> Point_2 &amp;a)
{
  <span class="kw">return</span> a + delta;
}

<span class="co">///</span> Из точки можно вычесть вектор, чтобы получить смещённую точку.
<span class="kw">inline</span> Point_2 <span class="kw">operator</span>-(<span class="dt">const</span> Point_2 &amp;a, <span class="dt">const</span> Vector_2 &amp;delta)
{
  <span class="kw">return</span> Point_2(a.x - delta.x, a.y - delta.y);
}

<span class="ot">#endif</span><span class="co">//AGEO2D_HPP_INCLUDED_</span></code></pre></div>
<p><br>
</p>
<h1 id="jarvis.cpp">0910-jarvis.cpp</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">﻿<span class="co">// jarvis.cpp</span>
<span class="co">// Алгоритм Джарвиса ("заворачивания подарка")</span>
<span class="co">// построения выпуклой оболочки множества точек на плоскости.</span>
<span class="ot">#include &lt;cassert&gt;</span>
<span class="ot">#include &lt;utility&gt; </span><span class="co">// swap</span>
<span class="ot">#include &lt;cmath&gt;   </span><span class="co">// abs</span>
<span class="ot">#include "ageo2d.hpp" </span><span class="co">// точки и вектора</span>


<span class="co">///</span> В диапазоне точек найти самую верхнюю из самых правых.
Point_2* find_highest_rightmost(Point_2 *begin, Point_2 *end)
{
  assert(begin &lt; end);
  <span class="dt">double</span> x_max = begin-&gt;x, y_max = begin-&gt;y;
  <span class="kw">auto</span> cur_max = begin;
  <span class="kw">while</span> (++begin != end)
  {
    <span class="kw">if</span> (x_max &lt; begin-&gt;x
     || begin-&gt;x == x_max &amp;&amp; y_max &lt; begin-&gt;y)
    {
      x_max = begin-&gt;x;
      y_max = begin-&gt;y;
      cur_max = begin;
    }
  }

  <span class="kw">return</span> cur_max;
}


<span class="co">///</span> В диапазоне точек найти самый дальний поворот по часовой стрелке от точки v.
Point_2* max_cw_turn(Point_2 *begin, Point_2 *end, Point_2 v)
{
  assert(begin &lt; end);
  <span class="kw">auto</span> cur_max = begin;
  <span class="kw">auto</span> vector = *begin - v; <span class="co">// воспользуемся оператором минус, определённым для точек выше</span>
  <span class="kw">while</span> (++begin != end)
  {
    <span class="dt">const</span> <span class="kw">auto</span> new_vector = *begin - v;
    <span class="dt">const</span> <span class="kw">auto</span> cp = crossp(vector, new_vector);
    <span class="kw">if</span> (cp &lt; <span class="fl">0.</span>   <span class="co">// поворот от vector к new_vector по ЧС?</span>
     || cp == <span class="fl">0.</span>  <span class="co">// коллинеарны, но сонаправленны и new_vector длиннее, чем vector?</span>
     &amp;&amp; dotp(vector, vector) &lt; dotp(vector, new_vector))
    {
      cur_max = begin;
      vector = new_vector;
    }
  }

  <span class="kw">return</span> cur_max;
}


<span class="co">///</span> Алгоритм заворачивания подарка.
<span class="co">///</span> Переставляет элементы исходного диапазона точек так,
<span class="co">///</span> чтобы вершины выпуклой оболочки в порядке обхода против часовой стрелки
<span class="co">///</span> встали в начале диапазона, возвращает указатель на следующую за последней
<span class="co">///</span> вершиной построенной выпуклой оболочки вершину.
Point_2* convex_hull_jarvis(Point_2 *begin, Point_2 *end)
{
  <span class="kw">using</span> std::swap;
  <span class="kw">if</span> (begin == end)
    <span class="kw">return</span> end;

  <span class="co">// Найти позицию самой верхней из самых правых точек.</span>
  <span class="co">// Это -- последняя вершина выпуклой оболочки.</span>
  <span class="kw">auto</span> cur = find_highest_rightmost(begin, end);
  <span class="co">// Потенциальная ошибка: если есть более одной точки, равной *cur,</span>
  <span class="co">// то алгоритм может выдать некорректный результат.</span>
  <span class="co">// Как можно исправить эту ситуацию?</span>
  
  <span class="co">// Поставить её в конец последовательности для того,</span>
  <span class="co">// чтобы корректно выйти из цикла, когда следующая вершина совпадёт с ней.</span>
  <span class="dt">const</span> <span class="kw">auto</span> last_pos = end - <span class="dv">1</span>;
  swap(*cur, *last_pos);
  cur = last_pos;

  <span class="co">// Цикл по вершинам выпуклой оболочки.</span>
  <span class="kw">while</span> (<span class="kw">true</span>)
  {
    <span class="dt">const</span> <span class="kw">auto</span> next = max_cw_turn(begin, end, *cur);
    <span class="co">// Поставить следующую вершину.</span>
    swap(*begin, *next);
    cur = begin++;

    <span class="kw">if</span> (next == last_pos) <span class="co">// Выпуклая оболочка построена.</span>
      <span class="kw">return</span> begin;
  }
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Геометрические операции, применяемые при тестировании</span>

<span class="co">///</span> Проверка многоугольника на строгую выпуклость.
<span class="dt">bool</span> is_strictly_convex(<span class="dt">const</span> Point_2 *begin, <span class="dt">const</span> Point_2 *end)
{
  <span class="kw">if</span> (end - begin &lt; <span class="dv">2</span>)
    <span class="kw">return</span> <span class="kw">true</span>; <span class="co">// одна точка</span>

  <span class="kw">if</span> (end - begin &lt; <span class="dv">3</span>)
    <span class="kw">return</span> begin[<span class="dv">0</span>] != begin[<span class="dv">1</span>]; <span class="co">// отрезок</span>

  <span class="co">// Проходя по всем углам (парам смежных рёбер) многоугольника,</span>
  <span class="co">// проверять, что поворот происходит строго против ЧС.</span>
  <span class="kw">auto</span> a = *(end - <span class="dv">2</span>), b = *(end - <span class="dv">1</span>);
  <span class="kw">do</span>
  {
    <span class="dt">const</span> <span class="kw">auto</span> c = *begin++;
    <span class="dt">const</span> <span class="kw">auto</span> <span class="co">// рёбра</span>
      ba = b - a,
      cb = c - b;

    <span class="co">// Проверить поворот от ba к cb.</span>
    <span class="kw">if</span> (crossp(ba, cb) &lt;= <span class="fl">0.</span>)
      <span class="kw">return</span> <span class="kw">false</span>;

    a = b;
    b = c;
  } <span class="kw">while</span> (begin != end);

  <span class="kw">return</span> <span class="kw">true</span>;
}


<span class="co">///</span> Положение точки относительно множества.
<span class="kw">enum</span> Point_location
{
  point_location_inside,   <span class="co">// внутри</span>
  point_location_boundary, <span class="co">// на границе</span>
  point_location_outside   <span class="co">// снаружи</span>
};

<span class="co">///</span> Определить положение точки p относительно многоугольника [begin, end),
<span class="co">///</span> в котором вершины перечислены в порядке обхода против часовой стрелки.
<span class="co">///</span> Осторожно: на результат может влиять погрешность вычислений.
<span class="co">///</span> Используется правило витков (== ненулевого индекса).
<span class="co">///</span> Алгоритм позаимствован с http:<span class="co">//geomalgorithms.com/a03-_inclusion.html</span>
Point_location locate_point
  (
    <span class="dt">const</span> Point_2 *begin, <span class="dt">const</span> Point_2 *end, <span class="co">// многоугольник</span>
    Point_2 p,                                <span class="co">// точка</span>
    <span class="dt">double</span> tolerance = <span class="fl">0.</span>                     <span class="co">// условный допуск на границе</span>
  )
{
  <span class="kw">using</span> std::abs;
  <span class="kw">if</span> (begin == end)
    <span class="kw">return</span> point_location_outside;

  <span class="dt">int</span> wn = <span class="dv">0</span>; <span class="co">// количество витков</span>
  <span class="co">// Проходя по всем рёбрам многоугольника, считать количество витков.</span>
  <span class="kw">auto</span> prev = *(end - <span class="dv">1</span>);
  <span class="kw">do</span>
  {
    <span class="dt">const</span> <span class="kw">auto</span> next = *begin++;
    <span class="dt">const</span> <span class="kw">auto</span>
      edge = next - prev,
      prad = p - prev;

    <span class="dt">const</span> <span class="kw">auto</span> cp = crossp(prad, edge);
    <span class="co">// Ребро пересекает луч снизу-вверх справа от точки p.</span>
    <span class="kw">if</span> (prev.y &lt;= p.y &amp;&amp; p.y &lt; next.y &amp;&amp; <span class="fl">0.</span> &lt; cp)
      ++wn;
    <span class="co">// Ребро пересекает луч сверху-вниз справа от точки p.</span>
    <span class="kw">else</span> <span class="kw">if</span> (next.y &lt;= p.y &amp;&amp; p.y &lt; prev.y &amp;&amp; cp &lt; <span class="fl">0.</span>)
      --wn;
    <span class="co">// Дополнительная проверка: точка лежит на ребре</span>
    <span class="kw">else</span> <span class="kw">if</span> (abs(cp) &lt;= tolerance
          &amp;&amp; dotp(prad, prad) &lt;= dotp(prad, edge))
      <span class="kw">return</span> point_location_boundary;

    prev = next;
  } <span class="kw">while</span> (begin != end);

  <span class="kw">return</span> wn == <span class="dv">0</span> ? point_location_outside : point_location_inside;
}


<span class="co">///////////////////////////////////////////////////////////////////////////////</span>
<span class="co">// Тестирование</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;random&gt;</span>


<span class="co">///</span> Тест на основе заранее известной оболочки.
<span class="dt">int</span> test_chj_0()
{
  Point_2 points[]
  {
    {  <span class="dv">0</span>,  <span class="dv">0</span> },
    { <span class="dv">10</span>,  <span class="dv">0</span> },
    {  <span class="dv">0</span>, <span class="dv">10</span> },
    { <span class="dv">10</span>, <span class="dv">10</span> },
    {  <span class="dv">0</span>,  <span class="dv">1</span> },
    {  <span class="dv">0</span>,  <span class="dv">0</span> },
    {  <span class="dv">5</span>,  <span class="dv">0</span> },
    {  <span class="dv">5</span>,  <span class="dv">5</span> },
    {  <span class="dv">2</span>,  <span class="dv">7</span> }
  };
  <span class="dt">const</span> <span class="kw">auto</span> points_sz = <span class="kw">sizeof</span>(points) / <span class="kw">sizeof</span>(Point_2);

  <span class="dt">const</span> Point_2 ch[]
  {
    {  <span class="dv">0</span>, <span class="dv">10</span> },
    {  <span class="dv">0</span>,  <span class="dv">0</span> },
    { <span class="dv">10</span>,  <span class="dv">0</span> },
    { <span class="dv">10</span>, <span class="dv">10</span> },
  };
  <span class="dt">const</span> <span class="kw">auto</span> ch_sz = <span class="kw">sizeof</span>(ch) / <span class="kw">sizeof</span>(Point_2);

  <span class="kw">if</span> (convex_hull_jarvis(points, points + points_sz)
    - points != ch_sz) <span class="co">// в оболочке должно быть ch_sz вершин</span>
    <span class="kw">return</span> <span class="dv">1</span>;
  
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; ch_sz; ++i)
    <span class="kw">if</span> (points[i] != ch[i])
      <span class="kw">return</span> <span class="dv">2</span>;
  <span class="kw">return</span> <span class="dv">0</span>;
}


<span class="co">///</span> Заполнить диапазон случайными точками с нормальным распределением по каждой координате.
<span class="co">///</span> Центр в нуле, среднеквадратичное отклонение единица.
<span class="dt">void</span> fill_random_normal(Point_2 *begin, Point_2 *end)
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  random_device seed_gen;      <span class="co">// генератор случайного зерна</span>
  mt19937_64 rng(seed_gen());  <span class="co">// генератор псевдослучайных последовательностей бит</span>
  normal_distribution&lt;&gt; distr; <span class="co">// нормальное распределение</span>
  <span class="kw">while</span> (begin != end)
    *begin++ = Point_2(distr(rng), distr(rng));
}


<span class="co">///</span> Проверить алгоритм выпуклой оболочки на заданном наборе точек.
<span class="dt">int</span> test_cvj_on(Point_2 *begin, Point_2 *end)
{
  <span class="dt">const</span> <span class="kw">auto</span> ch_end = convex_hull_jarvis(begin, end);
  <span class="kw">if</span> (!is_strictly_convex(begin, ch_end))
    <span class="kw">return</span> <span class="dv">1</span>;

  <span class="kw">for</span> (<span class="kw">auto</span> p = ch_end; p != end; ++p)
    <span class="kw">if</span> (locate_point(begin, ch_end, *p) != point_location_inside)
      <span class="kw">return</span> <span class="dv">2</span>;

  <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="co">///</span> Сгенерировать случайный набор точек и проверить на нём алгоритм выпуклой оболочки.
<span class="dt">int</span> test_cvj_1()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  random_device seed_gen;      <span class="co">// генератор случайного зерна</span>
  mt19937_64 rng(seed_gen());  <span class="co">// генератор псевдослучайных последовательностей бит</span>
  uniform_int_distribution&lt;&gt; distr(<span class="dv">3</span>, <span class="dv">2000</span>); <span class="co">// равномерное распределение на целых из [3, 2000]</span>

  <span class="co">// Случайное количество точек.</span>
  <span class="dt">const</span> <span class="kw">auto</span> sz = distr(rng);
  cout &lt;&lt; sz &lt;&lt; <span class="st">'</span><span class="ch">\t</span><span class="st">'</span>;
  <span class="kw">auto</span> points = <span class="kw">new</span> Point_2[sz];
  <span class="co">// Сгенерировать случайные точки.</span>
  fill_random_normal(points, points + sz);
  <span class="co">// Проверить работу алгоритма на этом наборе точек.</span>
  <span class="dt">const</span> <span class="kw">auto</span> result = test_cvj_on(points, points + sz);
  cout &lt;&lt; result &lt;&lt; endl;
  <span class="kw">delete</span>[] points;
  <span class="kw">return</span> result;
}


<span class="dt">int</span> main()
{
  <span class="kw">using</span> <span class="kw">namespace</span> std;
  cout &lt;&lt; test_chj_0() &lt;&lt; endl;
  <span class="kw">while</span> (<span class="kw">true</span>)
    assert(test_cvj_1() == <span class="dv">0</span>);

  <span class="kw">return</span> EXIT_SUCCESS;
}</code></pre></div>
<p><br>
</p>
<hr>
<p><a href="https://teccxx.neocities.org/mx1/index.html#contents">Общее оглавление</a></p>
<p>Кувшинов Д.Р. © 2015</p>
<p></p>


</body></html>